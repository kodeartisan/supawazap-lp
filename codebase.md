# next-env.d.ts

```ts
/// <reference types="next" /> /// <reference types="next/image-types/global" /> import "./.next/dev/types/routes.d.ts"; // NOTE: This file should not be edited // see https://nextjs.org/docs/app/api-reference/config/typescript for more information.
```

# next.config.ts

```ts
import type { NextConfig } from "next"; const nextConfig: NextConfig = { /* config options here */ reactCompiler: true, }; export default nextConfig;
```

# package.json

```json
{ "name": "supawazap-lp", "version": "0.1.0", "private": true, "scripts": { "dev": "next dev", "build": "next build", "start": "next start" }, "dependencies": { "@mantine/core": "^8.3.10", "@mantine/hooks": "^8.3.10", "lucide-react": "^0.561.0", "next": "16.0.10", "postcss": "^8.5.6", "postcss-preset-mantine": "^1.18.0", "postcss-simple-vars": "^7.0.1", "react": "19.2.1", "react-dom": "19.2.1" }, "devDependencies": { "@iconify/react": "^6.0.2", "@types/node": "^20", "@types/react": "^19", "@types/react-dom": "^19", "autoprefixer": "^10.4.23", "babel-plugin-react-compiler": "1.0.0", "tailwindcss": "^4.1.18", "typescript": "^5" } }
```

# postcss.config.cjs

```cjs
module.exports = { plugins: { "postcss-preset-mantine": {}, "postcss-simple-vars": { variables: { "mantine-breakpoint-xs": "36em", "mantine-breakpoint-sm": "48em", "mantine-breakpoint-md": "62em", "mantine-breakpoint-lg": "75em", "mantine-breakpoint-xl": "88em", }, }, }, };
```

# public/logo.png

This is a binary file of the type: Image

# public/mockup-3d.png

This is a binary file of the type: Image

# public/og-image.png

This is a binary file of the type: Image

# public/screenshots/chrome-store-1-broadcast.png

This is a binary file of the type: Image

# public/screenshots/chrome-store-2-quickreply.png

This is a binary file of the type: Image

# README.md

```md
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app). ## Getting Started First, run the development server: \`\`\`bash npm run dev # or yarn dev # or pnpm dev # or bun dev \`\`\` Open [http://localhost:3000](http://localhost:3000) with your browser to see the result. You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file. This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel. ## Learn More To learn more about Next.js, take a look at the following resources: - [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API. - [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial. You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome! ## Deploy on Vercel The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js. Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
```

# source-code.md

```md
# assets/icon.png This is a binary file of the type: Image # package.json \`\`\`json { "name": "supawazap", "displayName": "Supawazap: WhatsAppâ„¢ Web with Superpowers", "version": "1.0.0", "description": "Supercharge your WA with CRM, Bulk Sender, Scheduler, Workflow, Quick Reply, Export Contacts, and privacy tools.", "scripts": { "dev": "plasmo dev --no-cs-reload", "build": "plasmo build", "package": "plasmo package" }, "dependencies": { "@hello-pangea/dnd": "^18.0.1", "@lemonsqueezy/lemonsqueezy.js": "^4.0.0", "@mantine/core": "^8.3.9", "@mantine/dates": "^8.3.9", "@mantine/dropzone": "^8.3.9", "@mantine/form": "^8.3.9", "@mantine/hooks": "^8.3.9", "@plasmohq/messaging": "0.7.1", "@plasmohq/storage": "^1.15.0", "@wppconnect/wa-js": "^3.19.3", "axios": "^1.13.2", "clsx": "^2.1.1", "date-fns": "^4.1.0", "dayjs": "^1.11.19", "dexie": "^4.2.1", "dexie-react-hooks": "^4.2.0", "emoji-picker-react": "^4.16.1", "file-saver": "^2.0.5", "jquery": "^3.7.1", "lodash": "^4.17.21", "lucide-react": "^0.555.0", "mantine-datatable": "^8.3.8", "plasmo": "0.90.5", "react": "18.2.0", "react-dom": "18.2.0", "react-if": "^4.1.6", "webextension-polyfill": "^0.12.0", "xlsx": "^0.18.5", "zustand": "^5.0.8" }, "devDependencies": { "@ianvs/prettier-plugin-sort-imports": "4.1.1", "@iconify/react": "^6.0.2", "@types/chrome": "0.0.258", "@types/file-saver": "^2.0.7", "@types/jquery": "^3.5.33", "@types/lodash": "^4.17.21", "@types/node": "20.11.5", "@types/react": "18.2.48", "@types/react-dom": "18.2.18", "@types/webextension-polyfill": "^0.12.4", "postcss": "^8.5.6", "postcss-preset-mantine": "1.17.0", "postcss-simple-vars": "^7.0.1", "prettier": "3.2.4", "typescript": "5.3.3" }, "manifest": { "host_permissions": [ "https://web.whatsapp.com/*", "https://api.lemonsqueezy.com/*", "https://generativelanguage.googleapis.com/*" ], "permissions": [], "default_locale": "en" } } \`\`\` # postcss.config.cjs \`\`\`cjs module.exports = { plugins: { 'postcss-preset-mantine': {}, 'postcss-simple-vars': { variables: { 'mantine-breakpoint-xs': '36em', 'mantine-breakpoint-sm': '48em', 'mantine-breakpoint-md': '62em', 'mantine-breakpoint-lg': '75em', 'mantine-breakpoint-xl': '88em', }, }, }, } \`\`\` # README.md \`\`\`md This is a [Plasmo extension](https://docs.plasmo.com/) project bootstrapped with [`plasmo init`](https://www.npmjs.com/package/plasmo). ## Getting Started First, run the development server: \`\`\`bash pnpm dev # or npm run dev \`\`\` Open your browser and load the appropriate development build. For example, if you are developing for the chrome browser, using manifest v3, use: `build/chrome-mv3-dev`. You can start editing the popup by modifying `popup.tsx`. It should auto-update as you make changes. To add an options page, simply add a `options.tsx` file to the root of the project, with a react component default exported. Likewise to add a content page, add a `content.ts` file to the root of the project, importing some module and do some logic, then reload the extension on your browser. For further guidance, [visit our Documentation](https://docs.plasmo.com/) ## Making production build Run the following: \`\`\`bash pnpm build # or npm run build \`\`\` This should create a production bundle for your extension, ready to be zipped and published to the stores. ## Submit to the webstores The easiest way to deploy your Plasmo extension is to use the built-in [bpp](https://bpp.browser.market) GitHub action. Prior to using this action however, make sure to build your extension and upload the first version to the store to establish the basic credentials. Then, simply follow [this setup instruction](https://docs.plasmo.com/framework/workflows/submit) and you should be on your way for automated submission! \`\`\` # src/background/index.ts \`\`\`ts import { Setting } from '@/constants' import { storage } from '@/libs/storage' import { openWa } from '@/utils/ext' import browser from 'webextension-polyfill' browser.runtime.onInstalled.addListener(async (details) => { if (details.reason === 'install') { await storage.set(Setting.LICENSE_KEY, null) await storage.set(Setting.OPEN_SIDEBAR, true) await storage.set(Setting.BLUR_PROFILE_PICTURES, false) await storage.set(Setting.BLUR_MESSAGES, false) await storage.set(Setting.BLUR_USER_GROUP_NAMES, false) await storage.set(Setting.BLUR_RECENT_MESSAGES, false) await storage.set(Setting.UNBLUR_ON_HOVER, false) await openWa() } }) \`\`\` # src/background/messages/ai.ts \`\`\`ts import type { PlasmoMessaging } from '@plasmohq/messaging' const handler: PlasmoMessaging.MessageHandler = async (req, res) => { const { action, body } = req.body if (action === 'testConnection') { const { apiKey, model } = body if (!apiKey) { return res.send({ error: true, message: 'API Key is missing.', }) } try { // Simple handshake request to Gemini const response = await fetch( `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify({ contents: [ { parts: [ { text: 'Say "OK" if connected.', }, ], }, ], generationConfig: { maxOutputTokens: 5, }, }), }, ) const data = await response.json() if (!response.ok) { throw new Error( data.error?.message || 'Failed to connect to AI Provider', ) } res.send({ success: true, data: data, }) } catch (error: any) { console.error('AI Connection Test Error:', error) res.send({ error: true, message: error.message || 'Connection failed.', }) } } else { res.send({ error: 'Unknown action' }) } } export default handler \`\`\` # src/background/messages/http.ts \`\`\`ts import http from '@/libs/http' import type { PlasmoMessaging } from '@plasmohq/messaging' const handler: PlasmoMessaging.MessageHandler = async (req, res) => { const { url, method, data, config } = req.body const httpInstance = { POST: () => { return http.post(url, data, config) }, GET: () => { return http.get(url, config) }, } const result = await httpInstance[method]?.() return res.send(result.data) } export default handler \`\`\` # src/background/messages/ls.ts \`\`\`ts import lemonSqueezy from '@/libs/ls' import type { PlasmoMessaging } from '@plasmohq/messaging' import pkg from '../../../package.json' const handler: PlasmoMessaging.MessageHandler = async (req, res) => { const { action, body } = req.body try { let response switch (action) { case 'validateLicense': response = await lemonSqueezy.validateLicense(body.licenseKey) break case 'activateLicense': response = await lemonSqueezy.activateLicense(body.licenseKey, pkg.name) break case 'deactivateLicense': response = await lemonSqueezy.deactivateLicense( body.licenseKey, body.instanceId, ) break case 'getCustomer': response = await lemonSqueezy.getCustomer(body.customerId) break default: return res.send({ error: 'Invalid Lemon Squeezy action' }) } res.send(response) } catch (error) { res.send({ error: true, message: error.message || 'An unknown error occurred.', }) } } export default handler \`\`\` # src/background/messages/open-workflow.ts \`\`\`ts import type { PlasmoMessaging } from '@plasmohq/messaging' import browser from 'webextension-polyfill' const handler: PlasmoMessaging.MessageHandler = async (req, res) => { const { workflowId } = req.body try { const url = chrome.runtime.getURL(`tabs/workflow.html?id=${workflowId}`) await browser.tabs.create({ url }) res.send({ success: true }) } catch (error) { console.error('Failed to open workflow tab:', error) res.send({ error: error.message }) } } export default handler \`\`\` # src/components/AlertBanner.tsx \`\`\`tsx import useLicense from '@/hooks/useLicense' import { Icon } from '@iconify/react' import { Alert, Box, Button, Group, Text } from '@mantine/core' import React from 'react' interface AlertBannerProps { message: string linkText?: string linkHref?: string onLinkClick?: () => void } const AlertBanner: React.FC<AlertBannerProps> = ({ message, linkText = 'Upgrade now!', linkHref = 'https://supawazap.com/#pricing', onLinkClick, }) => { const license = useLicense() // Only show for free users if (!license.isFree()) { return <Box mb={3} /> } const handleClick = () => { if (onLinkClick) { onLinkClick() } else { window.open(linkHref, '_blank') } } return ( <Alert color="orange" icon={ <Icon style={{ marginTop: 10 }} icon="tabler:alert-triangle" fontSize={18} /> } styles={{ root: { padding: '2px 6px' }, icon: { marginRight: 8 }, }} > <Group justify="space-between" align="center" wrap="nowrap"> <Text size="sm" fw={500}> {message} </Text> <Button size="xs" leftSection={<Icon icon="tabler:crown" fontSize={14} />} onClick={handleClick} styles={{ root: { backgroundImage: 'linear-gradient(90deg, #f59e0b, #f97316)', boxShadow: '0 0 15px rgba(249, 115, 22, 0.3)', fontWeight: 700, border: 'none', transition: 'transform 0.2s ease, box-shadow 0.2s ease', '&:hover': { transform: 'scale(1.02)', boxShadow: '0 0 20px rgba(249, 115, 22, 0.5)', }, }, }} > {linkText} </Button> </Group> </Alert> ) } export default AlertBanner \`\`\` # src/components/App.module.css \`\`\`css /* Sidebar Tab Styling */ .tab { transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); color: var(--matrix-text-secondary); border-radius: 12px; margin-bottom: 4px; } .tab:hover { background-color: var(--matrix-glass-overlay); color: var(--matrix-text-primary); transform: translateX(-2px); } .tab[data-active] { background: var(--matrix-bg-card); color: var(--matrix-emerald-400); border: 1px solid var(--matrix-border-highlight); box-shadow: 0 0 15px rgba(16, 185, 129, 0.1); position: relative; } .tab[data-active]::before { content: ''; position: absolute; left: -1px; top: 10%; bottom: 10%; width: 3px; background: var(--matrix-emerald-500); border-radius: 0 4px 4px 0; box-shadow: 0 0 8px var(--matrix-emerald-500); } \`\`\` # src/components/App.tsx \`\`\`tsx import { Action, Page, Setting } from '@/constants' import StatusListener from '@/features/status/components/StatusListener' import WorkflowListener from '@/features/workflow/components/WorkflowListener' import PageWorkflow from '@/features/workflow/PageWorkflow' import useLicense from '@/hooks/useLicense' import useWa from '@/hooks/useWa' import useWindowMessage from '@/hooks/useWindowMessage' import { useAppStore } from '@/stores/app' import env from '@/utils/env' import { Icon } from '@iconify/react' import { ActionIcon, Group, Paper, Stack, Tabs, ThemeIcon, Tooltip, } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import { useStorage } from '@plasmohq/storage/hook' import React, { useEffect, useState } from 'react' import { When } from 'react-if' import PageBroadcast from '../features/broadcast/PageBroadcast' import PageContactInfo from '../features/contacts/PageContactInfo' // ++ ADDED import PageContacts from '../features/contacts/PageContacts' import ModalDirectChat from '../features/direct-chat/ModalDirectChat' import PagePrivacy from '../features/privacy/PagePrivacy' import PageQuickReply from '../features/quick-reply/PageQuickReply' import PageStatus from '../features/status/PageStatus' import PageTools from '../features/tools/PageTools' import classes from './App.module.css' import BroadcastListener from './Listeners/BroadcastListener' import PrivacyListener from './Listeners/PrivacyListener' import ModalActivation from './Modal/ModalActivation' import ModalFaq from './Modal/ModalFaq' import ModalPricing from './Modal/ModalPricing' import ModalProfile from './Modal/ModalProfile' // Add CONTACT_INFO to constants/index.ts ideally, but defining locally for safety if constant file isn't updated yet. const PAGE_CONTACT_INFO = 'CONTACT_INFO' const App: React.FC = () => { const wa = useWa() const { setIsReady, setGroups, setActiveChat, // ++ ADDED: Destructure the setter for selected contact setSelectedContact, } = useAppStore() const [openSidebar, setOpenSidebar] = useStorage(Setting.OPEN_SIDEBAR, true) const license = useLicense() // Modals const [showModalActivation, modalActivation] = useDisclosure(false) const [showModalFaq, modalFaq] = useDisclosure(false) const [showModalProfile, modalProfile] = useDisclosure(false) const [showModalPricing, modalPricing] = useDisclosure(false) const [showModalDirectChat, modalDirectChat] = useDisclosure(false) const [activeTab, setActiveTab] = useState<string | null>(null) useWindowMessage(async (event: MessageEvent) => { const { data: { action, body }, } = event switch (action) { case Action.Window.READY: setIsReady(true) break case Action.Window.ACTIVE_CHAT: setActiveChat(body) // ++ ADDED: Clear specific selected contact when user switches chat in WA, // so the panel automatically updates to the new active chat. setSelectedContact(null) break case Action.Window.GO_TO_PAGE: if (typeof body === 'object' && body.page) { if (body.page === PAGE_CONTACT_INFO) { if (body.data) { setSelectedContact(body.data) } setActiveTab(PAGE_CONTACT_INFO) } else { setActiveTab(body.page) } } else { setActiveTab(body) } break case Action.Window.SHOW_CONTACT_INFO: setActiveTab(PAGE_CONTACT_INFO) break case Action.Window.CLOSE_PAGE: setActiveTab(null) break case Action.Window.SHOW_MODAL_PRICING: modalPricing.toggle() break case Action.Window.SHOW_MODAL_ACTIVATION: modalActivation.toggle() break case Action.Window.SHOW_MODAL_FAQ: modalFaq.toggle() break case Action.Window.SHOW_MODAL_PROFILE: modalProfile.toggle() break default: break } }) useEffect(() => { license.init().then().catch(console.error) }, []) useEffect(() => { ;(async function () { if (!wa.isReady) return setTimeout(async () => { const groups = await wa.group.list() setGroups(groups) }, 3000) })() }, [wa.isReady]) const handleChangeTab = async (value: string) => { if (Page.UPGRADE === value) { window.open('https://supawazap.com/#pricing', '_blank') return } if (Page.ACTIVATE === value) { modalActivation.toggle() return } if (Page.FAQ === value) { window.open('https://supawazap.com/#faqs', '_blank') return } if (Page.PROFILE === value) { modalProfile.toggle() return } if (Page.DIRECT_CHAT === value) { modalDirectChat.toggle() return } if (Page.CLOSE === value) { await setOpenSidebar(false) return } setActiveTab(value) } const renderTabList = ( <Paper shadow="xs" style={{ height: '100%' }} radius={0}> <Tabs.List style={{ gap: 0, height: '100%', flexDirection: 'row', borderLeft: '1px solid var(--mantine-color-gray-8)', }} > <Stack justify="space-between" gap={0}> <Stack gap={0}> <Tabs.Tab value={Page.BROADCAST} className={classes.tab} py={6}> <Tooltip label="Broadcast"> <ThemeIcon variant="transparent" style={{ cursor: 'pointer' }} c="var(--mantine-primary-color-6)" > <Icon icon="tabler:broadcast" fontSize={24} /> </ThemeIcon> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.WORKFLOW} className={classes.tab} py={6}> <Tooltip label="Workflow"> <ThemeIcon variant="transparent" style={{ cursor: 'pointer' }} c="var(--mantine-primary-color-6)" > <Icon icon="tabler:robot" fontSize={24} /> </ThemeIcon> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.QUICK_REPLY} className={classes.tab} py={6}> <Tooltip label="Quick Reply"> <ThemeIcon variant="transparent" style={{ cursor: 'pointer' }} c="var(--mantine-primary-color-6)" > <Icon icon="tabler:bolt" fontSize={24} /> </ThemeIcon> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.CONTACTS} className={classes.tab} py={6}> <Tooltip label="Contacts"> <ThemeIcon variant="transparent" style={{ cursor: 'pointer' }} c="var(--mantine-primary-color-6)" > <Icon icon="tabler:address-book" fontSize={24} /> </ThemeIcon> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.DIRECT_CHAT} className={classes.tab} py={6}> <Tooltip label="Direct Chat"> <ThemeIcon variant="transparent" style={{ cursor: 'pointer' }} c="var(--mantine-primary-color-6)" > <Icon icon="tabler:message-plus" fontSize={24} /> </ThemeIcon> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.STATUS} className={classes.tab} py={6}> <Tooltip label="Status"> <ThemeIcon variant="transparent" style={{ cursor: 'pointer' }} c="var(--mantine-primary-color-6)" > <Icon icon="tabler:history-toggle" fontSize={24} /> </ThemeIcon> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.PRIVACY} className={classes.tab} py={6}> <Tooltip label="Privacy"> <ThemeIcon variant="transparent" style={{ cursor: 'pointer' }} c="var(--mantine-primary-color-6)" > <Icon icon="tabler:eye-off" fontSize={24} /> </ThemeIcon> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.TOOLS} className={classes.tab} py={6}> <Tooltip label="Tools"> <ThemeIcon variant="transparent" style={{ cursor: 'pointer' }} c="var(--mantine-primary-color-6)" > <Icon icon="tabler:tools" fontSize={24} /> </ThemeIcon> </Tooltip> </Tabs.Tab> </Stack> <Stack gap={0}> <Tabs.Tab value={Page.UPGRADE} className={classes.tab} py={6}> <Tooltip label="Upgrade"> <ThemeIcon variant="transparent" style={{ cursor: 'pointer' }} c="orange" > <Icon icon="tabler:crown" fontSize={24} /> </ThemeIcon> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.ACTIVATE} className={classes.tab} py={6}> <Tooltip label="Activate"> <ThemeIcon variant="transparent" style={{ cursor: 'pointer' }} c="var(--mantine-primary-color-6)" > <Icon icon="tabler:key" fontSize={24} /> </ThemeIcon> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.FAQ} className={classes.tab} py={6}> <Tooltip label="Faqs"> <ThemeIcon variant="transparent" style={{ cursor: 'pointer' }} c="var(--mantine-primary-color-6)" > <Icon icon="tabler:help-circle" fontSize={24} /> </ThemeIcon> </Tooltip> </Tabs.Tab> <Tabs.Tab value={Page.CLOSE} className={classes.tab} py={6}> <Tooltip label="Close"> <ThemeIcon variant="transparent" color="red" style={{ cursor: 'pointer' }} > <Icon icon="tabler:x" fontSize={24} /> </ThemeIcon> </Tooltip> </Tabs.Tab> </Stack> </Stack> </Tabs.List> </Paper> ) const renderTabPanel = ( <> <Tabs.Panel value={Page.BROADCAST}> <PageBroadcast /> </Tabs.Panel> <Tabs.Panel value={Page.CONTACTS}> <PageContacts /> </Tabs.Panel> {/* ++ ADDED: Panel for Contact Info */} <Tabs.Panel value={PAGE_CONTACT_INFO}> <PageContactInfo /> </Tabs.Panel> <Tabs.Panel value={Page.QUICK_REPLY}> <PageQuickReply /> </Tabs.Panel> <Tabs.Panel value={Page.WORKFLOW}> <PageWorkflow /> </Tabs.Panel> <Tabs.Panel value={Page.STATUS}> <PageStatus /> </Tabs.Panel> <Tabs.Panel value={Page.PRIVACY}> <PagePrivacy /> </Tabs.Panel> <Tabs.Panel value={Page.TOOLS}> <PageTools /> </Tabs.Panel> </> ) return ( <> <When condition={wa.isReady}> <div style={{ position: 'fixed', right: 0, top: 0, height: '100vh', zIndex: 1000, transform: openSidebar ? 'translateX(0)' : 'translateX(100%)', transition: 'transform 0.4s cubic-bezier(0.16, 1, 0.3, 1)', willChange: 'transform', }} > <Group> <Tabs inverted orientation="vertical" variant="pills" radius={0} value={activeTab} onChange={handleChangeTab} style={{ height: '100vh', }} > {renderTabPanel} <Paper radius={0}>{renderTabList}</Paper> </Tabs> </Group> </div> <div style={{ position: 'fixed', right: 0, bottom: 80, zIndex: 999, opacity: openSidebar ? 0 : 1, transform: openSidebar ? 'translateX(20px)' : 'translateX(0)', pointerEvents: openSidebar ? 'none' : 'auto', transition: 'all 0.3s ease', }} > <Tooltip label="Open"> <ActionIcon w={35} h={35} onClick={async () => { await setOpenSidebar(true) }} style={{ borderRadius: '14px 0px 0px 14px', boxShadow: '0 4px 12px rgba(0,0,0,0.3)', border: '1px solid rgba(255,255,255,0.1)', backgroundColor: 'rgba(0,0,0,0.6)', backdropFilter: 'blur(8px)', }} > <Icon icon="tabler:layout-sidebar-right-expand" fontSize={20} color="var(--matrix-emerald-400)" /> </ActionIcon> </Tooltip> </div> </When> {/* Modals */} <ModalActivation opened={showModalActivation} onClose={modalActivation.close} /> <ModalFaq opened={showModalFaq} onClose={modalFaq.close} /> <ModalProfile opened={showModalProfile} onClose={modalProfile.close} /> <ModalPricing opened={showModalPricing} onClose={modalPricing.close} /> <ModalDirectChat opened={showModalDirectChat} onClose={modalDirectChat.close} /> {/* Listeners */} <BroadcastListener /> <PrivacyListener /> <StatusListener /> <WorkflowListener /> </> ) } export default App \`\`\` # src/components/Confirm/Confirm.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import { useConfirmStore } from '@/stores/confirm' import { Icon } from '@iconify/react' import { Button, Group, Stack, Text, ThemeIcon, Title } from '@mantine/core' import React from 'react' const Confirm: React.FC = () => { const { options, hide } = useConfirmStore() if (!options) return null const { title, message, type, onConfirm, onCancel } = options const getIcon = () => { switch (type) { case 'danger': return 'tabler:alert-triangle' case 'warning': return 'tabler:alert-circle' case 'success': return 'tabler:circle-check' default: return 'tabler:info-circle' } } const getColor = () => { switch (type) { case 'danger': return 'red' case 'warning': return 'orange' case 'success': return 'teal' default: return 'blue' } } return ( <Modal opened={!!options} onClose={onCancel} w={400} withCloseButton={false} > <Stack align="center" gap="md" p="md"> <ThemeIcon variant="light" size={60} radius="xl" color={getColor()}> <Icon icon={getIcon()} fontSize={32} /> </ThemeIcon> <Stack gap="xs" align="center"> <Title order={4} ta="center"> {title} </Title> <Text c="dimmed" size="sm" ta="center"> {message} </Text> </Stack> <Group w="100%" grow mt="md"> <Button variant="default" onClick={onCancel}> Cancel </Button> <Button color={getColor()} onClick={onConfirm}> Confirm </Button> </Group> </Stack> </Modal> ) } export default Confirm \`\`\` # src/components/Confirm/ConfirmProvider.tsx \`\`\`tsx import React from 'react' import Confirm from './Confirm' const ConfirmProvider: React.FC = () => { return <Confirm /> } export default ConfirmProvider \`\`\` # src/components/Datatable/MessageType.tsx \`\`\`tsx import { Message } from '@/constants' import { Icon } from '@iconify/react' import { Group, Text } from '@mantine/core' import _ from 'lodash' import React from 'react' interface Props { type: string } const MessageType: React.FC<Props> = ({ type }: Props) => { const icons: Record<string, string> = { [Message.TEXT]: 'tabler:text-size', [Message.MEDIA]: 'tabler:photo', [Message.IMAGE]: 'tabler:photo', [Message.VIDEO]: 'tabler:video', [Message.FILE]: 'tabler:file', [Message.BUTTON]: 'tabler:hand-click', [Message.LIST]: 'tabler:list', [Message.LOCATION]: 'tabler:map-pin', [Message.POLL]: 'tabler:chart-bar', [Message.VCARD]: 'tabler:id', } const icon = icons[type] ?? 'tabler:message' return ( <Group gap={4} wrap="nowrap"> <Icon icon={icon} fontSize={18} /> <Text size="sm">{_.startCase(type?.toLowerCase())}</Text> </Group> ) } export default MessageType \`\`\` # src/components/Input/InputSendLater.tsx \`\`\`tsx import useLicense from '@/hooks/useLicense' import toast from '@/utils/toast' // ++ ADDED: Import toast import { showModalUpgrade } from '@/utils/util' import { Icon } from '@iconify/react' import { Badge, Group, Stack, Switch, Text, TextInput, Tooltip, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' import { When } from 'react-if' interface Props { form: UseFormReturnType<any> } const InputSendLater: React.FC<Props> = ({ form }: Props) => { const license = useLicense() return ( <Stack> <Switch label={ <Group gap={4} wrap="nowrap"> <Text fw={500}>Send later</Text> {license.isFree() && ( <Badge color="yellow" variant="light" size="sm"> Pro </Badge> )} <Tooltip label="Schedule your broadcast to be sent at a specific date and time in the future." position="top-start" multiline w={350} withArrow > <Icon icon="tabler:info-circle" style={{ display: 'block' }} /> </Tooltip> </Group> } {...form.getInputProps('scheduler.enabled', { type: 'checkbox' })} onChange={(event) => { if (license.isFree()) { toast.warning('Only for Pro users, Please Upgrade', 'Warning') showModalUpgrade() return } form.setFieldValue('scheduler.enabled', event.currentTarget.checked) }} checked={ license.isFree() ? false : form.values.scheduler?.enabled || false } /> <When condition={form.values.scheduler.enabled && !license.isFree()}> <TextInput label="Date time" size="sm" type="datetime-local" {...form.getInputProps('scheduler.scheduledAt')} /> </When> </Stack> ) } export default InputSendLater \`\`\` # src/components/Input/InputTextarea.tsx \`\`\`tsx import { Icon } from '@iconify/react' import { ActionIcon, Button, Group, Popover, Stack, Textarea, Tooltip, } from '@mantine/core' import EmojiPicker, { Theme, type EmojiClickData } from 'emoji-picker-react' import React, { useRef, useState } from 'react' interface Variable { label: string variable: string } interface Props { value: string onChange: (value: string) => void error?: any placeholder?: string | null variables?: Variable[] } const InputTextarea: React.FC<Props> = ({ value, onChange, error = null, placeholder = 'Enter your message here...', variables = [ { label: 'Name', variable: '{name}' }, { label: 'Number', variable: '{number}' }, ], }) => { const textareaRef = useRef<HTMLTextAreaElement>(null) const [emojiPickerOpened, setEmojiPickerOpened] = useState(false) const insertEmoji = (emojiData: EmojiClickData) => { const textarea = textareaRef.current if (!textarea) return const start = textarea.selectionStart const end = textarea.selectionEnd const emoji = emojiData.emoji const newText = value.substring(0, start) + emoji + value.substring(end) onChange(newText) // Kembalikan fokus dan posisi kursor setTimeout(() => { const newPosition = start + emoji.length textarea.focus() textarea.setSelectionRange(newPosition, newPosition) }, 0) } const applyFormat = (startTag: string, endTag: string = '') => { const textarea = textareaRef.current if (!textarea) return const start = textarea.selectionStart const end = textarea.selectionEnd const selectedText = value.substring(start, end) const newText = value.substring(0, start) + startTag + (selectedText || '') + endTag + value.substring(end) onChange(newText) setTimeout(() => { const newPosition = start + startTag.length + (selectedText.length || 0) textarea.focus() textarea.setSelectionRange(newPosition, newPosition) }, 0) } const insertVariable = (variable: string) => { const textarea = textareaRef.current if (!textarea) return const start = textarea.selectionStart const end = textarea.selectionEnd const newText = value.substring(0, start) + variable + value.substring(end) onChange(newText) setTimeout(() => { const newPosition = start + variable.length textarea.focus() textarea.setSelectionRange(newPosition, newPosition) }, 0) } const insertSpintaxExample = () => { applyFormat('{Hello|Hi|Hey}') } return ( <Stack gap={4}> <Group justify="space-between"> <Group gap={4}> <Tooltip label="Bold" withArrow> <ActionIcon size="sm" variant="subtle" onClick={() => applyFormat('*', '*')} > <Icon icon="tabler:bold" fontSize={16} /> </ActionIcon> </Tooltip> <Tooltip label="Italic" withArrow> <ActionIcon size="sm" variant="subtle" onClick={() => applyFormat('_', '_')} > <Icon icon="tabler:italic" fontSize={16} /> </ActionIcon> </Tooltip> <Tooltip label="Strikethrough" withArrow> <ActionIcon size="sm" variant="subtle" onClick={() => applyFormat('~', '~')} > <Icon icon="tabler:strikethrough" fontSize={16} /> </ActionIcon> </Tooltip> <Tooltip label="Monospace" withArrow> <ActionIcon size="sm" variant="subtle" onClick={() => applyFormat('\`\`\`', '\`\`\`')} > <Icon icon="tabler:code" fontSize={16} /> </ActionIcon> </Tooltip> <Tooltip label="Spintax: {Hi|Hello}" w={200} multiline withArrow> <ActionIcon size="sm" variant="subtle" onClick={insertSpintaxExample} > <Icon icon="tabler:arrows-shuffle" fontSize={16} /> </ActionIcon> </Tooltip> <Popover opened={emojiPickerOpened} onChange={setEmojiPickerOpened} position="bottom-start" shadow="md" > <Popover.Target> <Tooltip label="Emoji" withArrow> <ActionIcon size="sm" variant="subtle" onClick={() => setEmojiPickerOpened((o) => !o)} > <Icon icon="tabler:mood-smile" fontSize={16} /> </ActionIcon> </Tooltip> </Popover.Target> <Popover.Dropdown p={0}> <EmojiPicker theme={Theme.AUTO} onEmojiClick={(emojiData) => { insertEmoji(emojiData) setEmojiPickerOpened(false) }} width={350} height={400} previewConfig={{ showPreview: false }} searchDisabled /> </Popover.Dropdown> </Popover> </Group> </Group> <Textarea ref={textareaRef} value={value} onChange={(event) => onChange(event.currentTarget.value)} placeholder={placeholder || ''} minRows={6} maxRows={12} autosize error={error} /> {variables.length > 0 && ( <Group gap="xs" mt="xs" align="center"> {variables.map((v) => ( <Button key={v.variable} variant="default" size="compact-xs" onClick={() => insertVariable(v.variable)} > {v.label} </Button> ))} </Group> )} </Stack> ) } export default InputTextarea \`\`\` # src/components/Input/InputTyping.tsx \`\`\`tsx // src/features/broadcast/components/Input/InputTyping.tsx import useLicense from '@/hooks/useLicense' import { Icon } from '@iconify/react' import { Group, Switch, Text, Tooltip } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' interface Props { form: UseFormReturnType<any> } const InputTyping: React.FC<Props> = ({ form }: Props) => { return ( <Switch label={ <Group gap={4} wrap="nowrap"> <Text fw={500}>Typing effect</Text> <Tooltip label='Show "Typing..." status to the recipient to mimic human behavior and reduce the risk of being flagged.' position="top-start" multiline w={300} withArrow > <Icon icon="tabler:info-circle" style={{ display: 'block' }} /> </Tooltip> </Group> } {...form.getInputProps('isTyping', { type: 'checkbox' })} /> ) } export default InputTyping \`\`\` # src/components/Input/Message/InputMessage.tsx \`\`\`tsx import { Media, Message } from '@/constants' import useLicense from '@/hooks/useLicense' import db, { type BroadcastTemplate } from '@/libs/db' import toast from '@/utils/toast' import { showModalUpgrade } from '@/utils/util' import { Icon } from '@iconify/react' import { ActionIcon, Badge, // ++ ADDED Box, Button, Fieldset, Group, ScrollArea, Stack, Text, TextInput, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' import { When } from 'react-if' import InputTextarea from '../InputTextarea' import SelectTemplate from './SelectTemplate' import Upload from './Upload' interface Props { form: UseFormReturnType<any> allowProTypes?: boolean withTemplateSelector?: boolean } const InputMessage: React.FC<Props> = ({ form, allowProTypes = false, withTemplateSelector = false, }) => { const license = useLicense() const handleTypeChange = (type: string, isPro: boolean) => { form.setFieldValue('type', type) } // ... [handleTemplateSelect function remains the same] ... const handleTemplateSelect = async (template: BroadcastTemplate) => { const { type, message, id } = template const isProType = [ Message.IMAGE, Message.VIDEO, Message.AUDIO, Message.FILE, Message.LOCATION, Message.POLL, ].includes(type) if (isProType && license.isFree()) { toast.error('Templates with rich media are restricted to Pro users.') showModalUpgrade() return } form.setFieldValue('type', type) // Reset fields logic... form.setFieldValue('inputText', '') form.setFieldValue('inputImage', { file: null, caption: '' }) form.setFieldValue('inputVideo', { file: null, caption: '' }) form.setFieldValue('inputAudio', { file: null }) form.setFieldValue('inputFile', { file: null, caption: '' }) switch (type) { case Message.TEXT: form.setFieldValue( 'inputText', typeof message === 'string' ? message : '', ) break case Message.IMAGE: { const media = await db.media .where({ parentId: id, type: Media.BROADCAST_TEMPLATE }) .first() form.setFieldValue('inputImage', { file: media?.file || null, caption: (message as any)?.caption || '', }) break } case Message.VIDEO: { const media = await db.media .where({ parentId: id, type: Media.BROADCAST_TEMPLATE }) .first() form.setFieldValue('inputVideo', { file: media?.file || null, caption: (message as any)?.caption || '', }) break } case Message.AUDIO: { const media = await db.media .where({ parentId: id, type: Media.BROADCAST_TEMPLATE }) .first() form.setFieldValue('inputAudio', { file: media?.file || null, }) break } case Message.FILE: { const media = await db.media .where({ parentId: id, type: Media.BROADCAST_TEMPLATE }) .first() form.setFieldValue('inputFile', { file: media?.file || null, caption: typeof message === 'string' ? message : (message as any)?.caption || '', }) break } case Message.LOCATION: form.setFieldValue('inputLocation', message) break case Message.POLL: form.setFieldValue('inputPoll', message) break default: break } } const messageTypes = [ { type: Message.TEXT, icon: 'tabler:text-size', label: 'Text', pro: false }, { type: Message.IMAGE, icon: 'tabler:photo', label: 'Image', pro: true, }, { type: Message.VIDEO, icon: 'tabler:video', label: 'Video', pro: true, }, { type: Message.AUDIO, icon: 'tabler:volume', label: 'Audio', pro: true, }, { type: Message.FILE, icon: 'tabler:file', label: 'File', pro: true }, { type: Message.LOCATION, icon: 'tabler:map-pin', label: 'Location', pro: true, }, { type: Message.POLL, icon: 'tabler:chart-bar', label: 'Poll', pro: true, }, ] // ... [renderContent remains same] ... const renderContent = () => { // ... content rendering logic const { type } = form.values switch (type) { case Message.TEXT: return ( <InputTextarea value={form.values.inputText} onChange={(val) => form.setFieldValue('inputText', val)} error={form.errors.inputText} /> ) case Message.IMAGE: return ( <Stack> <Upload type="image" value={form.values.inputImage.file} onDrop={(file) => form.setFieldValue('inputImage.file', file)} onRemove={() => form.setFieldValue('inputImage.file', null)} /> {form.errors['inputImage.file'] && ( <Text c="red" size="sm"> {form.errors['inputImage.file']} </Text> )} <InputTextarea placeholder="Caption (Optional)" value={form.values.inputImage.caption} onChange={(val) => form.setFieldValue('inputImage.caption', val)} /> </Stack> ) case Message.VIDEO: return ( <Stack> <Upload type="video" value={form.values.inputVideo.file} onDrop={(file) => form.setFieldValue('inputVideo.file', file)} onRemove={() => form.setFieldValue('inputVideo.file', null)} /> {form.errors['inputVideo.file'] && ( <Text c="red" size="sm"> {form.errors['inputVideo.file']} </Text> )} <InputTextarea placeholder="Caption (Optional)" value={form.values.inputVideo.caption} onChange={(val) => form.setFieldValue('inputVideo.caption', val)} /> </Stack> ) case Message.AUDIO: return ( <Stack> <Upload type="audio" value={form.values.inputAudio.file} onDrop={(file) => form.setFieldValue('inputAudio.file', file)} onRemove={() => form.setFieldValue('inputAudio.file', null)} /> {form.errors['inputAudio.file'] && ( <Text c="red" size="sm"> {form.errors['inputAudio.file']} </Text> )} </Stack> ) case Message.FILE: return ( <Stack> <Upload type="file" value={form.values.inputFile.file} onDrop={(file) => form.setFieldValue('inputFile.file', file)} onRemove={() => form.setFieldValue('inputFile.file', null)} /> {form.errors['inputFile.file'] && ( <Text c="red" size="sm"> {form.errors['inputFile.file']} </Text> )} <InputTextarea placeholder="Caption (Optional)" value={form.values.inputFile.caption} onChange={(val) => form.setFieldValue('inputFile.caption', val)} /> </Stack> ) case Message.LOCATION: return ( <Stack> <Group grow> <TextInput label="Latitude" required {...form.getInputProps('inputLocation.lat')} /> <TextInput label="Longitude" required {...form.getInputProps('inputLocation.lng')} /> </Group> <TextInput label="Location Name" {...form.getInputProps('inputLocation.name')} /> <TextInput label="Address" {...form.getInputProps('inputLocation.address')} /> </Stack> ) case Message.POLL: return ( <Stack> <TextInput label="Poll Name" required {...form.getInputProps('inputPoll.name')} /> <Fieldset legend="Choices"> <Stack gap="xs"> {form.values.inputPoll.choices.map((_: any, index: number) => ( <Group key={index}> <TextInput style={{ flex: 1 }} placeholder={`Choice ${index + 1}`} {...form.getInputProps(`inputPoll.choices.${index}`)} /> <When condition={form.values.inputPoll.choices.length > 2}> <ActionIcon color="red" variant="subtle" onClick={() => form.removeListItem('inputPoll.choices', index) } > <Icon icon="tabler:trash" /> </ActionIcon> </When> </Group> ))} <Button variant="default" size="xs" onClick={() => form.insertListItem('inputPoll.choices', '')} leftSection={<Icon icon="tabler:plus" />} > Add Choice </Button> </Stack> </Fieldset> </Stack> ) default: return null } } return ( <Stack> <Group justify="space-between" align="center"> <Text fw={500}>Message Type</Text> <When condition={withTemplateSelector}> <SelectTemplate onSelect={handleTemplateSelect} /> </When> </Group> <ScrollArea w={'100%'} type="hover"> <Box w={'100%'} style={{ textWrap: 'nowrap' }} pb={4}> {messageTypes.map((item) => { const isLocked = item.pro && license.isFree() return ( <Button key={item.type} variant={form.values.type === item.type ? 'filled' : 'default'} onClick={() => handleTypeChange(item.type, item.pro)} size="xs" mr={7} // ++ MODIFIED: Keep original icon on left, add Badge on right leftSection={<Icon icon={item.icon} fontSize={16} />} style={{ whiteSpace: 'nowrap' }} > {item.label} </Button> ) })} </Box> </ScrollArea> <Stack p="md" style={{ border: '1px solid var(--mantine-color-default-border)', borderRadius: 'var(--mantine-radius-md)', }} > {renderContent()} </Stack> </Stack> ) } export default InputMessage \`\`\` # src/components/Input/Message/SelectTemplate.tsx \`\`\`tsx import ModalCreateUpdateTemplate from '@/components/Modal/ModalCreateUpdateTemplate' import ModalManageTemplate from '@/features/broadcast/components/Modal/ModalManageTemplate' import db, { type BroadcastTemplate } from '@/libs/db' import { Icon } from '@iconify/react' import { ActionIcon, Button, Group, Popover, ScrollArea, Stack, Text, TextInput, ThemeIcon, Tooltip, UnstyledButton, } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import { useLiveQuery } from 'dexie-react-hooks' import React, { useMemo, useState } from 'react' import MessageType from '../../Datatable/MessageType' interface Props { onSelect: (template: BroadcastTemplate) => void } const SelectTemplate: React.FC<Props> = ({ onSelect }) => { const [opened, { close, toggle }] = useDisclosure(false) const [showCreateModal, createModalHandlers] = useDisclosure(false) const [search, setSearch] = useState('') const templates = useLiveQuery(() => db.broadcastTemplates.toArray()) const filteredTemplates = useMemo(() => { if (!templates) return [] if (!search) return templates return templates.filter((t) => t.name.toLowerCase().includes(search.toLowerCase()), ) }, [templates, search]) const handleSelect = (template: BroadcastTemplate) => { onSelect(template) close() } return ( <> <Popover opened={opened} onChange={toggle} width={320} position="bottom-end" withArrow shadow="md" trapFocus > <Popover.Target> <Button variant="outline" size="xs" onClick={toggle} leftSection={<Icon icon="tabler:template" fontSize={16} />} rightSection={<Icon icon="tabler:chevron-down" fontSize={14} />} > Template </Button> </Popover.Target> <Popover.Dropdown p="xs"> <Stack gap="xs"> <Group gap="xs" wrap="nowrap"> <TextInput placeholder="Search templates..." size="xs" leftSection={<Icon icon="tabler:search" fontSize={14} />} value={search} onChange={(e) => setSearch(e.currentTarget.value)} rightSection={ search && ( <Icon icon="tabler:x" fontSize={12} style={{ cursor: 'pointer' }} onClick={() => setSearch('')} /> ) } autoFocus style={{ flex: 1 }} /> <Tooltip label="Manage templates" withArrow> <ActionIcon variant="light" color="emerald" size="input-xs" // Matches TextInput height onClick={createModalHandlers.open} > <Icon icon="tabler:plus" fontSize={16} /> </ActionIcon> </Tooltip> </Group> <ScrollArea.Autosize mah={250} type="scroll" offsetScrollbars> {filteredTemplates && filteredTemplates.length > 0 ? ( <Stack gap={4}> {filteredTemplates.map((template) => ( <UnstyledButton key={template.id} onClick={() => handleSelect(template)} style={{ padding: '8px', borderRadius: 'var(--mantine-radius-sm)', transition: 'background-color 0.2s', }} onMouseEnter={(e) => { e.currentTarget.style.backgroundColor = 'var(--mantine-color-dark-6)' }} onMouseLeave={(e) => { e.currentTarget.style.backgroundColor = 'transparent' }} > <Group wrap="nowrap" align="center" justify="space-between" > <Group gap="xs" wrap="nowrap" style={{ overflow: 'hidden' }} > <ThemeIcon variant="light" size="sm" color="gray" radius="xl" > <Icon icon="tabler:file-text" fontSize={14} /> </ThemeIcon> <Stack gap={0} style={{ overflow: 'hidden' }}> <Text size="sm" truncate fw={500}> {template.name} </Text> {/* Reusing existing MessageType component for consistency */} <div style={{ transform: 'scale(0.85)', transformOrigin: 'left', }} > <MessageType type={template.type} /> </div> </Stack> </Group> <Icon icon="tabler:corner-down-left" fontSize={14} color="var(--mantine-color-dimmed)" style={{ opacity: 0.5 }} /> </Group> </UnstyledButton> ))} </Stack> ) : ( <Stack align="center" py="lg" gap="xs"> <Icon icon="tabler:template-off" fontSize={24} color="var(--mantine-color-dimmed)" /> <Text size="xs" c="dimmed"> No templates found. </Text> </Stack> )} </ScrollArea.Autosize> </Stack> </Popover.Dropdown> </Popover> <ModalManageTemplate opened={showCreateModal} onClose={createModalHandlers.close} /> </> ) } export default SelectTemplate \`\`\` # src/components/Input/Message/Upload.tsx \`\`\`tsx import { Icon } from '@iconify/react' import { ActionIcon, Group, rem, Stack, Text, Tooltip } from '@mantine/core' import { Dropzone, type FileRejection } from '@mantine/dropzone' import React, { useEffect, useState } from 'react' interface Props { type: 'image' | 'video' | 'file' | 'audio' // Added 'audio' value: File | null onDrop: (file: File) => void onReject?: (fileRejections: FileRejection[]) => void onRemove: () => void } const Upload: React.FC<Props> = ({ type, value, onDrop, onReject = () => {}, onRemove, }) => { const [preview, setPreview] = useState<string | null>(null) const mimeTypes: Record<string, string[]> = { image: ['image/png', 'image/jpeg', 'image/gif', 'image/webp'], video: ['video/mp4', 'video/mpeg', 'video/quicktime'], audio: ['audio/mpeg', 'audio/mp3', 'audio/ogg', 'audio/wav', 'audio/mp4'], // Added Audio Mimes file: [], // Any file } const extensionsText: Record<string, string> = { image: 'Supports: PNG, JPG, JPEG, GIF, WEBP', video: 'Supports: MP4, MPEG, MOV', audio: 'Supports: MP3, OGG, WAV, MP4', // Added Audio Text file: 'Supports: Any file type', } const maxSizes: Record<string, number> = { image: 5 * 1024 * 1024, // 5MB video: 16 * 1024 * 1024, // 16MB audio: 16 * 1024 * 1024, // 16MB for Audio file: 16 * 1024 * 1024, // 16MB } const icons: Record<string, string> = { image: 'tabler:photo', video: 'tabler:video', audio: 'tabler:volume', file: 'tabler:file', } useEffect(() => { if (value) { if (type === 'image') { const url = URL.createObjectURL(value) setPreview(url) return () => URL.revokeObjectURL(url) } else { setPreview(null) } } else { setPreview(null) } }, [value, type]) const handleDrop = (files: File[]) => { if (files.length > 0) { onDrop(files[0]) } } const handleRemove = (e: React.MouseEvent) => { e.stopPropagation() e.preventDefault() onRemove() } const renderContent = () => { if (value) { return ( <Group justify="center" gap="md" wrap="nowrap" style={{ pointerEvents: 'none' }} > {preview ? ( <img src={preview} alt="Preview" style={{ maxHeight: 60, maxWidth: '100%', objectFit: 'contain', borderRadius: 8, }} /> ) : ( <Icon icon={icons[type] || 'tabler:file-check'} fontSize={40} color="var(--mantine-color-teal-5)" /> )} <Stack gap={0} align="flex-start" style={{ flex: 1, overflow: 'hidden' }} > <Text size="sm" fw={500} lineClamp={1}> {value.name} </Text> <Text size="xs" c="dimmed"> {(value.size / 1024 / 1024).toFixed(2)} MB </Text> </Stack> <Tooltip label="Remove file"> <ActionIcon color="red" variant="light" onClick={handleRemove} style={{ pointerEvents: 'all' }} > <Icon icon="tabler:trash" fontSize={18} /> </ActionIcon> </Tooltip> </Group> ) } return ( <Group justify="center" gap="xl" style={{ pointerEvents: 'none' }}> <Dropzone.Accept> <Icon icon="tabler:upload" fontSize={50} color="var(--mantine-color-blue-6)" /> </Dropzone.Accept> <Dropzone.Reject> <Icon icon="tabler:x" fontSize={50} color="var(--mantine-color-red-6)" /> </Dropzone.Reject> <Dropzone.Idle> <Icon icon="tabler:cloud-upload" fontSize={50} color="var(--mantine-color-dimmed)" /> </Dropzone.Idle> <Stack gap={0} align="center"> <Text size="md" inline> Drag file here or click to select </Text> <Text size="xs" c="dimmed" mt={4}> Max size: {maxSizes[type] / 1024 / 1024} MB </Text> <Text size="xs" c="dimmed"> {extensionsText[type]} </Text> </Stack> </Group> ) } return ( <Dropzone onDrop={handleDrop} onReject={onReject} maxSize={maxSizes[type]} accept={mimeTypes[type].length > 0 ? mimeTypes[type] : undefined} multiple={false} style={{ border: '1px dashed var(--mantine-color-dimmed)', borderRadius: 'var(--mantine-radius-md)', backgroundColor: 'var(--mantine-color-body)', cursor: value ? 'default' : 'pointer', }} disabled={!!value} > {renderContent()} </Dropzone> ) } export default Upload \`\`\` # src/components/Input/Message/useInputMessage.tsx \`\`\`tsx import { Media, Message } from '@/constants' import db from '@/libs/db' import { useForm } from '@mantine/form' import _ from 'lodash' const defaultValues = { type: Message.TEXT, inputText: '', inputImage: { file: null as File | null, caption: '', }, inputVideo: { file: null as File | null, caption: '', }, inputAudio: { file: null as File | null, // Audio usually doesn't typically have a caption in standard broadcast context }, inputFile: { file: null as File | null, caption: '', }, inputLocation: { lat: '', lng: '', name: '', address: '', url: '', }, inputPoll: { name: '', choices: ['Yes', 'No'], }, } const useInputMessage = () => { const form = useForm({ initialValues: defaultValues, validate: { inputText: (value, values) => { if (values.type === Message.TEXT && _.isEmpty(value)) { return 'Message text is required' } return null }, inputImage: { file: (value, values) => { if (values.type === Message.IMAGE && !value) { return 'Image file is required' } return null }, }, inputVideo: { file: (value, values) => { if (values.type === Message.VIDEO && !value) { return 'Video file is required' } return null }, }, inputAudio: { file: (value, values) => { if (values.type === Message.AUDIO && !value) { return 'Audio file is required' } return null }, }, inputFile: { file: (value, values) => { if (values.type === Message.FILE && !value) { return 'Document file is required' } return null }, }, inputLocation: { lat: (value, values) => values.type === Message.LOCATION && _.isEmpty(value) ? 'Required' : null, lng: (value, values) => values.type === Message.LOCATION && _.isEmpty(value) ? 'Required' : null, }, inputPoll: { name: (value, values) => values.type === Message.POLL && _.isEmpty(value) ? 'Required' : null, choices: (value, values) => { if (values.type === Message.POLL) { if (value.length < 2) return 'At least 2 choices required' if (value.some((c) => _.isEmpty(c))) return 'Choices cannot be empty' } return null }, }, }, }) const getMessage = () => { const { type, inputText, inputImage, inputVideo, inputAudio, inputFile, inputLocation, inputPoll, } = form.values const messages: Record<string, any> = { [Message.TEXT]: inputText, [Message.IMAGE]: { caption: inputImage.caption }, [Message.VIDEO]: { caption: inputVideo.caption }, [Message.AUDIO]: {}, // Audio typically has no content payload other than the file itself [Message.FILE]: inputFile.caption, [Message.LOCATION]: inputLocation, [Message.POLL]: { name: inputPoll.name, choices: inputPoll.choices }, } return messages[type] } const insertBroadcastFile = async ( parentId: number, broadcastFileType: string, ) => { const { type, inputImage, inputVideo, inputAudio, inputFile } = form.values let file: File | null = null if (type === Message.IMAGE) file = inputImage.file else if (type === Message.VIDEO) file = inputVideo.file else if (type === Message.AUDIO) file = inputAudio.file else if (type === Message.FILE) file = inputFile.file if (file) { await db.media.add({ parentId, type: broadcastFileType, name: file.name, file, ext: file.type, }) } } return { form, getMessage, insertBroadcastFile, } } export default useInputMessage \`\`\` # src/components/Layout/LayoutModal.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import style from '@/utils/style' import { Box, Group, Stack, Text, ThemeIcon, Title } from '@mantine/core' import React from 'react' import { When } from 'react-if' interface Props { opened: boolean onClose: () => void title: string description?: string icon?: React.ReactNode children: React.ReactNode w?: number | string withCloseButton?: boolean } const LayoutModal: React.FC<Props> = ({ opened, onClose, title, description, icon, children, w = 600, withCloseButton = true, }) => { return ( <Modal opened={opened} onClose={onClose} w={w} withCloseButton={withCloseButton} > <Stack gap="lg" h="100%"> {/* Header Section */} <Stack gap={5}> <Group gap="xs" align="center"> {icon && ( <ThemeIcon variant="light" size="lg" color="emerald" radius="md" style={{ background: 'rgba(16, 185, 129, 0.1)' }} > {icon} </ThemeIcon> )} <Title order={3} style={style.gradientText}> {title} </Title> </Group> <When condition={description}> <Text c="dimmed" size="sm"> {description} </Text> </When> </Stack> {/* Content Body */} <Box style={{ flexGrow: 1 }}>{children}</Box> </Stack> </Modal> ) } export default LayoutModal \`\`\` # src/components/Layout/LayoutPage.module.css \`\`\`css .header { /* Gradient border effect for the header */ border-bottom: 1px solid transparent; background: linear-gradient(#000, #000) padding-box, linear-gradient( 90deg, transparent, var(--matrix-border-subtle), transparent ) border-box; background-color: rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px); } .footer { border-top: 1px solid var(--matrix-border-subtle); background-color: #000; } /* Ensure global scroll area inside layout matches the aesthetic */ :global(.mantine-ScrollArea-viewport) { background-color: var(--matrix-bg-page); } /* Add a subtle scanline effect to the background if desired */ /* .backgroundScanline { position: absolute; inset: 0; background: repeating-linear-gradient( 0deg, transparent 0px, transparent 1px, rgba(16, 185, 129, 0.03) 2px ); pointer-events: none; z-index: 0; } */ \`\`\` # src/components/Layout/LayoutPage.tsx \`\`\`tsx import useLicense from '@/hooks/useLicense' import useWa from '@/hooks/useWa' import env from '@/utils/env' import style from '@/utils/style' import { closePage } from '@/utils/util' import { Icon } from '@iconify/react' import { ActionIcon, Badge, Group, Paper, ScrollArea, Stack, Text, Title, type MantineSpacing, type StyleProp, } from '@mantine/core' import { license } from '@wppconnect/wa-js' import defaultLogo from 'data-base64:../../../assets/icon.png' import React from 'react' import { When } from 'react-if' import packageJson from '../../../package.json' import classes from './LayoutPage.module.css' interface Props { width?: StyleProp<React.CSSProperties['width']> | null height?: StyleProp<React.CSSProperties['height']> | null p?: StyleProp<MantineSpacing> title?: string | null description?: string | null children: React.ReactNode icon?: React.ReactNode } const LayoutPage: React.FC<Props> = ({ width = 500, height = 555, p = 'md', children, title = null, description = null, icon, }: Props) => { const license = useLicense() const renderBody = () => { return ( <Stack p={p} w={width}> {children} </Stack> ) } return ( <> <Paper radius={0} shadow="xl" style={{ border: 'none', // GLASS/BLUR SETTINGS: // 1. Transparent black (0.75) for high contrast white text but see-through background backgroundColor: 'rgba(0, 0, 0, 0.75)', // 2. Strong blur to obscure WhatsApp chat behind it backdropFilter: 'blur(24px) saturate(180%)', // 3. Support for Webkit-based browsers (Safari/older Chrome) WebkitBackdropFilter: 'blur(24px) saturate(180%)', height: '100%', minHeight: '100vh', // Thin right border for clear separation from chat borderRight: '1px solid rgba(255, 255, 255, 0.1)', }} > <Stack w={width} gap={0}> {/* Header */} <Group justify="space-between" className={classes.header} px={'md'} py={'sm'} align="center" // Ensure vertical alignment if description makes header taller > <Group gap={12} align="center"> {icon ? ( <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', background: 'rgba(255, 255, 255, 0.05)', borderRadius: '8px', padding: '6px', border: '1px solid rgba(255, 255, 255, 0.1)', }} > {icon} </div> ) : ( <img width={35} height={35} src={defaultLogo} style={{ borderRadius: 10 }} /> )} <Stack gap={0} justify="center"> <Group gap={8} align="center"> <Title order={3} ml={2} style={style.gradientText}> {title ? title : packageJson.displayName} </Title> <When condition={license?.isPro()}> <Badge variant="light" c="orange" size="md" radius="sm"> Pro </Badge> </When> </Group> <When condition={!!description}> <Text size="xs" c="dimmed" ml={2} lineClamp={1}> {description} </Text> </When> </Stack> </Group> <Group> <ActionIcon variant="subtle" color="gray" onClick={closePage} style={{ transition: 'all 0.2s', '&:hover': { color: '#ef4444', transform: 'rotate(90deg)', }, }} > <Icon icon="tabler:x" fontSize={20} /> </ActionIcon> </Group> </Group> <ScrollArea h={'95vh'} type="scroll"> {renderBody()} </ScrollArea> </Stack> </Paper> </> ) } export default LayoutPage \`\`\` # src/components/Listeners/BroadcastListener.tsx \`\`\`tsx import { Action } from '@/constants' import useBroadcast from '@/features/broadcast/hooks/useBroadcast' import useWa from '@/hooks/useWa' import useWindowMessage from '@/hooks/useWindowMessage' import _ from 'lodash' import { useEffect } from 'react' const BroadcastListener: React.FC = () => { const wa = useWa() const broadcast = useBroadcast() useWindowMessage(async (event: MessageEvent) => { const { data: { action }, } = event switch (action) { case Action.Window.SEND_BROADCAST: await broadcast.init() break default: break } }) useEffect(() => { if (!wa.isReady) return broadcast .init() .then(() => { console.log('Broadcast listener initialized.') }) .catch(console.error) const interval = setInterval(broadcast.checkScheduled, 5000) return () => { clearInterval(interval) } }, [wa.isReady]) return null } export default BroadcastListener \`\`\` # src/components/Listeners/PrivacyListener.tsx \`\`\`tsx import { Setting } from '@/constants' import useWa from '@/hooks/useWa' import privacy from '@/utils/privacy' import { useMutationObserver } from '@mantine/hooks' import { useStorage } from '@plasmohq/storage/hook' import $ from 'jquery' import React, { useEffect } from 'react' const PrivacyListener: React.FC = () => { const wa = useWa() const [blurProfilePictures] = useStorage(Setting.BLUR_PROFILE_PICTURES) const [blurMessages] = useStorage(Setting.BLUR_MESSAGES) const [blurUserGroupNames] = useStorage(Setting.BLUR_USER_GROUP_NAMES) const [blurRecentMessages] = useStorage(Setting.BLUR_RECENT_MESSAGES) const [unblurOnHover] = useStorage(Setting.UNBLUR_ON_HOVER) // Observer for Profile Pictures, Names, and Recent Messages (Sidebar) useMutationObserver( (mutations) => { privacy.init().then().catch(console.error) }, { attributes: true, childList: true, }, () => $('div[class="x1y332i5 x1n2onr6 x6ikm8r x10wlt62 xjwt4uw"]')[0], ) // Observer specifically for Chat/Messages area useMutationObserver( (mutations) => { privacy.init().then().catch(console.error) }, { attributes: true, childList: true, }, () => $( 'div[class="x3psx0u xwib8y2 xkhd6sd xrmvbpv xh8yej3 xquzyny x1gryazu xkrivgy"]', )[0], ) // Trigger effect when state changes or WA is ready useEffect(() => { if (!wa.isReady) return privacy.init().then().catch(console.error) }, [ wa.isReady, blurProfilePictures, blurMessages, blurUserGroupNames, blurRecentMessages, unblurOnHover, ]) return null } export default PrivacyListener \`\`\` # src/components/Modal/Modal.tsx \`\`\`tsx import { Icon } from '@iconify/react' import { ActionIcon, Box, Card, Portal, type MantineSpacing, type StyleProp, } from '@mantine/core' import React, { useEffect, useState, type CSSProperties } from 'react' import { When } from 'react-if' interface Props { opened: boolean onClose: () => void height?: string | number width?: string | number style?: CSSProperties withCloseButton?: boolean | false h?: StyleProp<React.CSSProperties['height']> w?: StyleProp<React.CSSProperties['width']> p?: StyleProp<MantineSpacing> children: React.ReactNode closeOnClickOutside?: boolean // ++ ADDED: Prop baru untuk kontrol klik luar } const Modal: React.FC<Props> = ({ opened, onClose, style = {}, withCloseButton = false, p = 'lg', h, w, children, closeOnClickOutside = true, // ++ DEFAULT: True (aktif) ...rest }: Props) => { const [portalTarget, setPortalTarget] = useState<HTMLElement | null>(() => { // Mencari container di dalam Shadow DOM Plasmo const shadowHost = document.getElementById('crm-main') const target = shadowHost?.shadowRoot?.querySelector( 'div.plasmo-csui-container', ) as HTMLElement return target || document.body }) useEffect(() => { // Jika target awal adalah document.body (fallback), coba cari lagi setelah mount // Ini penting untuk komponen yang di-mount sangat awal if (portalTarget === document.body) { const shadowHost = document.getElementById('crm-main') const target = shadowHost?.shadowRoot?.querySelector( 'div.plasmo-csui-container', ) as HTMLElement if (target) { setPortalTarget(target) } } }, [portalTarget]) // ++ ADDED: Handler khusus untuk klik backdrop const handleBackdropClick = (e: React.MouseEvent) => { // Mencegah event bubbling yang tidak diinginkan e.stopPropagation() if (closeOnClickOutside) { onClose() } } // Helper for CSS transition const transitionStyle = 'all 0.3s cubic-bezier(0.16, 1, 0.3, 1)' return ( <Portal target={portalTarget || undefined}> {/* BACKDROP / OVERLAY */} <div style={{ position: 'fixed', top: 0, bottom: 0, left: 0, right: 0, zIndex: 399, width: '100%', height: '100%', backgroundColor: 'rgba(0, 0, 0, 0.6)', // Warna latar belakang gelap transparan backdropFilter: 'blur(4px)', WebkitBackdropFilter: 'blur(4px)', // Animasi State: opacity: opened ? 1 : 0, visibility: opened ? 'visible' : 'hidden', transition: `opacity 0.3s ease, visibility 0.3s ease`, // Pointer events penting agar bisa diklik saat open, dan tembus saat close pointerEvents: opened ? 'auto' : 'none', cursor: closeOnClickOutside ? 'pointer' : 'default', // Visual cue }} onClick={handleBackdropClick} // ++ UPDATE: Menggunakan handler baru ></div> {/* MODAL CONTAINER */} <Box style={{ position: 'fixed', top: '50%', left: '50%', zIndex: 1050, // Animasi Transform: transform: opened ? 'translate(-50%, -50%) scale(1)' : 'translate(-50%, -48%) scale(0.95)', opacity: opened ? 1 : 0, visibility: opened ? 'visible' : 'hidden', transition: transitionStyle, // Pastikan konten modal tetap bisa menerima interaksi mouse pointerEvents: opened ? 'auto' : 'none', ...style, }} {...rest} > <Card shadow="xl" p={p} w={w} h={h} radius="xl" style={{ backgroundColor: 'rgba(0, 0, 0, 0.75)', backdropFilter: 'blur(24px) saturate(180%)', WebkitBackdropFilter: 'blur(24px) saturate(180%)', border: '1px solid rgba(255, 255, 255, 0.1)', color: '#f8fafc', transition: 'box-shadow 0.3s ease', }} onClick={(e) => e.stopPropagation()} > <When condition={withCloseButton}> <ActionIcon onClick={onClose} color="gray" variant="subtle" style={{ position: 'absolute', right: 12, top: 12, zIndex: 10, color: 'rgba(255, 255, 255, 0.5)', transition: 'all 0.2s', '&:hover': { color: '#fff', backgroundColor: 'rgba(255,255,255,0.1)', transform: 'rotate(90deg)', }, }} > <Icon icon="tabler:x" fontSize={18} /> </ActionIcon> <Box mb={'md'} /> </When> {children} <Box mb={'sm'} /> </Card> </Box> </Portal> ) } export default Modal \`\`\` # src/components/Modal/ModalActivation.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import useLicense from '@/hooks/useLicense' import toast from '@/utils/toast' import { getStoreId } from '@/utils/util' import { Icon } from '@iconify/react' import { Box, Button, Group, Paper, rem, Stack, Text, TextInput, ThemeIcon, Title, } from '@mantine/core' import { useForm } from '@mantine/form' import _ from 'lodash' import React, { useState } from 'react' interface Props { opened: boolean onClose: () => void } const defaultValues = { license: '', } const ModalActivation: React.FC<Props> = ({ opened, onClose }: Props) => { const license = useLicense() const form = useForm({ initialValues: defaultValues, validate: { license: (value) => _.isEmpty(value) ? 'A license key is required.' : null, }, }) const [loading, setLoading] = useState<boolean>(false) const handleOnClose = () => { form.reset() onClose() } const handleSubmit = async () => { const { hasErrors } = form.validate() if (hasErrors) { return } setLoading(true) form.clearErrors() try { const response = await license.activate(form.values.license) if (response.data.error) { form.setFieldError('license', response.data.error.replace(/_/g, ' ')) setLoading(false) return } // if (response.data.meta.store_id.toString() !== getStoreId()) { // form.setFieldError( // 'license', // 'This license key is not valid for this product.', // ) // setLoading(false) // return // } toast.success('Access granted. Welcome to Pro.', 'Activation Successful') handleOnClose() } catch (err) { console.error('Activation error:', err) form.setFieldError('license', 'Connection refused. Please try again.') } finally { setLoading(false) } } return ( <Modal opened={opened} onClose={handleOnClose} w={500} withCloseButton> <Stack gap="lg" px="md" pb="md"> {/* Header Section with Neon Pulse */} <Stack align="center" gap="xs"> <Box style={{ position: 'relative', display: 'flex', alignItems: 'center', justifyContent: 'center', width: '80px', height: '80px', borderRadius: '50%', background: 'rgba(16, 185, 129, 0.1)', border: '1px solid rgba(16, 185, 129, 0.2)', boxShadow: '0 0 30px rgba(16, 185, 129, 0.2)', }} > {/* Inner pulsing circle */} <div style={{ position: 'absolute', inset: 0, borderRadius: '50%', animation: 'pulse-glow 3s infinite', boxShadow: 'inset 0 0 20px rgba(16, 185, 129, 0.1)', }} /> <Icon icon="tabler:key" fontSize={32} style={{ color: '#34d399', zIndex: 2 }} /> </Box> <Title order={3} ta="center" mt="sm"> License Activation </Title> <Text c="dimmed" size="sm" ta="center" maw={350}> Enter your secure key to decrypt Pro features. </Text> </Stack> {/* Input Section */} <Paper p="xl" radius="lg" style={{ backgroundColor: 'rgba(255, 255, 255, 0.02)', border: '1px solid rgba(255, 255, 255, 0.05)', }} > <Stack> <TextInput label="License Key" placeholder="xxxx-xxxx-xxxx-xxxx" description="The 16-character string sent to your email." required size="md" leftSection={ <Icon icon="tabler:shield-lock" fontSize={18} color="#64748b" /> } {...form.getInputProps('license')} styles={{ input: { fontFamily: 'var(--font-mono)', // Use monospace for key entry letterSpacing: '1px', }, }} /> <Button loading={loading} onClick={handleSubmit} fullWidth size="md" color="emerald" variant="filled" leftSection={<Icon icon="tabler:lock-open" fontSize={20} />} mt="xs" > Activate </Button> </Stack> </Paper> </Stack> </Modal> ) } export default ModalActivation \`\`\` # src/components/Modal/ModalCreateUpdateTemplate.tsx \`\`\`tsx import InputMessage from '@/components/Input/Message/InputMessage' import useInputMessage from '@/components/Input/Message/useInputMessage' import Modal from '@/components/Modal/Modal' import { Media, Message } from '@/constants' import db, { type BroadcastTemplate } from '@/libs/db' import toast from '@/utils/toast' import { Button, Group, Stack, TextInput, Title } from '@mantine/core' import React, { useEffect, useState } from 'react' interface Props { opened: boolean onClose: () => void data?: Partial<BroadcastTemplate> | null } const ModalCreateUpdateTemplate: React.FC<Props> = ({ opened, onClose, data, }) => { const { form, getMessage, insertBroadcastFile } = useInputMessage() const [name, setName] = useState('') useEffect(() => { if (opened) { if (data) { form.setValues({ type: data.type, }) setName(data.name || '') // Map message content back to form const msg = data.message if (data.type === Message.TEXT) { form.setFieldValue('inputText', typeof msg === 'string' ? msg : '') } else if (data.type === Message.IMAGE) { form.setFieldValue('inputImage.caption', msg?.caption || '') } else if (data.type === Message.VIDEO) { form.setFieldValue('inputVideo.caption', msg?.caption || '') } else if (data.type === Message.FILE) { form.setFieldValue( 'inputFile.caption', typeof msg === 'string' ? msg : msg?.caption || '', ) } else if (data.type === Message.LOCATION) { form.setFieldValue('inputLocation', msg) } else if (data.type === Message.POLL) { form.setFieldValue('inputPoll', msg) } // Load media if applicable if ( [Message.IMAGE, Message.VIDEO, Message.FILE].includes(data.type) && data.id ) { db.media .where({ parentId: data.id, type: Media.BROADCAST_TEMPLATE }) .first() .then((media) => { if (media && media.file) { if (data.type === Message.IMAGE) form.setFieldValue('inputImage.file', media.file) if (data.type === Message.VIDEO) form.setFieldValue('inputVideo.file', media.file) if (data.type === Message.FILE) form.setFieldValue('inputFile.file', media.file) } }) } } else { form.reset() setName('') } } }, [opened, data]) const handleSubmit = async () => { // Manual validation for name if (!name) { toast.error('Template name is required') return } const validation = form.validate() if (validation.hasErrors) return const message = getMessage() const type = form.values.type try { let id = data?.id if (id) { // Update await db.broadcastTemplates.update(id, { name, type, message, }) // Handle Media if ([Message.IMAGE, Message.VIDEO, Message.FILE].includes(type)) { // Delete old media await db.media .where({ parentId: id, type: Media.BROADCAST_TEMPLATE }) .delete() // Add new media await insertBroadcastFile(id, Media.BROADCAST_TEMPLATE) } toast.success('Template updated successfully') } else { // Create id = await db.broadcastTemplates.add({ name, type, message, }) await insertBroadcastFile(id, Media.BROADCAST_TEMPLATE) toast.success('Template created successfully') } onClose() } catch (error) { console.error(error) toast.error('Failed to save template') } } return ( <Modal opened={opened} onClose={onClose}> <Title order={3} mb="md"> {data ? 'Edit Template' : 'Create Template'} </Title> <Stack> <TextInput label="Template Name" placeholder="Enter template name" required value={name} onChange={(e) => setName(e.currentTarget.value)} /> <InputMessage form={form} allowProTypes /> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button onClick={handleSubmit}>Save</Button> </Group> </Stack> </Modal> ) } export default ModalCreateUpdateTemplate \`\`\` # src/components/Modal/ModalFaq.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import { Icon } from '@iconify/react' import { Accordion, Anchor, Group, Paper, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' interface Props { opened: boolean onClose: () => void } const faqData = [ { icon: 'tabler:key', question: 'Where can I find my license key?', answer: 'You will receive an email from Lemon Squeezy after making a purchase. This email usually contains your purchase details and your license key.', }, { icon: 'tabler:shield-check', question: 'Is my data secure?', answer: 'Absolutely. Your data security is our priority. This extension does not collect, store, or share any personal data from your WhatsApp account. All processes occur locally on your device.', }, { icon: 'tabler:mail-question', question: 'How can I get more help and support?', answer: 'If you have other questions or need assistance, please feel free to email us at extdotninja@gmail.com. Our team will be happy to help you.', }, ] const ModalFaq: React.FC<Props> = ({ opened, onClose }: Props) => { const handleOnClose = () => { onClose() } return ( <Modal opened={opened} onClose={handleOnClose} withCloseButton w={800}> <Stack> <Stack align="center" gap={4} mb={'xl'}> <Icon icon="tabler:help-circle" fontSize={42} /> <Title order={3} ta="center"> Frequently Asked Questions </Title> </Stack> <Accordion variant="separated" radius="md"> {faqData.map((item) => ( <Accordion.Item key={item.question} value={item.question}> <Accordion.Control icon={ <ThemeIcon variant="light" size="lg"> <Icon icon={item.icon} fontSize={22} /> </ThemeIcon> } > <Text fw={500} dangerouslySetInnerHTML={{ __html: item.question.replace( /\*\*(.*?)\*\*/g, '<b>$1</b>', ), }} ></Text> </Accordion.Control> <Accordion.Panel> <Text c="dimmed" size="sm" lh={1.6} dangerouslySetInnerHTML={{ __html: item.answer.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>'), }} ></Text> </Accordion.Panel> </Accordion.Item> ))} </Accordion> <Paper withBorder p="md" shadow="none" radius="md" mt="xl"> <Group> <ThemeIcon size="xl" radius="md" variant="light"> <Icon icon="tabler:mail" fontSize={20} /> </ThemeIcon> <Stack gap={2}> <Title order={4}>Still have questions?</Title> <Text c="dimmed" size="sm"> Our team is ready to help. Contact us via email. </Text> <Anchor href="mailto:extdotninja@gmail.com" size="sm" fw={500} target="_blank" > extdotninja@gmail.com </Anchor> </Stack> </Group> </Paper> </Stack> </Modal> ) } export default ModalFaq \`\`\` # src/components/Modal/ModalMenu.tsx \`\`\`tsx \`\`\` # src/components/Modal/ModalPricing.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import plans from '@/config/plans' import { Icon } from '@iconify/react' import { Badge, Box, Button, Group, Paper, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' interface Props { opened: boolean onClose: () => void } const ModalPricing: React.FC<Props> = ({ opened, onClose }) => { return ( <Modal opened={opened} onClose={onClose} w={1250}> <Stack gap="xl"> <Stack align="center" ta="center" gap="xs"> <Title order={1} style={{ fontSize: '3rem', letterSpacing: '-0.02em', background: 'linear-gradient(to bottom, #ffffff, #94a3b8)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent', }} > Choose your power level. </Title> <Text size="lg" c="dimmed" maw={600}> Transparent pricing. No hidden fees. Instant activation. </Text> </Stack> <Group justify="center" align="stretch" mt="md" gap="xl"> {plans.map((plan, index) => { const isHighlight = !plan.isFree return ( <Paper key={index} radius="lg" p={36} style={{ position: 'relative', width: '350px', // Glass Panel aesthetic backgroundColor: isHighlight ? 'rgba(16, 185, 129, 0.03)' : 'rgba(2, 6, 23, 0.4)', backdropFilter: 'blur(12px)', border: isHighlight ? '1px solid rgba(52, 211, 153, 0.3)' : '1px solid rgba(255, 255, 255, 0.05)', boxShadow: isHighlight ? '0 0 40px -10px rgba(16, 185, 129, 0.15)' : 'none', transition: 'transform 0.3s ease, box-shadow 0.3s ease', cursor: 'default', }} // Hover effect simulation via inline styles or class would go here > {/* Floating Glow Effect for Paid Plans */} {isHighlight && ( <div style={{ position: 'absolute', top: 0, left: 0, right: 0, height: '1px', background: 'linear-gradient(90deg, transparent, #34d399, transparent)', opacity: 0.5, }} /> )} <Stack justify="space-between" style={{ height: '100%' }}> <Box> <Group justify="space-between" align="center" mb="md"> <Title order={2} c={isHighlight ? 'white' : 'gray.5'}> {plan.name} </Title> {isHighlight && ( <Icon icon="tabler:sparkles" className="text-emerald-400" fontSize={24} /> )} </Group> <Text size="sm" c="dimmed" style={{ minHeight: '40px' }}> {plan.description} </Text> <Group gap={4} align="baseline"> <Text span fz={48} fw={700} c={isHighlight ? 'emerald.4' : 'dimmed'} > {plan.price} </Text> {plan.priceSuffix && ( <Text span fz="sm" c="dimmed" fw={500}> {plan.priceSuffix} </Text> )} </Group> <Stack gap="md"> {plan.features.map((feature, idx) => ( <Group key={idx} gap="md" align="flex-start" wrap="nowrap" > {plan.isFree ? ( <ThemeIcon variant="transparent" c="dimmed" size="xs" mt={4} > <Icon icon="tabler:minus" /> </ThemeIcon> ) : ( <ThemeIcon variant="light" color="emerald" size="sm" radius="xl" mt={2} > <Icon icon="tabler:check" fontSize={12} /> </ThemeIcon> )} <Text size="sm" c={plan.isFree ? 'dimmed' : 'gray.3'}> {feature} </Text> </Group> ))} </Stack> </Box> <Box mt={32}> {plan.isFree ? ( <Button fullWidth variant="outline" color="gray" size="md" disabled style={{ borderColor: 'rgba(255,255,255,0.1)' }} > Current Plan </Button> ) : ( <Button component="a" href={plan.link} target="_blank" fullWidth size="md" variant="filled" color="emerald" leftSection={ <Icon icon="tabler:rocket" fontSize={20} /> } // The 'aura-button-green-beam' style from theme.ts will apply here > Upgrade Now </Button> )} </Box> </Stack> </Paper> ) })} </Group> </Stack> </Modal> ) } export default ModalPricing \`\`\` # src/components/Modal/ModalProfile.tsx \`\`\`tsx import { Setting } from '@/constants' import useLicense from '@/hooks/useLicense' import { useAppStore } from '@/stores/app' import confirm from '@/utils/confirm' // ++ ADDED import { showModalActivation, showModalPricing } from '@/utils/util' import { Icon } from '@iconify/react' import { Badge, Button, Card, Divider, Group, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import { useStorage } from '@plasmohq/storage/hook' import dayjs from 'dayjs' import React from 'react' import { When } from 'react-if' import Modal from './Modal' interface Props { opened: boolean onClose: () => void } const ModalProfile: React.FC<Props> = ({ opened, onClose }) => { const license = useLicense() const { license: licenseData } = useAppStore() const [licenseKey] = useStorage(Setting.LICENSE_KEY) const handleDeactivate = async () => { // -- MODIFIED: Use custom confirm const isConfirmed = await confirm.danger( 'Deactivate License', 'Are you sure you want to deactivate your license on this device?', ) if (isConfirmed) { await license.deactivate() } } const handleUpgrade = () => { showModalPricing() } const handleActivate = () => { showModalActivation() } const maskLicenseKey = (key: string | undefined | null) => { if (!key) return 'N/A' const keyParts = key.split('-') if (keyParts.length > 1) { return `****-****-****-${keyParts[keyParts.length - 1]}` } return '****' + key.slice(-4) } const InfoItem = ({ icon, label, value, }: { icon: string label: string value: React.ReactNode }) => ( <Group wrap="nowrap" gap="lg"> <ThemeIcon variant="light" size={36} radius="md" color="gray"> <Icon icon={icon} fontSize={20} /> </ThemeIcon> <div> <Text size="xs" c="dimmed"> {label} </Text> <Text size="sm" fw={500}> {value || '-'} </Text> </div> </Group> ) return ( <Modal opened={opened} onClose={onClose} withCloseButton w={800}> <Stack> {/* License Details */} <Card withBorder radius="md" p="md" shadow="none"> <Stack> <Group justify="space-between" align="center"> <Title order={5}>License Status</Title> <Badge color={license.isPro() ? 'yellow' : 'gray'} size="lg" variant="filled" > {license.isPro() ? 'Pro' : 'Trial'} </Badge> </Group> <Divider my="sm" /> <When condition={license.isPro()}> <Stack my="xs" gap="sm"> <InfoItem icon="tabler:user-circle" label="Licensed To" value={licenseData?.meta.customer_name} /> <InfoItem icon="tabler:mail" label="Email" value={licenseData?.meta.customer_email} /> <InfoItem icon="tabler:key" label="License Key" value={maskLicenseKey(licenseKey)} /> <InfoItem icon="tabler:calendar" label="Expires On" value={ licenseData?.license_key.expires_at ? dayjs(licenseData.license_key.expires_at).format( 'DD MMMM YYYY', ) : 'Lifetime' } /> </Stack> </When> <Text size="sm" c="dimmed" mt="md"> {license.isPro() ? 'Thank you for being a Pro user! You have access to all features.' : 'Upgrade to Pro to unlock all features.'} </Text> <Group justify="flex-end" mt="lg" gap="md"> <When condition={license.isFree()}> <Button onClick={handleUpgrade} color="teal" leftSection={<Icon icon="tabler:crown" fontSize={18} />} > Upgrade to Pro </Button> <Button onClick={handleActivate} variant="outline" leftSection={<Icon icon="tabler:key" fontSize={18} />} > Activate License </Button> </When> <When condition={license.isPro()}> <Button onClick={license.goToMyOrders} variant="outline" leftSection={<Icon icon="tabler:credit-card" fontSize={18} />} > Manage Subscription </Button> <Button onClick={handleDeactivate} color="red" variant="light" leftSection={<Icon icon="tabler:logout" fontSize={18} />} > Deactivate License </Button> </When> </Group> </Stack> </Card> {/* Data Privacy */} <Card withBorder radius="md" p="md" shadow="none"> <Stack> <Group justify="space-between" align="center"> <Title order={5}>Data Privacy Guarantee</Title> <ThemeIcon variant="light" color="teal" size="lg"> <Icon icon="tabler:shield-check" fontSize={22} /> </ThemeIcon> </Group> <Divider my="sm" /> <Text size="sm" c="dimmed"> All your data is stored only on your computer and is never sent to our servers. You have 100% control over your data. </Text> </Stack> </Card> </Stack> </Modal> ) } export default ModalProfile \`\`\` # src/components/Toast/Toast.module.css \`\`\`css @keyframes fadeIn { from { opacity: 0; transform: translateX(100%); } to { opacity: 1; transform: translateX(0); } } .toast { animation: fadeIn 0.3s ease-out forwards; } \`\`\` # src/components/Toast/Toast.tsx \`\`\`tsx import { type Toast } from '@/stores/toast' import { Icon } from '@iconify/react' import { ActionIcon, Group, Paper, Stack, Text, ThemeIcon } from '@mantine/core' import { useEffect } from 'react' import classes from './Toast.module.css' interface ToastProps extends Toast { onClose: () => void } const ToastComponent: React.FC<ToastProps> = ({ id, type, title, message, duration = 2000, onClose, }) => { // Auto-close after duration useEffect(() => { const timer = setTimeout(onClose, duration) return () => clearTimeout(timer) }, [id, duration, onClose]) // Configuration for each toast type const toastConfig = { success: { icon: 'tabler:check', color: 'teal' }, error: { icon: 'tabler:x', color: 'red' }, info: { icon: 'tabler:info-circle', color: 'blue' }, warning: { icon: 'tabler:alert-triangle', color: 'orange' }, } as const const { icon, color } = toastConfig[type] return ( <Paper shadow="lg" p="sm" radius="md" withBorder className={classes.toast} style={{ minWidth: 350, maxWidth: 400 }} > <Group align="flex-start" wrap="nowrap"> <ThemeIcon color={color} size={36} radius="xl" variant="light" mt={4}> <Icon icon={icon} fontSize={22} /> </ThemeIcon> <Stack gap={2} style={{ flex: 1 }}> <Text fw={600} size="md"> {title} </Text> <Text size="sm" c="dimmed"> {message} </Text> </Stack> <ActionIcon variant="transparent" color="gray" onClick={onClose}> <Icon icon="tabler:x" fontSize={20} /> </ActionIcon> </Group> </Paper> ) } export default ToastComponent \`\`\` # src/components/Toast/ToastProvider.tsx \`\`\`tsx import { useToastStore } from '@/stores/toast' import { Box } from '@mantine/core' import React from 'react' import ToastComponent from './Toast' const ToastProvider: React.FC = () => { const { toasts, removeToast } = useToastStore() return ( <Box style={{ position: 'fixed', top: 20, right: 20, zIndex: 2000, display: 'flex', flexDirection: 'column', gap: '10px', }} > {toasts.map((toast) => ( <ToastComponent key={toast.id} id={toast.id} type={toast.type} title={toast.title} message={toast.message} duration={toast.duration} onClose={() => removeToast(toast.id)} /> ))} </Box> ) } export default ToastProvider \`\`\` # src/config/plans.ts \`\`\`ts const plans = [ { name: 'Free', isFree: true, description: 'For basic needs.', price: '$0', priceSuffix: null, link: '#', features: [ 'Start unlimited chats', 'No need to save contacts', 'Send text messages only', ], }, { name: '1 day passs', isFree: false, description: 'Ideal for testing.', placeholderPrice: '$89', price: '$3', priceSuffix: '/day', link: 'https://extdotninja.lemonsqueezy.com/buy/a94d5657-7944-4766-8439-88be3268bf42?logo=0', features: [ 'Start unlimited chats', 'No need to save contacts', 'Send Image, Video, File, Location, Text', 'Save Unlimited Message Templates', 'Ideal for testing', ], }, { name: 'Lifetime', isFree: false, description: 'Pay once, access forever, no monthly fees.', placeholderPrice: '$89', price: '$19', priceSuffix: '/one-time', link: 'https://extdotninja.lemonsqueezy.com/buy/53f1c17b-8636-49cf-b454-ab0ad2700418?logo=0', features: [ 'Start unlimited chats', 'No need to save contacts', 'Send Image, Video, File, Location, Text', 'Save Unlimited Message Templates', ], }, ] export default plans \`\`\` # src/constants/action.ts \`\`\`ts export const App = { HTTP: 'App.HTPP', AI: 'App.AI', } export const Blocklist = { ALL: 'Blocklist.ALL', BLOCK_CONTACT: 'Blocklist.BLOCK_CONTACT', IS_BLOCKED: 'Blocklist.IS_BLOCKED', UNBLOCK_CONTACT: 'Blocklist.UNBLOCK_CONTACT', } export const Cart = { ADD: 'Cart.ADD', CLEAR: 'Cart.CLEAR', GET: 'Cart.GET', GET_THUMB_FROM_CART: 'Cart.GET_THUMB_FROM_CART', REMOVE: 'Cart.REMOVE', SUBMIT: 'Cart.SUBMIT', UPDATE: 'Cart.UPDATE', } export const Catalog = { ADD_PRODUCT_IMAGE: 'Catalog.ADD_PRODUCT_IMAGE', CHANGE_PRODUCT_IMAGE: 'Catalog.CHANGE_PRODUCT_IMAGE', CREATE_COLLECTION: 'Catalog.CREATE_COLLECTION', CREATE_PRODUCT: 'Catalog.CREATE_PRODUCT', DELETE_COLLECTION: 'Catalog.DELETE_COLLECTION', DELETE_PRODUCT: 'Catalog.DELETE_PRODUCT', EDIT_COLLECTION: 'Catalog.EDIT_COLLECTION', EDIT_PRODUCT: 'Catalog.EDIT_PRODUCT', GET_COLLECTIONS: 'Catalog.GET_COLLECTIONS', GET_MY_CATALOG: 'Catalog.GET_MY_CATALOG', GET_PRODUCT_BY_ID: 'Catalog.GET_PRODUCT_BY_ID', GET_PRODUCTS: 'Catalog.GET_PRODUCTS', REMOVE_PRODUCT_IMAGE: 'Catalog.REMOVE_PRODUCT_IMAGE', SET_PRODUCT_VISIBILITY: 'Catalog.SET_PRODUCT_VISIBILITY', UPDAGE_CART_ENABLED: 'Catalog.UPDAGE_CART_ENABLED', } export const Community = { ADD_SUB_GROUPS: 'Community.ADD_SUB_GROUPS', } export const Chat = { ARCHIVE: 'Chat.ARCHIVE', CAN_MARK_PLAYED: 'Chat.CAN_MARK_PLAYED', CAN_MUTE: 'Chat.CAN_MUTE', CAN_REPLY: 'Chat.CAN_REPLY', CLEAR: 'Chat.CLEAR', CLOSE_CHAT: 'Chat.CLOSE_CHAT', DELETE: 'Chat.DELETE', DELETE_MESSAGE: 'Chat.DELETE_MESSAGE', DOWNLOAD_MEDIA: 'Chat.DOWNLOAD_MEDIA', // ++ ADDED FIND: 'Chat.FIND', FORWARD_MESSAGE: 'Chat.FORWARD_MESSAGE', GET: 'Chat.GET', GET_ACTIVE_CHAT: 'Chat.GET_ACTIVE_CHAT', GET_LAST_SEEN: 'Chat.GET_LAST_SEEN', GET_MESSAGE_ACK: 'Chat.GET_MESSAGE_ACK', GET_MESSAGES: 'Chat.GET_MESSAGES', GET_NOTES: 'Chat.GET_NOTES', GET_PLATFORM_MESSAGE: 'Chat.GET_PLATFORM_MESSAGE', MARK_IS_COMPOSING: 'Chat.MARK_IS_COMPOSING', MARK_IS_PAUSED: 'Chat.MARK_IS_PAUSED', MARK_IS_READ: 'Chat.MARK_IS_READ', MARK_IS_RECORDING: 'Chat.MARK_IS_RECORDING', MARK_IS_UNREAD: 'Chat.MARK_IS_UNREAD', MARK_PLAYED: 'Chat.MARK_PLAYED', MUTE: 'Chat.MUTE', UNMUTE: 'Chat.UNMUTE', OPEN_CHAT_AT: 'Chat.OPEN_CHAT_AT', OPEN_CHAT_BOTTOM: 'Chat.OPEN_CHAT_BOTTOM', OPEN_CHAT_FROM_UNREAD: 'Chat.OPEN_CHAT_FROM_UNREAD', PIN: 'Chat.PIN', PIN_MSG: 'Chat.PIN_MSG', LIST: 'Chat.LIST', SET_CHAT_LIST: 'Chat.SET_CHAT_LIST', SET_INPUT_TEXT: 'Chat.SET_INPUT_TEXT', SET_NOTES: 'Chat.SET_NOTES', } export const Contact = { GET: 'Contact.GET', GET_BUSINESS_PROFILE: 'Contact.GET_BUSINESS_PROFILE', GET_COMMON_GROUPS: 'Contact.GET_COMMON_GROUPS', GET_PROFILE_PICTURE_URL: 'Contact.GET_PROFILE_PICTURE_URL', GET_STATUS: 'Contact.GET_STATUS', LIST: 'Contact.LIST', LIST_CONTACT_BY_COUNTRY: 'Contact.LIST_CONTACT_BY_COUNTRY', IS_EXIST: 'Contact.IS_EXIST', REMOVE: 'Contact.REMOVE', } export const Conn = { GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER: 'Conn.GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER', GET_AUTH_CODE: 'Conn.GET_AUTH_CODE', GET_PROFILE: 'Conn.GET_PROFILE', GET_MY_USER_ID: 'Conn.GET_MY_USER_ID', } export const Group = { ADD_PARTICIPANTS: 'Group.ADD_PARTICIPANTS', APPROVE: 'Group.APPROVE', LIST: 'Group.LIST', CAN_ADD: 'Group.CAN_ADD', CAN_DEMOTE: 'Group.CAN_DEMOTE', CAN_PROMOTE: 'Group.CAN_PROMOTE', CAN_REMOVE: 'Group.CAN_REMOVE', CREATE: 'Group.CREATE', DEMOTE_PARTICIPANTS: 'Group.DEMOTE_PARTICIPANTS', GET_GROUP_INFO_FROM_INVITE_CODE: 'Group.GET_GROUP_INFO_FROM_INVITE_CODE', GET_GROUP_SIZE_LIMIT: 'Group.GET_GROUP_SIZE_LIMIT', GET_INVITE_LINK: 'Group.GET_INVITE_LINK', GET_MEMBERSHIP_REQUESTS: 'Group.GET_MEMBERSHIP_REQUESTS', GET_PARTICIPANTS: 'Group.GET_PARTICIPANTS', IAM_ADMIN: 'Group.IAM_ADMIN', IAM_MEMBER: 'Group.IAM_MEMBER', IAM_RESTRICTED_MEMBER: 'Group.IAM_RESTRICTED_MEMBER', IAM_SUPER_ADMIN: 'Group.IAM_SUPER_ADMIN', JOIN: 'Group.JOIN', LEAVE: 'Group.LEAVE', PROMOTE_PARTICIPANTS: 'Group.PROMOTE_PARTICIPANTS', REJECT: 'Group.REJECT', REMOVE_ICON: 'Group.REMOVE_ICON', REMOVE_PARTICIPANTS: 'Group.REMOVE_PARTICIPANTS', REVOKE_INVITE_CODE: 'Group.REVOKE_INVITE_CODE', SET_DESCRIPTION: 'Group.SET_DESCRIPTION', SET_ICON: 'Group.SET_ICON', SET_PROPERTY: 'Group.SET_PROPERTY', SET_SUBJECT: 'Group.SET_SUBJECT', } export const Newsletter = { CREATE: 'Newsletter.CREATE', DESTROY: 'Newsletter.DESTROY', EDIT: 'Newsletter.EDIT', GET_SUBSCRIBERS: 'Newsletter.GET_SUBSCRIBERS', MUTE: 'Newsletter.MUTE', } export const Send = { TEXT: 'Send.TEXT', IMAGE: 'Send.IMAGE', LOCATION: 'Send.LOCATION', DOCUMENT: 'Send.DOCUMENT', FILE: 'Send.FILE', POLL: 'Send.POLL', VCARD: 'Send.VCARD', } export const Status = { GET: 'Status.GET', GET_MY_STATUS: 'Status.GET_MY_STATUS', REMOVE: 'Status.REMOVE', SEND_IMAGE_STATUS: 'Status.SEND_IMAGE_STATUS', SEND_READ_STATUS: 'Status.SEND_READ_STATUS', SEND_TEXT_STATUS: 'Status.SEND_TEXT_STATUS', SEND_VIDEO_STATUS: 'Status.SEND_VIDEO_STATUS', UPDATE_PARTICIPANTS: 'Status.UPDATE_PARTICIPANTS', } export const Profile = { EDIT_BUSINESS_PROFILE: 'Profile.EDIT_BUSINESS_PROFILE', GET_MY_PROFILE_NAME: 'Profile.GET_MY_PROFILE_NAME', GET_MY_PROFILE_PICTURE: 'Profile.GET_MY_PROFILE_PICTURE', GET_MY_STATUS: 'Profile.GET_MY_STATUS', IS_BUSINESS: 'Profile.IS_BUSINESS', REMOVE_MY_PROFILE_PICTURE: 'Profile.REMOVE_MY_PROFILE_PICTURE', SET_MY_PROFILE_NAME: 'Profile.SET_MY_PROFILE_NAME', SET_MY_PROFILE_PICTURE: 'Profile.SET_MY_PROFILE_PICTURE', SET_MY_STATUS: 'Profile.SET_MY_STATUS', } export const AI = { REWRITE_MESSAGE: 'AI.REWRITE_MESSAGE', } export const Window = { READY: 'Window.READY', NEW_MESSAGE: 'Window.NEW_MESSAGE', ACTIVE_CHAT: 'Window.ACTIVE_CHAT', GO_TO_PAGE: 'Window.GO_TO_PAGE', CLOSE_PAGE: 'Window.CLOSE_PAGE', SHOW_MODAL_MAIN: 'Window.SHOW_MODAL_MAIN', SHOW_MODAL_PRICING: 'Window.SHOW_MODAL_PRICING', SHOW_MODAL_ACTIVATION: 'Window.SHOW_MODAL_ACTIVATION', SHOW_MODAL_UPGRADE: 'Window.SHOW_MODAL_UPGRADE', SHOW_MODAL_PROFILE: 'Window.SHOW_MODAL_PROFILE', SHOW_MODAL_FAQ: 'Window.SHOW_MODAL_FAQ', SHOW_CONTACT_INFO: 'Window.SHOW_CONTACT_INFO', SEND_BROADCAST: 'Window.SEND_BROADCAST', TRIGGER_SCHEDULER: 'Window.TRIGGER_SCHEDULER', GO_TO_HISTORY_PAGE: 'Window.GO_TO_HISTORY_PAGE', } \`\`\` # src/constants/index.ts \`\`\`ts import { MessageSquare } from 'lucide-react' // src/constants/index.ts export * as Action from './action' export * as Setting from './setting' export const PRIMARY_ICON = MessageSquare export const LINK_BUY = 'https://extdotninja.lemonsqueezy.com/buy/7f1401c0-fd00-4898-af64-15a869f9fb12?logo=0' export const Status = { SUCCESS: 'SUCCESS', IDLE: 'IDLE', PENDING: 'PENDING', FAILED: 'FAILED', RUNNING: 'RUNNING', SCHEDULER: 'SCHEDULER', CANCELLED: 'CANCELLED', PAUSED: 'PAUSED', DRAFT: 'DRAFT', POSTED: 'POSTED', } export const Page = { CLOSE: 'Page.CLOSE', BROADCAST: 'Page.BROADCAST', CONTACTS: 'Page.CONTACTS', WORKFLOW: 'Page.WORKFLOW', STATUS: 'Page.STATUS', EXPORT: 'Page.EXPORT', TOOLS: 'Page.TOOLS', NUMBER_VALIDATOR: 'Page.NUMBER_VALIDATOR', DIRECT_CHAT: 'Page.DIRECT_CHAT', PRIVACY: 'Page.PRIVACY', FAQ: 'Page.FAQ', UPGRADE: 'Page.UPGRADE', ACTIVATE: 'Page.ACTIVATE', PROFILE: 'Page.PROFILE', QUICK_REPLY: 'Page.QUICK_REPLY', WA_ME_GENERATOR: 'Page.WA_ME_GENERATOR', LABEL: 'Page.LABEL', GROUP_LINK_GENERATOR: 'Page.GROUP_LINK_GENERATOR', CHAT_BACKUP: 'Page.CHAT_BACKUP', } export const Account = { BUSINESS: 'BUSINESS', PERSONAL: 'PERSONAL', } export const Message = { TEXT: 'TEXT', MEDIA: 'MEDIA', IMAGE: 'IMAGE', VIDEO: 'VIDEO', AUDIO: 'AUDIO', FILE: 'FILE', LOCATION: 'LOCATION', VCARD: 'VCARD', BUTTON: 'BUTTON', LIST: 'LIST', POLL: 'POLL', } export const Media = { BROADCAST: 'BROADCAST', BROADCAST_TEMPLATE: 'BROADCAST_TEMPLATE', STATUS_CONTENT: 'STATUS_CONTENT', QUICK_REPLY: 'QUICK_REPLY', SCHEDULED_MESSAGE: 'SCHEDULED_MESSAGE', WORKFLOW: 'WORKFLOW', } export const StatusType = { TEXT: 'TEXT_STATUS', IMAGE: 'IMAGE_STATUS', VIDEO: 'VIDEO_STATUS', } export const ContactType = { ALL: 'CONTACT_TYPE_ALL', SAVED_CONTACTS: 'CONTACT_TYPE_SAVED_CONTACTS', UNSAVED_CONTACTS: 'CONTACT_TYPE_UNSAVED_CONTACTS', } export const AccountType = { ALL: 'ACCOUNT_TYPE_ALL', PERSONAL: 'ACCOUNT_TYPE_PERSONAL', BUSINESS: 'ACCOUNT_TYPE_BUSINESS', } export const MessageType = { ALL: 'MESSAGE_TYPE_ALL', HAVE_UNREAD_MESSAGES: 'MESSAGE_TYPE_HAVE_UNREAD_MESSAGES', NO_UNREAD_MESSAGES: 'MESSAGE_TYPE_NO_UNREAD_MESSAGES', } export const SaveAs = { CSV: 'SAVE_AS_CSV', EXCEL: 'SAVE_AS_EXCEL', PDF: 'SAVE_AS_PDF', JSON: 'SAVE_AS_JSON', MARKDOWN: 'SAVE_AS_MARKDOWN', HTML: 'SAVE_AS_HTML', VCARD: 'SAVE_AS_VCARD', } \`\`\` # src/constants/setting.ts \`\`\`ts export const LICENSE_KEY = 'SETTING_LICENSE_KEY' export const OPEN_SIDEBAR = 'SETTING_OPEN_SIDEBAR' export const LICENSE_INSTANCE_ID = 'SETTING_LICENSE_INSTANCE_ID' export const LICENSE_DATA_CACHE = 'SETTING_LICENSE_DATA_CACHE' export const IS_FIRST_TIME = 'SETTING_IS_FIRST_TIME' export const NEED_TO_OPEN = 'SETTING_NEED_TO_OPEN' export const HAS_ACKNOWLEDGED_BROADCAST_WARNING = 'SETTING.HAS_ACKNOWLEDGED_BROADCAST_WARNING' // Privacy export const BLUR_PROFILE_PICTURES = 'SETTING.BLUR_PROFILE_PICTURES' export const BLUR_MESSAGES = 'SETTING.BLUR_MESSAGES' export const BLUR_USER_GROUP_NAMES = 'SETTING.BLUR_USER_GROUP_NAMES' export const BLUR_RECENT_MESSAGES = 'SETTING.BLUR_RECENT_MESSAGES' export const UNBLUR_ON_HOVER = 'SETTING.UNBLUR_ON_HOVER' // Export export const EXPORT_COLUMNS = 'SETTING_EXPORT_COLUMNS' // ++ ADDED: General & Appearance export const THEME_MODE = 'SETTING_THEME_MODE' export const NOTIFICATIONS_ENABLED = 'SETTING_NOTIFICATIONS_ENABLED' export const COMPACT_MODE = 'SETTING_COMPACT_MODE' // ++ ADDED: Automation export const AUTO_REPLY_DELAY = 'SETTING_AUTO_REPLY_DELAY' export const WORKFLOW_LOGGING = 'SETTING_WORKFLOW_LOGGING' // ++ ADDED: Storage export const AUTO_BACKUP = 'SETTING_AUTO_BACKUP' // ++ ADDED: Broadcast export const BROADCAST_DEFAULT_DELAY_MIN = 'SETTING_BROADCAST_DEFAULT_DELAY_MIN' export const BROADCAST_DEFAULT_DELAY_MAX = 'SETTING_BROADCAST_DEFAULT_DELAY_MAX' export const BROADCAST_SMART_PAUSE = 'SETTING_BROADCAST_SMART_PAUSE' export const BROADCAST_SLEEP_MODE = 'SETTING_BROADCAST_SLEEP_MODE' export const BROADCAST_CONFIRM_BEFORE_SEND = 'SETTING_BROADCAST_CONFIRM_BEFORE_SEND' \`\`\` # src/contents/chat.tsx \`\`\`tsx import ConfirmProvider from '@/components/Confirm/ConfirmProvider' import ToastProvider from '@/components/Toast/ToastProvider' import { Action } from '@/constants' import QuickReplyPopover from '@/features/quick-reply/components/QuickReplyPopover' import ModalScheduleMessage from '@/features/schedule-message/components/ModalScheduleMessage' import ScheduleMessageListener from '@/features/schedule-message/components/ScheduleMessageListener' import useLicense from '@/hooks/useLicense' import useWa from '@/hooks/useWa' import db from '@/libs/db' import theme from '@/libs/theme' import style from '@/utils/style' import toast from '@/utils/toast' import { postMessage } from '@/utils/util' import { Icon } from '@iconify/react' import { ActionIcon, CopyButton, MantineProvider, Stack, Tooltip, } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import type { PlasmoCSConfig, PlasmoGetOverlayAnchor, PlasmoGetShadowHostId, } from 'plasmo' import { useEffect } from 'react' import { When } from 'react-if' export const getShadowHostId: PlasmoGetShadowHostId = () => `crm-chat` export const config: PlasmoCSConfig = { matches: ['https://web.whatsapp.com/*'], } export const getOverlayAnchor: PlasmoGetOverlayAnchor = async () => document.querySelector('footer') export const getStyle = () => { const $style = document.createElement('style') $style.textContent = style.generate() return $style } const Chat = () => { const { activeChat, setActiveChat, chat, isReady } = useWa() const license = useLicense() // Schedule Modal State const [showScheduleModal, scheduleModalHandlers] = useDisclosure(false) useEffect(() => { license.init().catch(console.error) }, []) const handleContactInfo = async () => { if (!activeChat?.number) { toast.error('No active chat selected.') return } const contactNumber = activeChat.number.includes('@c.us') ? activeChat.number : `${activeChat.number}@c.us` // 1. Check if contact already exists const existingContact = await db.contacts .where({ number: contactNumber }) .first() if (!existingContact) { // 2. License Check for Free Users (Limit 10 Contacts) if (license.isFree()) { const count = await db.contacts.count() if (count >= 10) { toast.warning( 'Free plan limit reached (10 contacts). Upgrade to save more.', 'Warning', ) return } } try { // 3. Add to Database await db.contacts.add({ number: contactNumber, name: activeChat.name || activeChat.formattedTitle || 'Unknown', }) toast.success('Contact saved successfully!') // Initialize custom fields for the new contact const newContact = await db.contacts .where({ number: contactNumber }) .first() if (newContact?.id) { const fields = await db.customFields.toArray() if (fields.length > 0) { await db.contactCustomFields.bulkAdd( fields.map((f) => ({ contactId: newContact.id!, customFieldId: f.id, value: f.type === 'toggle' ? false : null, })), ) } } } catch (error) { console.error('Failed to save contact:', error) toast.error('Failed to save contact.') return } } // 4. Open Contact Info Panel in Sidebar // This sends a message to App.tsx to switch the tab to CONTACT_INFO postMessage(Action.Window.SHOW_CONTACT_INFO, { name: activeChat.name, number: contactNumber, }) } const renderMenu = () => { return ( <Stack ml={13} mb={100} pos={'absolute'} bottom={'-80px'} gap={'xs'}> <QuickReplyPopover chat={activeChat} /> <CopyButton value={activeChat.number || ''} timeout={2000}> {({ copied, copy }) => ( <Tooltip label={copied ? 'Copied!' : 'Copy Number'} position="right" withArrow > <ActionIcon variant="filled" size={32} radius={'50%'} color={copied ? 'teal' : undefined} onClick={copy} > <Icon icon={copied ? 'tabler:check' : 'tabler:copy'} fontSize={16} /> </ActionIcon> </Tooltip> )} </CopyButton> <When condition={activeChat?.isUser}> <Tooltip label="Contact Profile" position="right"> <ActionIcon variant="filled" size={32} radius={'50%'} onClick={handleContactInfo} > <Icon icon={'tabler:address-book'} fontSize={18} /> </ActionIcon> </Tooltip> </When> <Tooltip label="Schedule Message" position="right"> <ActionIcon variant="filled" size={32} radius={'50%'} onClick={scheduleModalHandlers.open} > <Icon icon={'tabler:calendar-time'} fontSize={18} /> </ActionIcon> </Tooltip> </Stack> ) } return ( <> <MantineProvider theme={theme} //@ts-ignore forceColorScheme="dark" cssVariablesSelector="div.plasmo-csui-container" getRootElement={() => document .getElementById('crm-chat') ?.shadowRoot?.querySelector('div.plasmo-csui-container') || undefined } > {renderMenu()} <ToastProvider /> <ConfirmProvider /> {/* Modal and Listener */} <ModalScheduleMessage opened={showScheduleModal} onClose={scheduleModalHandlers.close} chat={activeChat} /> <ScheduleMessageListener /> </MantineProvider> </> ) } export default Chat \`\`\` # src/contents/inject-script.ts \`\`\`ts import { Action } from '@/constants' import wa from '@/libs/wa' import { initInjectScriptRelays } from '@/relays' import serialize from '@/utils/serialize' import { postMessage } from '@/utils/util' import type { PlasmoCSConfig } from 'plasmo' export const config: PlasmoCSConfig = { matches: ['https://web.whatsapp.com/*'], world: 'MAIN', } initInjectScriptRelays() wa.on.ready(() => { setTimeout(() => { onReady() }, 100) }) const onReady = () => { setTimeout(() => { window.postMessage({ action: Action.Window.READY, body: {}, }) WPP.on('chat.active_chat', (chat) => { const body = serialize.chat(chat) postMessage(Action.Window.ACTIVE_CHAT, body) }) WPP.on('chat.new_message', (msg) => { const serializedMsg = serialize.message(msg) postMessage(Action.Window.NEW_MESSAGE, serializedMsg) }) }, 1000) } \`\`\` # src/contents/main.tsx \`\`\`tsx import App from '@/components/App' import ConfirmProvider from '@/components/Confirm/ConfirmProvider' import ToastProvider from '@/components/Toast/ToastProvider' import theme from '@/libs/theme' import style from '@/utils/style' import { MantineProvider } from '@mantine/core' import type { PlasmoCSConfig, PlasmoGetShadowHostId } from 'plasmo' export const getShadowHostId: PlasmoGetShadowHostId = () => `crm-main` export const config: PlasmoCSConfig = { matches: ['https://web.whatsapp.com/*'], } export const getStyle = () => { const $style = document.createElement('style') $style.textContent = style.generate() return $style } const Main = () => { return ( <> <MantineProvider theme={theme} //@ts-ignore forceColorScheme="dark" cssVariablesSelector="div.plasmo-csui-container" getRootElement={() => document .getElementById('crm-main') ?.shadowRoot?.querySelector('div.plasmo-csui-container') || undefined } > <App /> <ToastProvider /> <ConfirmProvider /> </MantineProvider> </> ) } export default Main \`\`\` # src/contents/message.tsx \`\`\`tsx import { Icon } from '@iconify/react' import type { PlasmoCSConfig, PlasmoCSUIProps, PlasmoGetOverlayAnchorList, PlasmoGetShadowHostId, } from 'plasmo' import { useEffect, useRef, useState, type CSSProperties } from 'react' export const getShadowHostId: PlasmoGetShadowHostId = () => `crm-message` export const config: PlasmoCSConfig = { matches: ['https://web.whatsapp.com/*'], } export const getOverlayAnchorList: PlasmoGetOverlayAnchorList = async () => document.querySelectorAll('.message-in') const Message = ({ anchor }: PlasmoCSUIProps) => { const [isHovered, setIsHovered] = useState(false) const [isButtonHovered, setIsButtonHovered] = useState(false) // Ref untuk menyimpan timer delay const hoverTimeoutRef = useRef<NodeJS.Timeout | null>(null) // Fungsi saat mouse masuk (Pesan atau Tombol) const handleMouseEnter = () => { if (hoverTimeoutRef.current) { clearTimeout(hoverTimeoutRef.current) hoverTimeoutRef.current = null } setIsHovered(true) } // Fungsi saat mouse keluar (tambah delay agar tidak langsung hilang) const handleMouseLeave = () => { hoverTimeoutRef.current = setTimeout(() => { setIsHovered(false) }, 150) // Delay 150ms memberi waktu user pindah ke tombol } useEffect(() => { const element = anchor.element if (!element) return element.addEventListener('mouseenter', handleMouseEnter) element.addEventListener('mouseleave', handleMouseLeave) // Cek kondisi awal jika mouse sudah ada di atas elemen saat inject if (element.matches(':hover')) { handleMouseEnter() } return () => { element.removeEventListener('mouseenter', handleMouseEnter) element.removeEventListener('mouseleave', handleMouseLeave) } }, [anchor.element]) const buttonStyle: CSSProperties = { appearance: 'none', border: 'none', outline: 'none', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', width: '25px', height: '25px', borderRadius: '50%', backgroundColor: '#10b981', color: 'white', boxShadow: '0 2px 5px rgba(0,0,0,0.15)', // Pastikan tombol selalu bisa menerima event mouse pointerEvents: 'auto', } const containerStyle: CSSProperties = { marginLeft: 15, marginTop: 6, opacity: isHovered ? 1 : 0, pointerEvents: isHovered ? 'auto' : 'none', display: 'flex', alignItems: 'center', height: '100%', zIndex: 999, position: 'relative', } const handleChangeText = () => { const messageRoot = anchor.element as HTMLElement // Selector ini berdasarkan struktur HTML WA yang kamu kirim: // Mencari class .selectable-text.copyable-text lalu ambil span di dalamnya const textSpan = messageRoot.querySelector( '.selectable-text.copyable-text span', ) as HTMLElement if (textSpan) { // Cek apakah isinya "Halo" (opsional, bisa langsung timpa saja jika mau) if (textSpan.textContent?.trim() === 'Halo') { textSpan.textContent = 'Selamat' console.log('Berhasil mengubah teks Halo menjadi Selamat') } else { // Jika ingin memaksa ubah apa pun isinya menjadi Selamat: textSpan.textContent = 'Selamat' } } else { console.error('Elemen teks tidak ditemukan di dalam pesan ini.') } } return null return ( <div style={containerStyle} // Tambahkan event handler ke container tombol juga agar tidak kedip onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave} > <button style={buttonStyle} onMouseEnter={() => setIsButtonHovered(true)} onMouseLeave={() => setIsButtonHovered(false)} title="Translate" onClick={(e) => { e.stopPropagation() e.preventDefault() handleChangeText() }} > <Icon icon="tabler:language" fontSize={20} /> </button> </div> ) } export default Message \`\`\` # src/features/backup-chat/PageBackup.tsx \`\`\`tsx import React from 'react' const PageBackupChat: React.FC = () => { return <div></div> } export default PageBackupChat \`\`\` # src/features/broadcast/components/Datatable/BroadcastColumns.tsx \`\`\`tsx import { Message, Status } from '@/constants' import type { Broadcast } from '@/libs/db' import { truncate } from '@/utils/util' import { Icon } from '@iconify/react' import { ActionIcon, Box, Group, Menu, Text, Tooltip } from '@mantine/core' import type { DataTableColumn } from 'mantine-datatable' import React from 'react' import BroadcastStatsCell from './BroadcastStatsCell' // Import the new component import MessageStatus from './MessageStatus' import MessageType from './MessageType' interface ColumnActions { onViewDetails: (broadcast: Broadcast) => void onExport: (broadcast: Broadcast, format: string) => void onCancel: (broadcastId: number) => void onDelete: (broadcast: Broadcast) => void onEditSchedule: (broadcast: Broadcast) => void onResend: (broadcast: Broadcast, target: 'ALL' | 'FAILED' | 'SUCCESS') => void } const renderMessagePreview = (broadcast: Broadcast) => { const { type, message } = broadcast if (!message) return 'N/A' switch (type) { case Message.TEXT: return typeof message === 'string' ? message : JSON.stringify(message) case Message.IMAGE: case Message.VIDEO: case Message.FILE: return (message as any).caption || `Media File (${type})` case Message.LOCATION: return (message as any).name || (message as any).address || 'Location' case Message.POLL: return (message as any).name || 'Poll' case Message.VCARD: return 'Contact Card' default: return `Unsupported type: ${type}` } } export const getBroadcastColumns = ( actions: ColumnActions, ): DataTableColumn<Broadcast>[] => { return [ { accessor: 'name', title: 'Name', sortable: true, width: 150, render: (broadcast) => <Text truncate>{broadcast.name || 'N/A'}</Text>, }, { accessor: 'type', title: 'Type', render: (broadcast) => <MessageType type={broadcast.type} />, width: 130, }, { accessor: 'message', title: 'Content Preview', render: (broadcast) => { const fullMessage = renderMessagePreview(broadcast) return ( <Tooltip label={fullMessage} multiline w={220} withArrow position="top-start" disabled={fullMessage.length <= 50} > <Text truncate>{truncate(fullMessage, 50)}</Text> </Tooltip> ) }, ellipsis: true, }, { accessor: 'status', title: 'Status', render: (broadcast) => { return <MessageStatus status={broadcast.status} /> }, width: 180, sortable: true, }, { accessor: 'stats', title: 'Recipients', // Use the isolated component here render: (broadcast) => ( <BroadcastStatsCell broadcastId={broadcast.id} status={broadcast.status} /> ), width: 160, }, { accessor: 'actions', title: <Box mr="xs">Actions</Box>, textAlign: 'right', width: '0%', render: (broadcast) => { const isFinished = [ Status.SUCCESS, Status.FAILED, Status.CANCELLED, ].includes(broadcast.status) const isRunning = [Status.PENDING, Status.RUNNING].includes( broadcast.status, ) const isScheduled = broadcast.status === Status.SCHEDULER return ( <Group gap={4} justify="flex-end" wrap="nowrap"> <Tooltip label="View Details"> <ActionIcon variant="subtle" color="blue" onClick={() => actions.onViewDetails(broadcast)} > <Icon icon="tabler:eye" /> </ActionIcon> </Tooltip> {isScheduled && ( <Tooltip label="Edit Schedule"> <ActionIcon variant="subtle" color="cyan" onClick={() => actions.onEditSchedule(broadcast)} > <Icon icon="tabler:clock-edit" /> </ActionIcon> </Tooltip> )} <Menu shadow="md" position="left" withArrow> <Menu.Target> <ActionIcon variant="subtle"> <Icon icon="tabler:download" /> </ActionIcon> </Menu.Target> <Menu.Dropdown> <Menu.Item onClick={() => actions.onExport(broadcast, 'csv')}> <Text>Export as CSV</Text> </Menu.Item> <Menu.Item onClick={() => actions.onExport(broadcast, 'xlsx')}> <Text>Export as XLSX</Text> </Menu.Item> </Menu.Dropdown> </Menu> {(isRunning || isScheduled) && ( <Tooltip label="Cancel Broadcast"> <ActionIcon variant="subtle" color="orange" onClick={() => actions.onCancel(broadcast.id)} > <Icon icon="tabler:player-stop" /> </ActionIcon> </Tooltip> )} {isFinished && ( <Menu shadow="lg" position="bottom-end" withArrow width={180}> <Menu.Target> <Tooltip label="Resend Broadcast"> <ActionIcon variant="subtle" color="cyan"> <Icon icon="tabler:repeat" /> </ActionIcon> </Tooltip> </Menu.Target> <Menu.Dropdown> <Menu.Item leftSection={<Icon icon="tabler:users" fontSize={16} />} onClick={() => actions.onResend(broadcast, 'ALL')} > All Recipients </Menu.Item> <Menu.Divider /> <Menu.Item color="red" leftSection={<Icon icon="tabler:x" fontSize={16} />} onClick={() => actions.onResend(broadcast, 'FAILED')} > Failed Only </Menu.Item> <Menu.Item color="teal" leftSection={<Icon icon="tabler:check" fontSize={16} />} onClick={() => actions.onResend(broadcast, 'SUCCESS')} > Success Only </Menu.Item> </Menu.Dropdown> </Menu> )} {isFinished && ( <Tooltip label="Delete Broadcast"> <ActionIcon variant="subtle" color="red" onClick={() => actions.onDelete(broadcast)} > <Icon icon="tabler:trash" /> </ActionIcon> </Tooltip> )} </Group> ) }, }, ] } \`\`\` # src/features/broadcast/components/Datatable/BroadcastStatsCell.tsx \`\`\`tsx import { Status } from '@/constants' import db from '@/libs/db' import { Box, Group, Progress, Stack, Text } from '@mantine/core' import { useLiveQuery } from 'dexie-react-hooks' import React, { useMemo } from 'react' interface Props { broadcastId: number status: string } const BroadcastStatsCell: React.FC<Props> = ({ broadcastId, status }) => { // Only fetch contacts for THIS specific broadcast const contacts = useLiveQuery( () => db.broadcastContacts.where({ broadcastId }).toArray(), [broadcastId], ) const stats = useMemo(() => { if (!contacts) return { total: 0, success: 0, pending: 0, failed: 0, running: 0 } let success = 0 let pending = 0 let failed = 0 let running = 0 // Using a simple loop is faster than multiple filters for (const c of contacts) { if (c.status === Status.SUCCESS) success++ else if (c.status === Status.FAILED) failed++ else if (c.status === Status.RUNNING) running++ else pending++ } return { total: contacts.length, success, pending, failed, running, } }, [contacts]) const isProcessing = status === Status.RUNNING || stats.running > 0 const processed = stats.success + stats.failed + stats.running // Include running in progress visual const progress = stats.total > 0 ? Math.round((processed / stats.total) * 100) : 0 return ( <Stack gap={4}> {isProcessing && stats.total > 0 && ( <Box mb={4}> <Group justify="space-between"> <Text size="xs" fw={500}> {progress}% </Text> <Text size="xs" c="dimmed"> {processed}/{stats.total} </Text> </Group> <Progress value={progress} size="sm" striped animated mt={2} color="emerald" /> </Box> )} {!isProcessing && <Text size="xs">Total: {stats.total}</Text>} {stats.success > 0 && ( <Text size="xs" c="teal"> Success: {stats.success} </Text> )} {stats.running > 0 && ( <Text size="xs" c="orange"> Sending: {stats.running} </Text> )} {stats.failed > 0 && ( <Text size="xs" c="red"> Failed: {stats.failed} </Text> )} {stats.pending > 0 && !isProcessing && ( <Text size="xs" c="dimmed"> Pending: {stats.pending} </Text> )} </Stack> ) } export default React.memo(BroadcastStatsCell) \`\`\` # src/features/broadcast/components/Datatable/MessageStatus.tsx \`\`\`tsx // src/features/broadcast/components/Datatable/MessageStatus.tsx import { Status } from '@/constants' import { Icon } from '@iconify/react' import { Group, Loader, Text, Tooltip } from '@mantine/core' import React from 'react' interface Props { status: string error?: string | null overrideText?: string | null tooltip?: string | null } const MessageStatus: React.FC<Props> = ({ status, error = null, overrideText = null, tooltip = null, }: Props) => { const statusConfig: { [key: string]: { color: string; icon: React.ReactNode; text: string } } = { [Status.RUNNING]: { color: 'yellow', icon: <Loader color="yellow" size={16} />, text: 'Running', }, [Status.PENDING]: { color: 'blue', icon: <Icon icon="tabler:clock" fontSize={18} />, text: 'Pending', }, [Status.SUCCESS]: { color: 'green', icon: <Icon icon="tabler:checks" fontSize={18} />, text: 'Done', }, [Status.CANCELLED]: { color: 'gray', icon: <Icon icon="tabler:cancel" fontSize={18} />, text: 'Cancelled', }, [Status.FAILED]: { color: 'red', icon: <Icon icon="tabler:x" fontSize={18} />, text: 'Failed', }, [Status.PAUSED]: { color: 'gray', icon: <Icon icon="tabler:player-pause" fontSize={18} />, text: 'Paused', }, [Status.SCHEDULER]: { color: 'cyan', icon: <Icon icon="tabler:calendar-time" fontSize={18} />, text: 'Scheduled', }, } const config = statusConfig[status] if (!config) { return <Text size="sm">{status}</Text> } const displayText = overrideText || config.text const content = ( <Group gap="xs" wrap="nowrap" align="center"> <Group gap={4} wrap="nowrap" align="center"> {config.icon} <Text size="sm" c={config.color} fw={500}> {displayText} </Text> </Group> </Group> ) const tooltipContent = error || tooltip return tooltipContent ? ( <Tooltip label={tooltipContent} position="top-start" multiline w={220} withArrow > {content} </Tooltip> ) : ( content ) } export default MessageStatus \`\`\` # src/features/broadcast/components/Datatable/MessageType.tsx \`\`\`tsx import { Message } from '@/constants' import { Icon } from '@iconify/react' import { Group, Text } from '@mantine/core' import _ from 'lodash' import React from 'react' interface Props { type: string } const MessageType: React.FC<Props> = ({ type }: Props) => { const icons = { [Message.TEXT]: 'tabler:text-size', [Message.MEDIA]: 'tabler:library-photo', [Message.BUTTON]: 'tabler:hand-finger', [Message.LIST]: 'tabler:list', [Message.LOCATION]: 'tabler:map-pin', [Message.POLL]: 'tabler:list-details', [Message.VCARD]: 'tabler:user-square', } const icon = icons[type] ?? 'tabler:text-size' return ( <Group gap={4}> <Icon icon={icon} fontSize={18} /> <Text>{_.startCase(type?.toLowerCase())}</Text> </Group> ) } export default MessageType \`\`\` # src/features/broadcast/components/Excel/ExcelUploader.tsx \`\`\`tsx import { Icon } from '@iconify/react' import { ActionIcon, Button, FileInput, Group, ScrollArea, Stack, Table, Text, } from '@mantine/core' import FileSaver from 'file-saver' import React, { useState } from 'react' import * as XLSX from 'xlsx' interface Props { onConfirm: (data: any[]) => void onClose: () => void } /** * @component ExcelUploader * @description A generic component for uploading, parsing, previewing, and confirming Excel data. * It encapsulates the core logic previously duplicated in ModalSourceExcel and ExcelUploadPopover. */ const ExcelUploader: React.FC<Props> = ({ onConfirm, onClose }) => { const [parsedData, setParsedData] = useState<any[]>([]) const [excelFile, setExcelFile] = useState<File | null>(null) // Function to download a sample Excel template const handleDownloadSample = () => { const sampleData = [{ number: '6281234567890', name: 'John Doe' }] const worksheet = XLSX.utils.json_to_sheet(sampleData) const workbook = XLSX.utils.book_new() XLSX.utils.book_append_sheet(workbook, worksheet, 'Contacts') const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array', }) const data = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8', }) FileSaver.saveAs(data, 'sample_contacts.xlsx') } // Handles file selection and parsing const handleFileChange = (file: File | null) => { if (!file) { setParsedData([]) setExcelFile(null) return } setExcelFile(file) const reader = new FileReader() reader.onload = (event) => { const data = new Uint8Array(event.target?.result as ArrayBuffer) const workbook = XLSX.read(data, { type: 'array' }) const sheetName = workbook.SheetNames[0] const worksheet = workbook.Sheets[sheetName] const json = XLSX.utils.sheet_to_json(worksheet) setParsedData(json) } reader.readAsArrayBuffer(file) } // Removes a specific row from the preview data const handleDeleteRow = (indexToRemove: number) => { setParsedData((currentData) => currentData.filter((_, index) => index !== indexToRemove), ) } // Confirms the upload, passes the data to the parent, and calls the parent's close handler const handleConfirmUpload = () => { onConfirm(parsedData) onClose() } // Resets state and calls the parent's close handler const handleClose = () => { setParsedData([]) setExcelFile(null) onClose() } return ( <> <Text size="xs" c="dimmed" mt={-10}> File must contain a 'number' column. </Text> <Group justify="center"> <Button variant="light" size="xs" onClick={handleDownloadSample} leftSection={<Icon icon="tabler:download" />} > Download Sample </Button> </Group> <FileInput placeholder="Choose file" onChange={handleFileChange} accept=".xlsx, .xls, .csv" clearable value={excelFile} /> {parsedData.length > 0 && ( <> <Text size="sm">Data Preview:</Text> <ScrollArea h={150}> <Table striped highlightOnHover withTableBorder withColumnBorders fz="xs" > <Table.Thead> <Table.Tr> <Table.Th>Number</Table.Th> <Table.Th>Name</Table.Th> <Table.Th></Table.Th> </Table.Tr> </Table.Thead> <Table.Tbody> {parsedData.map((row, index) => ( <Table.Tr key={index}> <Table.Td>{row.number}</Table.Td> <Table.Td>{row.name}</Table.Td> <Table.Td> <ActionIcon color="red" variant="transparent" onClick={() => handleDeleteRow(index)} > <Icon icon="tabler:trash" fontSize={16} /> </ActionIcon> </Table.Td> </Table.Tr> ))} </Table.Tbody> </Table> </ScrollArea> </> )} <Group justify="flex-end" mt="md"> <Button variant="default" onClick={handleClose}> Cancel </Button> <Button onClick={handleConfirmUpload} disabled={parsedData.length === 0} > Add {parsedData.length} Numbers </Button> </Group> </> ) } export default ExcelUploader \`\`\` # src/features/broadcast/components/Excel/ExcelUploadPopover.tsx \`\`\`tsx import { Icon } from '@iconify/react' import { Button, Popover, Stack, Text, Tooltip } from '@mantine/core' import React, { useState } from 'react' import ExcelUploader from './ExcelUploader' interface Props { onConfirm: (data: any[]) => void } /** * @component ExcelUploadPopover * @description A popover component for Excel uploads, now refactored to use the generic ExcelUploader. * It acts as a lightweight wrapper, placing the uploader logic inside a Mantine Popover. */ const ExcelUploadPopover: React.FC<Props> = ({ onConfirm }) => { const [popoverOpened, setPopoverOpened] = useState(false) return ( <Popover opened={popoverOpened} onChange={setPopoverOpened} withArrow shadow="md" position="bottom-end" > <Popover.Target> <Tooltip label="Upload excel" position="top"> <Button size={'compact-sm'} variant="outline" onClick={() => setPopoverOpened((o) => !o)} > <Icon icon={'tabler:file-type-xls'} fontSize={24} /> </Button> </Tooltip> </Popover.Target> <Popover.Dropdown w={350}> <Stack> <Text size="sm" fw={500}> Upload Excel File </Text> <ExcelUploader onConfirm={onConfirm} onClose={() => setPopoverOpened(false)} /> </Stack> </Popover.Dropdown> </Popover> ) } export default ExcelUploadPopover \`\`\` # src/features/broadcast/components/Form/BatchingSettings.tsx \`\`\`tsx import useLicense from '@/hooks/useLicense' import toast from '@/utils/toast' import { showModalUpgrade } from '@/utils/util' import { Icon } from '@iconify/react' import { Badge, Collapse, Group, NumberInput, SimpleGrid, Switch, Text, Tooltip, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import { useDisclosure } from '@mantine/hooks' import React from 'react' interface Props { form: UseFormReturnType<any> } const BatchingSettings: React.FC<Props> = ({ form }) => { const license = useLicense() const [opened, { toggle, open, close }] = useDisclosure(false) return ( <> <Switch label={ <Group gap={4} wrap="nowrap"> <Text fw={500}>Batching</Text> {license.isFree() && ( <Badge color="yellow" variant="light" size="sm"> Pro </Badge> )} <Tooltip label="Split large broadcasts into smaller batches with a rest period in between. Crucial for avoiding bans." position="top-start" withArrow > <Icon icon="tabler:info-circle" style={{ display: 'block' }} /> </Tooltip> </Group> } checked={license.isFree() ? false : form.values.batching?.enabled} onChange={(event) => { if (license.isFree()) { toast.warning('Only for Pro users, Please Upgrade', 'Warning') showModalUpgrade() return } form.setFieldValue('batching.enabled', event.currentTarget.checked) }} /> <Collapse in={!license.isFree() && form.values.batching?.enabled}> <SimpleGrid cols={2} mt="xs"> <NumberInput label="Batch Size" description="Messages per batch" placeholder="e.g. 50" min={1} allowNegative={false} size="sm" {...form.getInputProps('batching.size')} /> <NumberInput label="Batch Delay" description="Minutes to sleep after batch" placeholder="e.g. 5" min={1} allowNegative={false} size="sm" {...form.getInputProps('batching.delay')} /> </SimpleGrid> </Collapse> </> ) } export default BatchingSettings \`\`\` # src/features/broadcast/components/Form/BroadcastActions.tsx \`\`\`tsx import { Icon } from '@iconify/react' import { Button, Group } from '@mantine/core' import { isFuture } from 'date-fns' import React from 'react' interface Props { onSend: () => void isScheduled: boolean scheduledAt: Date | null } /** * @component BroadcastActions * @description A sub-component for ModalCreateBroadcast that holds the main action buttons. * It displays a dynamic "Send/Schedule Broadcast" button. */ const BroadcastActions: React.FC<Props> = ({ onSend, isScheduled, scheduledAt, }: Props) => { const isScheduledForFuture = isScheduled && scheduledAt && isFuture(new Date(scheduledAt)) return ( <Group justify="flex-end" mt="lg"> <Button leftSection={<Icon icon="tabler:send" fontSize={18} />} onClick={onSend} > {isScheduledForFuture ? 'Schedule Broadcast' : 'Send Broadcast'} </Button> </Group> ) } export default BroadcastActions \`\`\` # src/features/broadcast/components/Form/BroadcastActionsSetup.tsx \`\`\`tsx import db, { type DelayPayload, type ExportReportPayload, type GroupReportPayload, type IncrementFieldPayload, type NotePayload, type SelfMessagePayload, type UpdateFieldPayload, } from '@/libs/db' import type { BroadcastAction } from '@/libs/db' import { useAppStore } from '@/stores/app' import { Icon } from '@iconify/react' import { ActionIcon, Alert, Blockquote, Button, Center, Group, NumberInput, SegmentedControl, Select, Stack, Text, Textarea, TextInput, ThemeIcon, Timeline, Tooltip, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import { randomId, useDisclosure } from '@mantine/hooks' import { useLiveQuery } from 'dexie-react-hooks' import _ from 'lodash' import React, { useMemo, useState } from 'react' import { When } from 'react-if' import ModalAddAction from './ModalAddAction' interface Props { form: UseFormReturnType<any> } const BroadcastActionsSetup: React.FC<Props> = ({ form }) => { const [activeTab, setActiveTab] = useState<'SUCCESS' | 'FAILED' | 'COMPLETE'>( 'SUCCESS', ) const [modalOpened, modalHandlers] = useDisclosure(false) // Fetch groups from app store for SEND_REPORT_GROUP const { groups } = useAppStore() const groupOptions = useMemo( () => groups.map((g: any) => ({ value: g.id._serialized || g.id, label: g.name || 'Unknown Group', })), [groups], ) // Fetch tags from database for the dropdown const tags = useLiveQuery(() => db.tags.toArray()) || [] const tagOptions = useMemo( () => tags.map((t) => ({ value: t.name, label: t.name })), [tags], ) // Fetch custom fields from database const customFields = useLiveQuery(() => db.customFields.toArray()) || [] const customFieldOptions = useMemo( () => customFields.map((f) => ({ value: String(f.id), label: f.name })), [customFields], ) const actions = form.values.actions || [] // Helper to get actions specific to the current tab const currentActions = actions .map((action: any, index: number) => ({ ...action, _index: index })) .filter((action: any) => action.trigger === activeTab) // 7. Logic Safety: Detect conflicting actions (e.g., Add Tag A & Remove Tag A) const conflictingTags = useMemo(() => { const addTags = currentActions .filter((a: any) => a.type === 'ADD_TAG' && a.payload) .map((a: any) => a.payload) const removeTags = currentActions .filter((a: any) => a.type === 'REMOVE_TAG' && a.payload) .map((a: any) => a.payload) return _.intersection(addTags, removeTags) }, [currentActions]) // 8. Natural Language Summary const summaryText = useMemo(() => { if (currentActions.length === 0) return null const descriptions = currentActions.map((action: any) => { const getFieldName = (id: number) => customFields.find((f) => f.id === id)?.name || 'field' switch (action.type) { case 'ADD_TAG': return `add tag '${action.payload || '...'}'` case 'REMOVE_TAG': return `remove tag '${action.payload || '...'}'` case 'ARCHIVE_CHAT': return 'archive the chat' case 'UPDATE_FIELD': { const p = action.payload as UpdateFieldPayload const fieldName = p?.customFieldId ? getFieldName(p.customFieldId) : '...' return `set ${fieldName} to '${p?.value || '...'}'` } case 'INCREMENT_FIELD': { const ip = action.payload as IncrementFieldPayload const fieldName = ip?.customFieldId ? getFieldName(ip.customFieldId) : '...' return `increment ${fieldName} by ${ip?.incrementBy || 1}` } case 'CLEAR_CHAT': return 'clear the chat' case 'DELETE_CHAT': return 'delete the chat' case 'PIN_CHAT': return 'pin the chat' case 'UNPIN_CHAT': return 'unpin the chat' case 'SELF_MESSAGE': { const sm = action.payload as SelfMessagePayload return `send self-message: '${sm?.message?.substring(0, 20) || '...'}...'` } case 'ADD_NOTE': { const n = action.payload as NotePayload return `add note: '${n?.content?.substring(0, 20) || '...'}...'` } case 'DELAY': { const d = action.payload as DelayPayload return `wait ${d?.seconds || '...'}s` } case 'EXPORT_REPORT': { const er = action.payload as ExportReportPayload return `export report as ${er?.format?.toUpperCase() || 'CSV'}` } case 'MUTE_CHAT': return 'mute the chat' case 'BLOCK_CONTACT': return 'block the contact' case 'SEND_STATS_SELF': return 'send stats to self' case 'SEND_REPORT_GROUP': return 'send report to group' default: return 'perform action' } }) // Join with commas and "and" for the last item const actionText = descriptions.length > 1 ? descriptions.slice(0, -1).join(', ') + ' and ' + descriptions.slice(-1) : descriptions[0] const triggerText = activeTab === 'SUCCESS' ? 'succeeds' : activeTab === 'FAILED' ? 'fails' : 'all finish' return `If delivery ${triggerText}, then ${actionText}.` }, [currentActions, activeTab, customFields]) const handleAddAction = (type: BroadcastAction['type']) => { form.insertListItem('actions', { id: randomId(), trigger: activeTab, type, payload: '', }) } const handleRemoveAction = (originalIndex: number) => { form.removeListItem('actions', originalIndex) } const getActionIcon = (type: string) => { switch (type) { case 'ADD_TAG': return 'tabler:tag' case 'REMOVE_TAG': return 'tabler:tag-off' case 'ARCHIVE_CHAT': return 'tabler:archive' case 'UPDATE_FIELD': return 'tabler:forms' case 'INCREMENT_FIELD': return 'tabler:plus' case 'CLEAR_CHAT': return 'tabler:eraser' case 'DELETE_CHAT': return 'tabler:trash' case 'PIN_CHAT': return 'tabler:pin' case 'UNPIN_CHAT': return 'tabler:pin-off' case 'SELF_MESSAGE': return 'tabler:message-report' case 'ADD_NOTE': return 'tabler:note' case 'DELAY': return 'tabler:clock-pause' case 'EXPORT_REPORT': return 'tabler:file-export' case 'MUTE_CHAT': return 'tabler:bell-off' case 'BLOCK_CONTACT': return 'tabler:ban' case 'SEND_STATS_SELF': return 'tabler:chart-bar' case 'SEND_REPORT_GROUP': return 'tabler:users-group' default: return 'tabler:bolt' } } const getActionLabel = (type: string) => { switch (type) { case 'ADD_TAG': return 'Add Tag' case 'REMOVE_TAG': return 'Remove Tag' case 'ARCHIVE_CHAT': return 'Archive Chat' case 'UPDATE_FIELD': return 'Update Custom Field' case 'INCREMENT_FIELD': return 'Increment Field' case 'CLEAR_CHAT': return 'Clear Chat' case 'DELETE_CHAT': return 'Delete Chat' case 'PIN_CHAT': return 'Pin Chat' case 'UNPIN_CHAT': return 'Unpin Chat' case 'SELF_MESSAGE': return 'Self-Message' case 'ADD_NOTE': return 'Add Contact Note' case 'DELAY': return 'Wait / Delay' case 'EXPORT_REPORT': return 'Export Report' case 'MUTE_CHAT': return 'Mute Chat' case 'BLOCK_CONTACT': return 'Block Contact' case 'SEND_STATS_SELF': return 'Send Stats to Self' case 'SEND_REPORT_GROUP': return 'Send Report to Group' default: return 'Action' } } const themeColor = activeTab === 'SUCCESS' ? 'teal' : activeTab === 'FAILED' ? 'red' : 'blue' return ( <Stack gap="sm"> <Group justify="space-between" align="center"> <Group gap={6}> <Text fw={600} size="sm"> Post-Broadcast Automation </Text> <Tooltip label="Perform actions automatically based on delivery status" withArrow > <Icon icon="tabler:info-circle" style={{ opacity: 0.5 }} /> </Tooltip> </Group> </Group> {/* Grouping Toggle */} <SegmentedControl fullWidth value={activeTab} size="sm" onChange={(val: 'SUCCESS' | 'FAILED' | 'COMPLETE') => setActiveTab(val)} color={themeColor} data={[ { value: 'SUCCESS', label: ( <Group gap={6} justify="center"> <Icon icon="tabler:circle-check" fontSize={16} color="var(--mantine-color-teal-5)" /> On Success </Group> ), }, { value: 'FAILED', label: ( <Group gap={6} justify="center"> <Icon icon="tabler:alert-circle" fontSize={16} color="var(--mantine-color-red-5)" /> On Failure </Group> ), }, { value: 'COMPLETE', label: ( <Group gap={6} justify="center"> <Icon icon="tabler:flag-check" fontSize={16} color="var(--mantine-color-blue-5)" /> On Complete </Group> ), }, ]} /> {/* Trigger Description */} <Text size="xs" c="dimmed" ta="center"> {activeTab === 'SUCCESS' && 'Actions run after EACH successful message delivery'} {activeTab === 'FAILED' && 'Actions run after EACH failed message delivery'} {activeTab === 'COMPLETE' && 'Actions run ONCE after ALL broadcasts finish'} </Text> <Stack p="md" style={{ backgroundColor: 'rgba(255,255,255,0.03)', borderRadius: 'var(--mantine-radius-md)', border: '1px solid var(--mantine-color-default-border)', minHeight: 180, }} justify="space-between" > {currentActions.length === 0 ? ( // Empty State <Center style={{ flex: 1, flexDirection: 'column', opacity: 0.6 }}> <ThemeIcon size={48} radius="xl" variant="light" color="gray" mb="sm" > <Icon icon="tabler:robot" fontSize={28} /> </ThemeIcon> <Text size="sm" fw={500}> Automate your CRM </Text> <Text size="xs" c="dimmed" ta="center" maw={250}> Example: Add tag 'Lead' if the message is successfully delivered. </Text> </Center> ) : ( <Stack gap="sm"> {/* Logic Safety Alert */} <When condition={conflictingTags.length > 0}> <Alert variant="light" color="orange" title="Conflict Detected" icon={<Icon icon="tabler:alert-triangle" />} p="xs" > <Text size="xs"> You are adding and removing the same tag:{' '} <b>{conflictingTags.join(', ')}</b>. These actions will cancel each other out. </Text> </Alert> </When> {/* Visual Flow: Timeline */} <Timeline active={currentActions.length} bulletSize={24} lineWidth={2} color={themeColor} > {currentActions.map((action: any, i: number) => { const originalIndex = action._index const isTagAction = ['ADD_TAG', 'REMOVE_TAG'].includes( action.type, ) return ( <Timeline.Item key={action.id || i} bullet={ <ThemeIcon size={24} radius="xl" variant="light" color={themeColor} > <Icon icon={getActionIcon(action.type)} fontSize={14} /> </ThemeIcon> } > <Group align="flex-start" justify="space-between" wrap="nowrap" > <Stack gap="xs" style={{ flex: 1 }}> <Text size="sm" fw={500}> {getActionLabel(action.type)} </Text> <When condition={isTagAction}> <Select size="xs" placeholder="Select a tag" data={tagOptions} searchable nothingFoundMessage="No tags found" {...form.getInputProps( `actions.${originalIndex}.payload`, )} comboboxProps={{ withinPortal: false }} rightSection={ <Icon icon="tabler:tag" fontSize={14} style={{ opacity: 0.5 }} /> } /> </When> <When condition={action.type === 'UPDATE_FIELD'}> <Select size="xs" placeholder="Select field" data={customFieldOptions} searchable nothingFoundMessage="No custom fields found" value={ form.values.actions[originalIndex]?.payload ?.customFieldId ? String( form.values.actions[originalIndex].payload .customFieldId, ) : null } onChange={(val) => { const current = form.values.actions[originalIndex]?.payload || {} form.setFieldValue( `actions.${originalIndex}.payload`, { ...current, customFieldId: val ? Number(val) : null, }, ) }} comboboxProps={{ withinPortal: false }} rightSection={ <Icon icon="tabler:forms" fontSize={14} style={{ opacity: 0.5 }} /> } /> <TextInput size="xs" placeholder="Value to set" value={ form.values.actions[originalIndex]?.payload ?.value || '' } onChange={(e) => { const current = form.values.actions[originalIndex]?.payload || {} form.setFieldValue( `actions.${originalIndex}.payload`, { ...current, value: e.target.value, }, ) }} rightSection={ <Icon icon="tabler:pencil" fontSize={14} style={{ opacity: 0.5 }} /> } /> </When> <When condition={action.type === 'INCREMENT_FIELD'}> <Select size="xs" placeholder="Select field" data={customFieldOptions} searchable nothingFoundMessage="No custom fields found" value={ form.values.actions[originalIndex]?.payload ?.customFieldId ? String( form.values.actions[originalIndex].payload .customFieldId, ) : null } onChange={(val) => { const current = form.values.actions[originalIndex]?.payload || {} form.setFieldValue( `actions.${originalIndex}.payload`, { ...current, customFieldId: val ? Number(val) : null, }, ) }} comboboxProps={{ withinPortal: false }} rightSection={ <Icon icon="tabler:forms" fontSize={14} style={{ opacity: 0.5 }} /> } /> <NumberInput size="xs" placeholder="Increment by" min={1} value={ form.values.actions[originalIndex]?.payload ?.incrementBy || 1 } onChange={(val) => { const current = form.values.actions[originalIndex]?.payload || {} form.setFieldValue( `actions.${originalIndex}.payload`, { ...current, incrementBy: val || 1, }, ) }} rightSection={ <Text size="xs" c="dimmed"> + </Text> } rightSectionWidth={24} /> </When> <When condition={action.type === 'SELF_MESSAGE'}> <Textarea size="xs" placeholder="Message to send to yourself (Note to Self)" minRows={2} value={ form.values.actions[originalIndex]?.payload ?.message || '' } onChange={(e) => { form.setFieldValue( `actions.${originalIndex}.payload`, { message: e.target.value }, ) }} /> </When> <When condition={action.type === 'ADD_NOTE'}> <Textarea size="xs" placeholder="Note content to add to contact" minRows={2} value={ form.values.actions[originalIndex]?.payload ?.content || '' } onChange={(e) => { form.setFieldValue( `actions.${originalIndex}.payload`, { content: e.target.value }, ) }} /> </When> <When condition={action.type === 'DELAY'}> <NumberInput size="xs" placeholder="Seconds to wait" min={1} max={300} value={ form.values.actions[originalIndex]?.payload ?.seconds || 5 } onChange={(val) => { form.setFieldValue( `actions.${originalIndex}.payload`, { seconds: val || 5 }, ) }} rightSection={ <Text size="xs" c="dimmed"> sec </Text> } rightSectionWidth={32} /> </When> <When condition={action.type === 'EXPORT_REPORT'}> <Select size="xs" placeholder="Export format" data={[ { value: 'csv', label: 'CSV' }, { value: 'xlsx', label: 'Excel (XLSX)' }, ]} value={ form.values.actions[originalIndex]?.payload ?.format || 'csv' } onChange={(val) => { form.setFieldValue( `actions.${originalIndex}.payload`, { format: val || 'csv' }, ) }} allowDeselect={false} comboboxProps={{ withinPortal: false }} /> </When> <When condition={action.type === 'SEND_REPORT_GROUP'}> <Select size="xs" placeholder="Select group" data={groupOptions} searchable value={ form.values.actions[originalIndex]?.payload ?.groupId || '' } onChange={(val) => { form.setFieldValue( `actions.${originalIndex}.payload`, { groupId: val || '' }, ) }} allowDeselect={false} comboboxProps={{ withinPortal: false }} /> </When> </Stack> <ActionIcon color="red" variant="subtle" size="sm" onClick={() => handleRemoveAction(originalIndex)} > <Icon icon="tabler:trash" fontSize={16} /> </ActionIcon> </Group> </Timeline.Item> ) })} </Timeline> </Stack> )} <Stack gap="xs" mt={currentActions.length > 0 ? 'md' : 0}> <Button variant="light" size="xs" fullWidth leftSection={<Icon icon="tabler:plus" fontSize={14} />} onClick={modalHandlers.open} color={themeColor} > Add Action </Button> {/* 8. Natural Language Summary */} <When condition={!!summaryText}> <Blockquote color={themeColor} radius="sm" iconSize={20} p="xs" mt="xs" styles={{ root: { backgroundColor: 'rgba(0,0,0,0.2)', borderLeftWidth: 2, }, }} icon={<Icon icon="tabler:quote" fontSize={14} />} > <Text size="xs" c="dimmed" style={{ fontStyle: 'italic' }}> {summaryText} </Text> </Blockquote> </When> </Stack> </Stack> <ModalAddAction opened={modalOpened} onClose={modalHandlers.close} onSelect={handleAddAction} activeTrigger={activeTab} /> </Stack> ) } export default BroadcastActionsSetup \`\`\` # src/features/broadcast/components/Form/BroadcastScheduler.tsx \`\`\`tsx import InputSendLater from '@/components/Input/InputSendLater' import { Icon } from '@iconify/react' import { Group, Stack, Text } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' interface Props { form: UseFormReturnType<any> } /** * @component BroadcastScheduler * @description A sub-component for ModalCreateBroadcast that handles scheduling. * It contains the "Send Later" switch and date/time picker. */ const BroadcastScheduler: React.FC<Props> = ({ form }) => { return ( <Stack> <InputSendLater form={form} /> </Stack> ) } export default BroadcastScheduler \`\`\` # src/features/broadcast/components/Form/ModalAddAction.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import useLicense from '@/hooks/useLicense' // ++ ADDED import type { BroadcastAction } from '@/libs/db' import { showModalUpgrade } from '@/utils/util' // ++ ADDED import { Icon } from '@iconify/react' import { Badge, // ++ ADDED Card, Group, ScrollArea, SimpleGrid, Stack, Text, ThemeIcon, Tooltip, UnstyledButton, } from '@mantine/core' import React from 'react' // Actions that only work in COMPLETE trigger const COMPLETE_ONLY_ACTIONS = [ 'SELF_MESSAGE', 'EXPORT_REPORT', 'SEND_STATS_SELF', 'SEND_REPORT_GROUP', ] // Action categories for the picker const ACTION_CATEGORIES = [ { title: 'Contact Management', items: [ { type: 'ADD_TAG', label: 'Add Tag', description: 'Attach a tag to the contact', icon: 'tabler:tag', color: 'violet', isPro: true, // ++ ADDED: Locked for Pro }, { type: 'REMOVE_TAG', label: 'Remove Tag', description: 'Detach a tag from the contact', icon: 'tabler:tag-off', color: 'grape', isPro: true, // ++ ADDED: Locked for Pro }, { type: 'UPDATE_FIELD', label: 'Update Custom Field', description: 'Set a custom field value', icon: 'tabler:forms', color: 'indigo', isPro: true, }, { type: 'INCREMENT_FIELD', label: 'Increment Field', description: 'Increase a number field by a value', icon: 'tabler:plus', color: 'teal', isPro: true, }, { type: 'ADD_NOTE', label: 'Add Note', description: 'Add note to contact profile', icon: 'tabler:note', color: 'cyan', }, ], }, { title: 'Chat Actions', items: [ { type: 'ARCHIVE_CHAT', label: 'Archive Chat', description: 'Move chat to archive', icon: 'tabler:archive', color: 'pink', }, { type: 'PIN_CHAT', label: 'Pin Chat', description: 'Pin chat to top of list', icon: 'tabler:pin', color: 'orange', }, { type: 'UNPIN_CHAT', label: 'Unpin Chat', description: 'Remove chat from pinned', icon: 'tabler:pin-off', color: 'yellow', }, { type: 'CLEAR_CHAT', label: 'Clear Chat', description: 'Clear messages (keep starred)', icon: 'tabler:eraser', color: 'lime', }, { type: 'DELETE_CHAT', label: 'Delete Chat', description: 'Permanently delete the chat', icon: 'tabler:trash', color: 'red', }, { type: 'MUTE_CHAT', label: 'Mute Chat', description: 'Mute notifications for 8 hours', icon: 'tabler:bell-off', color: 'gray', }, { type: 'BLOCK_CONTACT', label: 'Block Contact', description: 'Block the contact from messaging you', icon: 'tabler:ban', color: 'dark', }, ], }, { title: 'Utilities', items: [ { type: 'SELF_MESSAGE', label: 'Self-Message', description: 'Send message to yourself (Note to Self)', icon: 'tabler:message-report', color: 'teal', }, { type: 'DELAY', label: 'Wait / Delay', description: 'Wait before next action', icon: 'tabler:clock-pause', color: 'blue', }, { type: 'EXPORT_REPORT', label: 'Export Report', description: 'Auto-download broadcast results as CSV/Excel', icon: 'tabler:file-export', color: 'emerald', isPro: true, // ++ ADDED: Locked for Pro }, { type: 'SEND_STATS_SELF', label: 'Send Stats to Self', description: 'Send summary statistics to Note to Self', icon: 'tabler:chart-bar', color: 'violet', isPro: true, // ++ ADDED: Locked for Pro }, { type: 'SEND_REPORT_GROUP', label: 'Send Report to Group', description: 'Send summary to a WhatsApp group', icon: 'tabler:users-group', color: 'pink', isPro: true, // ++ ADDED: Locked for Pro }, ], }, ] interface Props { opened: boolean onClose: () => void onSelect: (type: BroadcastAction['type']) => void activeTrigger: 'SUCCESS' | 'FAILED' | 'COMPLETE' } // Actions that require specific contact/chat context (not available in COMPLETE) const CONTACT_REQUIRED_ACTIONS = [ 'ADD_TAG', 'REMOVE_TAG', 'UPDATE_FIELD', 'INCREMENT_FIELD', 'ADD_NOTE', 'ARCHIVE_CHAT', 'PIN_CHAT', 'UNPIN_CHAT', 'CLEAR_CHAT', 'DELETE_CHAT', 'MUTE_CHAT', 'BLOCK_CONTACT', ] const ModalAddAction: React.FC<Props> = ({ opened, onClose, onSelect, activeTrigger, }) => { const license = useLicense() // ++ ADDED const handleSelect = (type: BroadcastAction['type'], isPro: boolean) => { // ++ ADDED: License Check if (isPro && license.isFree()) { showModalUpgrade() return } onSelect(type) onClose() } const isActionDisabled = (type: string) => { // SELF_MESSAGE and EXPORT_REPORT only available in COMPLETE trigger if (COMPLETE_ONLY_ACTIONS.includes(type) && activeTrigger !== 'COMPLETE') { return true } // Contact/chat-specific actions not available in COMPLETE trigger if ( CONTACT_REQUIRED_ACTIONS.includes(type) && activeTrigger === 'COMPLETE' ) { return true } return false } const getDisabledTooltip = (type: string) => { if (type === 'SELF_MESSAGE' && activeTrigger !== 'COMPLETE') { return 'Only available in "On Complete" trigger (runs once after all broadcasts finish)' } if (type === 'EXPORT_REPORT' && activeTrigger !== 'COMPLETE') { return 'Only available in "On Complete" trigger (exports results when finished)' } if (type === 'SEND_STATS_SELF' && activeTrigger !== 'COMPLETE') { return 'Only available in "On Complete" trigger (sends stats summary)' } if (type === 'SEND_REPORT_GROUP' && activeTrigger !== 'COMPLETE') { return 'Only available in "On Complete" trigger (sends report to group)' } if ( CONTACT_REQUIRED_ACTIONS.includes(type) && activeTrigger === 'COMPLETE' ) { return 'Not available in "On Complete" - requires specific contact/chat context' } return '' } return ( <Modal opened={opened} onClose={onClose} withCloseButton w={700} p={0}> <Stack gap={0} h={500}> <Group p="md" style={{ borderBottom: '1px solid var(--mantine-color-default-border)', }} > <ThemeIcon variant="light" size="lg" color="emerald"> <Icon icon="tabler:bolt" fontSize={20} /> </ThemeIcon> <Text fw={600} size="lg"> Add Automation Action </Text> </Group> <ScrollArea style={{ flex: 1 }} bg="var(--mantine-color-body)" p={0}> <Stack p="md" gap="xl"> {ACTION_CATEGORIES.map((category) => ( <Stack key={category.title} gap="xs"> <Text size="xs" fw={700} c="dimmed" tt="uppercase"> {category.title} </Text> <SimpleGrid cols={{ base: 1, sm: 2 }} spacing="sm"> {category.items.map((item) => { const disabled = isActionDisabled(item.type) const tooltipLabel = getDisabledTooltip(item.type) // @ts-ignore const isPro = !!item.isPro // Check if locked visual should be shown (Pro item & Free license) const isLocked = isPro && license.isFree() const cardContent = ( <UnstyledButton key={item.type} onClick={() => !disabled && handleSelect( item.type as BroadcastAction['type'], isPro, ) } className="action-card-button" style={{ height: '100%', cursor: disabled ? 'not-allowed' : 'pointer', opacity: disabled ? 0.5 : 1, }} disabled={disabled} > <Card withBorder padding="sm" radius="md" className="action-category-card" style={ { height: '100%', backgroundColor: 'rgba(255,255,255,0.02)', '--hover-border-color': disabled ? 'transparent' : `var(--mantine-color-${item.color}-5)`, } as React.CSSProperties } > <Group align="flex-start" wrap="nowrap"> <ThemeIcon size="lg" radius="md" color={item.color} variant="light" > <Icon icon={item.icon} fontSize={20} /> </ThemeIcon> <Stack gap={2} style={{ flex: 1 }}> <Group justify="space-between" wrap="nowrap"> <Text size="sm" fw={600} c="white"> {item.label} </Text> {/* ++ ADDED: Pro Badge */} {isLocked && ( <Badge color="yellow" size="xs" variant="light" > Pro </Badge> )} </Group> <Text size="xs" c="dimmed" lh={1.3}> {item.description} </Text> </Stack> </Group> </Card> <style>{` .action-category-card { transition: border-color 0.15s ease, background-color 0.15s ease; } .action-card-button:not(:disabled):hover .action-category-card { border-color: var(--hover-border-color); background-color: rgba(255,255,255,0.05); } `}</style> </UnstyledButton> ) if (disabled && tooltipLabel) { return ( <Tooltip key={item.type} label={tooltipLabel} withArrow position="top" multiline w={250} > {cardContent} </Tooltip> ) } return cardContent })} </SimpleGrid> </Stack> ))} </Stack> </ScrollArea> </Stack> </Modal> ) } export default ModalAddAction \`\`\` # src/features/broadcast/components/Form/ModalSourceTags.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import TagModel from '@/features/contacts/models/TagModel' import db from '@/libs/db' import { Icon } from '@iconify/react' import { Badge, Button, Card, Center, Checkbox, Group, Loader, ScrollArea, Stack, Text, TextInput, Title, } from '@mantine/core' import { useDebouncedValue } from '@mantine/hooks' import { useLiveQuery } from 'dexie-react-hooks' import React, { useEffect, useMemo, useState } from 'react' import { When } from 'react-if' interface Props { opened: boolean onClose: () => void onSubmit: (recipients: any[]) => void } const ModalSourceTags: React.FC<Props> = ({ opened, onClose, onSubmit }) => { const tags = useLiveQuery(() => db.tags.toArray(), []) const [selectedTagIds, setSelectedTagIds] = useState<number[]>([]) const [searchQuery, setSearchQuery] = useState('') const [debouncedSearchQuery] = useDebouncedValue(searchQuery, 300) const [loading, setLoading] = useState(false) const [contactCounts, setContactCounts] = useState<Record<number, number>>({}) // Fetch contact counts when tags are loaded useEffect(() => { const fetchCounts = async () => { if (!tags || tags.length === 0) return const tagIds = tags.map((t) => t.id!).filter(Boolean) const counts = await TagModel.getContactCountsForTags(tagIds) setContactCounts(counts) } if (opened && tags) { fetchCounts() } }, [tags, opened]) const filteredTags = useMemo(() => { if (!tags) return [] if (!debouncedSearchQuery) return tags const lowerCaseQuery = debouncedSearchQuery.toLowerCase() return tags.filter((tag) => tag.name.toLowerCase().includes(lowerCaseQuery)) }, [tags, debouncedSearchQuery]) const handleToggleTag = (tagId: number) => { setSelectedTagIds((prev) => prev.includes(tagId) ? prev.filter((id) => id !== tagId) : [...prev, tagId], ) } const handleSubmit = async () => { if (selectedTagIds.length === 0) return setLoading(true) try { const rawRecipients = await TagModel.getRecipientsByTagIds(selectedTagIds) // Clean the number format to remove @c.us or @g.us suffixes const recipients = rawRecipients.map((r) => ({ ...r, number: r.number.replace('@c.us', '').replace('@g.us', ''), })) onSubmit(recipients) handleClose() } catch (error) { console.error('Failed to fetch recipients by tags', error) } finally { setLoading(false) } } const handleClose = () => { setSelectedTagIds([]) setSearchQuery('') onClose() } const isLoadingData = tags === undefined return ( <Modal opened={opened} onClose={handleClose} withCloseButton w={500}> <Stack> <Center> <Title order={4}>Add Recipients from Tags</Title> </Center> <TextInput placeholder="Search tags..." leftSection={<Icon icon="tabler:search" fontSize={16} />} value={searchQuery} size="sm" onChange={(event) => setSearchQuery(event.currentTarget.value)} disabled={isLoadingData || (tags?.length || 0) === 0} /> <When condition={isLoadingData}> <Center h={200}> <Loader /> <Text ml="md">Loading tags...</Text> </Center> </When> <When condition={!isLoadingData && (tags?.length || 0) === 0}> <Center h={200}> <Stack align="center" gap="xs"> <Icon icon="tabler:tag-off" fontSize={48} opacity={0.5} /> <Text c="dimmed">No tags found in database</Text> </Stack> </Center> </When> <When condition={!isLoadingData && (tags?.length || 0) > 0}> <ScrollArea h={300}> {filteredTags.length > 0 ? ( <Stack gap="xs"> {filteredTags.map((tag) => ( <Card key={tag.id} withBorder p="xs" radius="sm" shadow="none" style={{ cursor: 'pointer' }} onClick={() => handleToggleTag(tag.id!)} > <Group wrap="nowrap" justify="space-between"> <Group gap="sm"> <Checkbox checked={selectedTagIds.includes(tag.id!)} readOnly aria-label={`Select tag ${tag.name}`} style={{ pointerEvents: 'none' }} /> <Badge color={tag.color} variant="light" style={{ textTransform: 'none' }} > {tag.name} </Badge> <Text size="xs" c="dimmed"> {contactCounts[tag.id!] ?? 0} contacts </Text> </Group> </Group> </Card> ))} </Stack> ) : ( <Center h={100}> <Text c="dimmed">No tags match your search.</Text> </Center> )} </ScrollArea> </When> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={handleClose} disabled={loading}> Cancel </Button> <Button onClick={handleSubmit} disabled={selectedTagIds.length === 0} loading={loading} > Add Selected </Button> </Group> </Stack> </Modal> ) } export default ModalSourceTags \`\`\` # src/features/broadcast/components/Form/RecipientManager.tsx \`\`\`tsx // src/features/broadcast/components/Form/RecipientManager.tsx import useLicense from '@/hooks/useLicense' import { Icon } from '@iconify/react' import { Button, Group, Stack, Text, Tooltip } from '@mantine/core' import React from 'react' interface Props { recipientCount: number error?: string | any onClear: () => void onManage: () => void onLoad: () => void } /** * @component RecipientManager * @description A sub-component for ModalCreateBroadcast that handles the UI for managing recipients. * It displays the recipient count and provides buttons to clear or manage the recipient list. */ const RecipientManager: React.FC<Props> = ({ recipientCount, error, onClear, onManage, onLoad, }) => { const license = useLicense() // The Manage button is defined once to avoid code duplication. const manageButton = ( <Button variant="outline" size="xs" onClick={onManage} leftSection={<Icon icon="tabler:users-plus" fontSize={16} />} > Manage </Button> ) return ( <Stack gap="xs"> <Group justify="space-between"> <Text fw={500}>Recipients ({recipientCount})</Text> <Group> <Button variant="outline" color="red" size="xs" onClick={onClear} disabled={recipientCount == 0} leftSection={<Icon icon="tabler:x" fontSize={16} />} > Clear </Button> <Button variant="outline" size="xs" onClick={onLoad} leftSection={<Icon icon="tabler:database-import" fontSize={16} />} > Load </Button> {/* MODIFIED: Removed Tooltip restriction for free users. Now unlimited for all. */} {manageButton} </Group> </Group> {error && ( <Text c="red" size="sm"> {error} </Text> )} </Stack> ) } export default RecipientManager \`\`\` # src/features/broadcast/components/Form/RecipientSelector.tsx \`\`\`tsx import AlertBanner from '@/components/AlertBanner' import ModalConfirmLoad from '@/features/broadcast/components/Modal/ModalConfirmLoad' import ModalEditRecipient from '@/features/broadcast/components/Modal/ModalEditRecipient' import ModalLoadRecipientList from '@/features/broadcast/components/Modal/ModalLoadRecipientList' import ModalSaveRecipientList from '@/features/broadcast/components/Modal/ModalSaveRecipientList' import ModalSourceExcel from '@/features/broadcast/components/Modal/ModalSourceExcel' import ModalSourceGroups from '@/features/broadcast/components/Modal/ModalSourceGroups' import ModalSourceManual from '@/features/broadcast/components/Modal/ModalSourceManual' import ModalSourcePhoneContacts from '@/features/broadcast/components/Modal/ModalSourcePhoneContacts' // ++ ADDED: Import Smart Segment Modal import ModalSourceSmartSegment from '@/features/broadcast/components/Modal/ModalSourceSmartSegment' import type { useRecipientManager } from '@/features/broadcast/hooks/useRecipientManager' import useLicense from '@/hooks/useLicense' import toast from '@/utils/toast' import { showModalUpgrade } from '@/utils/util' import { Icon } from '@iconify/react' import { ActionIcon, Badge, Button, Group, Stack, Text, TextInput, Tooltip, } from '@mantine/core' import { DataTable } from 'mantine-datatable' import React from 'react' import ModalSourceCommunities from '../Modal/ModalSourceCommunities' import ModalSourceContacts from '../Modal/ModalSourceContacts' import ModalSourceTags from './ModalSourceTags' interface Props { manager: ReturnType<typeof useRecipientManager> } const RecipientSelector: React.FC<Props> = ({ manager }) => { const { recipients, paginatedRecipients, filteredAndSortedRecipients, selectedRecords, setSelectedRecords, sortStatus, setSortStatus, page, setPage, modals, handleAddRecipients, handleDeleteRecipient, handleBulkDelete, handleSaveList, handleLoadList, confirmLoadList, handleClearAll, editingCell, setEditingCell, editValue, setEditValue, handleSaveCellEdit, isSaving, listToLoad, } = manager const PAGE_SIZE = 10 const columns: any[] = [ { accessor: 'number', title: 'Number', sortable: true, ellipsis: true, render: (recipient: any) => { const isEditing = editingCell?.recordId === recipient.number && editingCell?.columnId === 'number' return isEditing ? ( <Group gap="xs" wrap="nowrap"> <TextInput value={editValue} onChange={(e) => setEditValue(e.currentTarget.value)} onBlur={handleSaveCellEdit} onKeyDown={(e) => { if (e.key === 'Enter') { e.preventDefault() handleSaveCellEdit() } else if (e.key === 'Escape') { setEditingCell(null) } }} autoFocus size="xs" style={{ flexGrow: 1 }} /> <Tooltip label="Save" withArrow position="top"> <ActionIcon variant="subtle" color="teal" onClick={handleSaveCellEdit} > <Icon icon="tabler:check" /> </ActionIcon> </Tooltip> </Group> ) : ( <Tooltip label="Click to edit" withArrow position="top"> <Text onClick={() => { setEditingCell({ recordId: recipient.number, columnId: 'number', }) setEditValue(recipient.number) }} style={{ cursor: 'pointer', width: '100%', padding: '6px 0', height: '100%', }} truncate size="xs" > {recipient.number} </Text> </Tooltip> ) }, }, { accessor: 'name', title: 'Name', sortable: true, render: (recipient: any) => { const isEditing = editingCell?.recordId === recipient.number && editingCell?.columnId === 'name' return isEditing ? ( <Group gap="xs" wrap="nowrap"> <TextInput value={editValue} onChange={(e) => setEditValue(e.currentTarget.value)} onBlur={handleSaveCellEdit} onKeyDown={(e) => { if (e.key === 'Enter') { e.preventDefault() handleSaveCellEdit() } else if (e.key === 'Escape') { setEditingCell(null) } }} autoFocus size="xs" style={{ flexGrow: 1 }} /> <Tooltip label="Save" withArrow position="top"> <ActionIcon variant="subtle" color="teal" onClick={handleSaveCellEdit} > <Icon icon="tabler:check" /> </ActionIcon> </Tooltip> </Group> ) : ( <Tooltip label="Click to edit" withArrow position="top"> <Text onClick={() => { setEditingCell({ recordId: recipient.number, columnId: 'name', }) setEditValue(recipient.name) }} style={{ cursor: 'pointer', width: '100%', padding: '6px 0', height: '100%', }} truncate size="xs" > {recipient.name} </Text> </Tooltip> ) }, }, { accessor: 'actions', title: '', textAlign: 'right', width: 50, render: (recipient: any) => ( <Group gap={4} justify="right" wrap="nowrap"> <Tooltip label="Delete"> <ActionIcon size="xs" variant="subtle" color="red" onClick={() => handleDeleteRecipient(recipient.number)} > <Icon icon="tabler:trash" /> </ActionIcon> </Tooltip> </Group> ), }, ] return ( <Stack gap="xs" h="100%"> {/* Toolbar */} <Group justify="space-between"> <Text fw={500} size="sm"> Recipients ({recipients.length}) </Text> <Group gap={4}> {selectedRecords.length > 0 ? ( <Button size="compact-xs" variant="light" color="red" leftSection={<Icon icon="tabler:trash" fontSize={14} />} onClick={handleBulkDelete} > Delete ({selectedRecords.length}) </Button> ) : ( <> <Tooltip label="Save List"> <ActionIcon variant="default" size="md" onClick={modals.saveList.open} disabled={recipients.length === 0} > <Icon icon="tabler:device-floppy" fontSize={18} /> </ActionIcon> </Tooltip> <Tooltip label="Clear All"> <ActionIcon variant="default" size="md" color="red" onClick={handleClearAll} disabled={recipients.length === 0} > <Icon icon="tabler:trash" fontSize={18} /> </ActionIcon> </Tooltip> </> )} </Group> </Group> {/* Action Buttons Grid */} <Group gap={6}> <Tooltip label="Type or paste phone numbers manually, one per line" withArrow position="top" > <Button size="xs" variant="default" leftSection={<Icon icon="tabler:plus" />} onClick={modals.manual.open} > Manual </Button> </Tooltip> <Tooltip label="Select from contacts saved in WhatsApp" withArrow position="top" > <Button size="xs" variant="default" leftSection={<Icon icon="tabler:address-book" />} onClick={modals.myContacts.open} > Phone </Button> </Tooltip> <Tooltip label="Select from CRM database (contacts saved in the app)" withArrow position="top" > <Button size="xs" variant="default" leftSection={<Icon icon="tabler:database" />} onClick={modals.crmContacts.open} > CRM </Button> </Tooltip> <Tooltip label="Select contacts by tag (e.g. VIP, Customer, etc.)" withArrow position="top" > <Button size="xs" variant="default" leftSection={<Icon icon="tabler:tag" />} onClick={modals.tags.open} > Tag </Button> </Tooltip> <Tooltip label="Powerful smart segment to filter contacts with dynamic conditions" withArrow position="top" > <Button size="xs" variant="default" leftSection={<Icon icon="tabler:filter" />} onClick={modals.smartSegment.open} > Segment </Button> </Tooltip> <Tooltip label="Load a previously saved recipient list" withArrow position="top" > <Button size="xs" variant="default" leftSection={<Icon icon="tabler:list" />} onClick={modals.loadList.open} > List </Button> </Tooltip> <Tooltip label="Get all members from selected WhatsApp groups" withArrow position="top" > <Button size="xs" variant="default" leftSection={<Icon icon="tabler:users-group" />} onClick={modals.groups.open} > Group </Button> </Tooltip> <Tooltip label="Get all members from selected WhatsApp communities" withArrow position="top" > <Button size="xs" variant="default" leftSection={<Icon icon="tabler:users" />} onClick={modals.communities.open} > Comm </Button> </Tooltip> <Tooltip label="Import recipient list from Excel (.xlsx) or CSV file" withArrow position="top" > <Button size="xs" variant="default" leftSection={<Icon icon="tabler:file-spreadsheet" />} onClick={modals.excel.open} > Excel </Button> </Tooltip> </Group> <AlertBanner message="Limited to 5 recipients in the free version. Go unlimited" /> {/* Table */} <DataTable height="100%" //@ts-ignore records={paginatedRecipients} columns={columns} totalRecords={filteredAndSortedRecipients.length} recordsPerPage={PAGE_SIZE} page={page} onPageChange={(p) => setPage(p)} minHeight={320} noRecordsText="Add recipients to start" withTableBorder striped //@ts-ignore selectedRecords={selectedRecords} //@ts-ignore onSelectedRecordsChange={setSelectedRecords} idAccessor="number" sortStatus={sortStatus} onSortStatusChange={setSortStatus} fz="xs" /> {/* Sub Modals */} <ModalSourceManual opened={modals.manual.opened} onClose={modals.manual.close} onSubmit={handleAddRecipients} /> <ModalSourcePhoneContacts opened={modals.myContacts.opened} onClose={modals.myContacts.close} onSubmit={handleAddRecipients} /> <ModalSourceExcel opened={modals.excel.opened} onClose={modals.excel.close} onSubmit={handleAddRecipients} /> <ModalSourceTags opened={modals.tags.opened} onClose={modals.tags.close} onSubmit={handleAddRecipients} /> <ModalSourceGroups opened={modals.groups.opened} onClose={modals.groups.close} onSubmit={handleAddRecipients} /> <ModalSourceCommunities opened={modals.communities.opened} onClose={modals.communities.close} onSubmit={handleAddRecipients} /> <ModalSourceContacts opened={modals.crmContacts.opened} onClose={modals.crmContacts.close} onSubmit={handleAddRecipients} /> {/* ++ ADDED: Smart Segment Modal Component */} <ModalSourceSmartSegment opened={modals.smartSegment.opened} onClose={modals.smartSegment.close} onSubmit={handleAddRecipients} /> <ModalSaveRecipientList opened={modals.saveList.opened} onClose={modals.saveList.close} onSave={handleSaveList} isSaving={isSaving} /> <ModalLoadRecipientList opened={modals.loadList.opened} onClose={modals.loadList.close} onLoad={handleLoadList} /> <ModalConfirmLoad opened={modals.confirmLoad.opened} onClose={modals.confirmLoad.close} onConfirm={confirmLoadList} listName={listToLoad?.name || ''} recipientCount={listToLoad?.recipients?.length || 0} /> <ModalEditRecipient opened={modals.edit.opened} onClose={modals.edit.close} onSubmit={(original, data) => { modals.edit.close() }} recipientData={null} /> </Stack> ) } export default RecipientSelector \`\`\` # src/features/broadcast/components/Form/SmartPauseSettings.tsx \`\`\`tsx import useLicense from '@/hooks/useLicense' import { Icon } from '@iconify/react' import { Badge, Group, Stack, Switch, Text, Tooltip } from '@mantine/core' import { TimeInput } from '@mantine/dates' import type { UseFormReturnType } from '@mantine/form' import React from 'react' import { When } from 'react-if' interface Props { form: UseFormReturnType<any> } /** * @component SmartPauseSettings * @description A sub-component for managing Smart Pause settings, allowing users * to define working hours during which broadcasts can be sent. */ const SmartPauseSettings: React.FC<Props> = ({ form }) => { const license = useLicense() return ( <Stack onClick={() => {}}> <Switch style={{ cursor: 'pointer' }} label={ <Group gap={4} wrap="nowrap"> <Text fw={500}>Smart Pause</Text> {license.isFree() && ( <Badge color="yellow" variant="light" size="sm"> Pro </Badge> )} <Tooltip label="Automatically pause the broadcast outside of specified hours and resume the next day. This helps simulate human behavior and avoid sending messages at inappropriate times." position="top-start" multiline w={300} withArrow > <Icon icon="tabler:info-circle" style={{ display: 'block' }} /> </Tooltip> </Group> } {...form.getInputProps('smartPause.enabled', { type: 'checkbox' })} /> <When condition={form.values.smartPause.enabled}> <Stack gap={4}> <Group grow align="flex-start"> <TimeInput label="Send between" description="Start time" {...form.getInputProps('smartPause.start')} /> <TimeInput label="And" description="End time" {...form.getInputProps('smartPause.end')} /> </Group> {form.errors['smartPause'] && ( <Text c="red" size="xs"> {' '} {form.errors['smartPause']}{' '} </Text> )} </Stack> </When> </Stack> ) } export default SmartPauseSettings \`\`\` # src/features/broadcast/components/Modal/ModalConfirmLoad.tsx \`\`\`tsx // src/features/broadcast/components/Modal/ModalConfirmLoad.tsx import Modal from '@/components/Modal/Modal' import { Icon } from '@iconify/react' import { Button, Center, Group, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' interface Props { opened: boolean onClose: () => void onConfirm: (mode: 'merge' | 'replace') => void listName: string recipientCount: number } /** * @component ModalConfirmLoad * @description A modal asking the user whether to merge or replace the current recipient list * with a newly loaded one. */ const ModalConfirmLoad: React.FC<Props> = ({ opened, onClose, onConfirm, listName, recipientCount, }) => { return ( <Modal opened={opened} onClose={onClose} withCloseButton w={500}> <Stack p="md"> <Center> <Stack align="center" gap="xs"> <ThemeIcon color="blue" size={50} radius="xl"> <Icon icon="tabler:database-import" fontSize={28} /> </ThemeIcon> <Title order={4}>Load Recipient List</Title> <Text c="dimmed" size="sm" ta="center"> You are about to load <b>{recipientCount} recipients</b> from the list "<b>{listName}</b>". </Text> <Text size="sm" ta="center" mt="sm"> How would you like to add them? </Text> </Stack> </Center> <Group justify="center" mt="lg" grow> <Button variant="outline" leftSection={<Icon icon="tabler:plus" />} onClick={() => onConfirm('merge')} > Merge </Button> <Button color="orange" leftSection={<Icon icon="tabler:replace" />} onClick={() => onConfirm('replace')} > Replace </Button> </Group> <Group justify="center" mt="sm"> <Button variant="default" onClick={onClose}> Cancel </Button> </Group> </Stack> </Modal> ) } export default ModalConfirmLoad \`\`\` # src/features/broadcast/components/Modal/ModalCreateBroadcast.tsx \`\`\`tsx import InputSendLater from '@/components/Input/InputSendLater' import InputMessage from '@/components/Input/Message/InputMessage' import Modal from '@/components/Modal/Modal' import { useRecipientManager } from '@/features/broadcast/hooks/useRecipientManager' import useLicense from '@/hooks/useLicense' // ++ ADDED import type { Broadcast } from '@/libs/db' import toast from '@/utils/toast' import { showModalUpgrade } from '@/utils/util' // ++ ADDED import { Icon } from '@iconify/react' import { Badge, // ++ ADDED Button, Group, NumberInput, ScrollArea, SimpleGrid, Stack, Stepper, Switch, Text, TextInput, Tooltip, } from '@mantine/core' import React, { useEffect, useState } from 'react' import { useBroadcastForm } from '../../hooks/useBroadcastForm' import BatchingSettings from '../Form/BatchingSettings' import BroadcastActions from '../Form/BroadcastActions' import BroadcastActionsSetup from '../Form/BroadcastActionsSetup' import RecipientSelector from '../Form/RecipientSelector' interface Props { opened: boolean onClose: () => void onSuccess: () => void cloneData?: { broadcast: Broadcast recipients: any[] } | null } const ModalCreateBroadcast: React.FC<Props> = ({ opened, onClose, onSuccess, cloneData = null, }) => { const [activeStep, setActiveStep] = useState(0) const license = useLicense() // ++ ADDED // 1. Initialize Form Hook const { form, inputMessageForm, handleClose: closeForm, handleSendBroadcast, } = useBroadcastForm({ cloneData: cloneData?.broadcast || null, onSuccess, onClose, }) // 2. Initialize Recipient Manager Hook const recipientManager = useRecipientManager({ initialRecipients: form.values.numbers, }) // 3. Pre-populate recipients when cloneData is provided useEffect(() => { if (cloneData?.recipients && cloneData.recipients.length > 0 && opened) { recipientManager.handleClearAll() const recipientsToAdd = cloneData.recipients.map((r) => ({ number: r.number, name: r.name, })) recipientManager.handleAddRecipients(recipientsToAdd) } }, [cloneData, opened]) // 4. Handle Modal Close (Cleanup) const handleModalClose = () => { recipientManager.handleClearAll() form.reset() inputMessageForm.reset() setActiveStep(0) closeForm() } // 5. Handle Send Action const onSendClick = async () => { const result = await handleSendBroadcast(recipientManager.recipients) if (result === 'SUCCESS') { recipientManager.handleClearAll() form.reset() inputMessageForm.reset() setActiveStep(0) closeForm() } } const nextStep = () => { if (activeStep === 0) { if (recipientManager.recipients.length === 0) { toast.error('Please select at least one recipient.') return } } setActiveStep((current) => (current < 2 ? current + 1 : current)) } const prevStep = () => setActiveStep((current) => (current > 0 ? current - 1 : current)) return ( <Modal opened={opened} onClose={handleModalClose} w={870} withCloseButton> <Stepper mt={'sm'} size="sm" active={activeStep} onStepClick={setActiveStep} mb="lg" > <Stepper.Step label="Select Audience" description="Choose recipients" icon={<Icon icon="tabler:users" fontSize={20} />} /> <Stepper.Step label="Compose" description="Write message" icon={<Icon icon="tabler:message" fontSize={20} />} /> <Stepper.Step label="Settings & Review" description="Configure & send" icon={<Icon icon="tabler:settings" fontSize={20} />} /> </Stepper> <ScrollArea h={450} type="auto" offsetScrollbars> <Stack gap="lg" px="sm"> {/* STEP 1: AUDIENCE */} <div style={{ display: activeStep === 0 ? 'block' : 'none' }}> <RecipientSelector manager={recipientManager} /> </div> {/* STEP 2: COMPOSE */} <div style={{ display: activeStep === 1 ? 'block' : 'none' }}> <Stack gap="md"> <TextInput size="sm" label="Broadcast Name" placeholder="e.g., Weekly Newsletter" {...form.getInputProps('name')} /> <InputMessage form={inputMessageForm} withTemplateSelector={true} /> </Stack> </div> {/* STEP 3: SETTINGS */} <div style={{ display: activeStep === 2 ? 'block' : 'none' }}> <Stack gap="md"> {/* Delay Settings */} <Group grow align="flex-start"> <NumberInput size="sm" label={ <Group gap={4} wrap="nowrap"> <Text size="sm" fw={500}> Min Delay (s) </Text> <Tooltip label="Wait at least this many seconds between messages." position="top-start" withArrow > <Icon icon="tabler:info-circle" /> </Tooltip> </Group> } min={5} {...form.getInputProps('delayMin')} /> <NumberInput size="sm" label={ <Group gap={4} wrap="nowrap"> <Text size="sm" fw={500}> Max Delay (s) </Text> <Tooltip label="Wait at most this many seconds. Random delay helps avoid bans." position="top-start" withArrow > <Icon icon="tabler:info-circle" /> </Tooltip> </Group> } min={5} {...form.getInputProps('delayMax')} /> </Group> {/* Grid: Typing, Batching, Valid Number, Send Later */} <SimpleGrid cols={2} spacing="md" verticalSpacing="lg"> <Switch label={ <Group gap={4} wrap="nowrap"> <Text fw={500}>Typing effect</Text> <Tooltip label='Show "Typing..." status to the recipient.' position="top-start" withArrow > <Icon icon="tabler:info-circle" style={{ display: 'block' }} /> </Tooltip> </Group> } {...form.getInputProps('isTyping', { type: 'checkbox' })} /> <BatchingSettings form={form} /> {/* Validate Number Switch - MODIFIED FOR PRO CHECK */} <Switch label={ <Group gap={4} wrap="nowrap"> <Text fw={500}>Only Valid Numbers</Text> {license.isFree() && ( <Badge color="yellow" variant="light" size="sm"> Pro </Badge> )} <Tooltip label="Check if numbers exist on WhatsApp before sending, helps avoid bans." position="top-start" withArrow > <Icon icon="tabler:info-circle" style={{ display: 'block' }} /> </Tooltip> </Group> } checked={ license.isFree() ? false : form.values.validateNumber } onChange={(event) => { if (license.isFree()) { toast.warning( 'Only for Pro users, Please Upgrade', 'Warning', ) showModalUpgrade() return } form.setFieldValue( 'validateNumber', event.currentTarget.checked, ) }} /> {/* Send Later moved inside grid to align with Validate Number */} <InputSendLater form={form} /> </SimpleGrid> {/* Automation Section */} <BroadcastActionsSetup form={form} /> </Stack> </div> </Stack> </ScrollArea> <Group justify="space-between" mt="sm"> {activeStep === 0 ? ( <Button variant="default" onClick={handleModalClose}> Cancel </Button> ) : ( <Button variant="default" onClick={prevStep}> Back </Button> )} {activeStep === 2 ? ( <BroadcastActions onSend={onSendClick} isScheduled={form.values.scheduler.enabled} scheduledAt={form.values.scheduler.scheduledAt} /> ) : ( <Button onClick={nextStep}>Next</Button> )} </Group> </Modal> ) } export default ModalCreateBroadcast \`\`\` # src/features/broadcast/components/Modal/ModalCreateUpdateTemplate.tsx \`\`\`tsx // src/components/Modal/ModalCreateUpdateTemplate.tsx import InputMessage from '@/components/Input/Message/InputMessage' import useInputMessage from '@/components/Input/Message/useInputMessage' import Modal from '@/components/Modal/Modal' import { Media, Message } from '@/constants' import db, { type BroadcastTemplate } from '@/libs/db' import { formHasErrors, isTypeMessageMedia } from '@/utils/util' import { Button, Center, Group, Stack, TextInput, Title } from '@mantine/core' import { useForm } from '@mantine/form' import _ from 'lodash' import React, { useEffect } from 'react' interface Props { opened: boolean onClose: () => void data?: Partial<BroadcastTemplate> | null initialData?: any | null } const ModalCreateUpdateTemplate: React.FC<Props> = ({ opened, onClose, data = null, initialData = null, }: Props) => { const { form: inputMessageForm, getMessage, insertBroadcastFile, } = useInputMessage() const form = useForm({ initialValues: { name: '', }, validate: { name: (value) => (_.isEmpty(value) ? 'Required' : null), }, }) useEffect(() => { if (opened) { if (initialData) { inputMessageForm.setValues(initialData) form.reset() } else if (data) { form.setValues({ name: data.name }) const messageData = data.message as any const type = data.type inputMessageForm.reset() inputMessageForm.setFieldValue('type', type) switch (type) { case Message.TEXT: inputMessageForm.setFieldValue( 'inputText', typeof messageData === 'string' ? messageData : '', ) break case Message.IMAGE: inputMessageForm.setFieldValue( 'inputImage.caption', messageData?.caption || '', ) inputMessageForm.setFieldValue('inputImage.file', null) break case Message.VIDEO: inputMessageForm.setFieldValue( 'inputVideo.caption', messageData?.caption || '', ) inputMessageForm.setFieldValue('inputVideo.file', null) break case Message.AUDIO: inputMessageForm.setFieldValue('inputAudio.file', null) break case Message.FILE: inputMessageForm.setFieldValue( 'inputFile.caption', messageData as string, ) inputMessageForm.setFieldValue('inputFile.file', null) break case Message.LOCATION: inputMessageForm.setFieldValue('inputLocation', messageData) break case Message.POLL: inputMessageForm.setFieldValue('inputPoll', messageData) break default: if (typeof messageData === 'string' && !isTypeMessageMedia(type)) { inputMessageForm.setFieldValue('inputText', messageData) } break } } else { form.reset() inputMessageForm.reset() } } // eslint-disable-next-line react-hooks/exhaustive-deps }, [data, initialData, opened]) const handleCreate = async () => { const { type } = inputMessageForm.values const { name } = form.values const templateId = await db.broadcastTemplates.add({ name, type, message: getMessage(), }) if (isTypeMessageMedia(type)) { if (typeof templateId === 'number') { await insertBroadcastFile(templateId, Media.BROADCAST_TEMPLATE) } else { console.error('Failed to get templateId as number for media upload') } } } const handleUpdate = async () => { if (!data?.id) return const { type } = inputMessageForm.values const { name } = form.values const messagePayload = getMessage() await db.broadcastTemplates.update(data.id, { name, type, message: messagePayload, }) const newFileIsSelected = (type === Message.IMAGE && inputMessageForm.values.inputImage.file) || (type === Message.VIDEO && inputMessageForm.values.inputVideo.file) || (type === Message.AUDIO && inputMessageForm.values.inputAudio.file) || (type === Message.FILE && inputMessageForm.values.inputFile.file) if (isTypeMessageMedia(type)) { if (newFileIsSelected) { await db.media .where({ parentId: data.id, type: Media.BROADCAST_TEMPLATE }) .delete() await insertBroadcastFile(data.id, Media.BROADCAST_TEMPLATE) } } else if (isTypeMessageMedia(data.type) && !isTypeMessageMedia(type)) { await db.media .where({ parentId: data.id, type: Media.BROADCAST_TEMPLATE }) .delete() } } const handleSubmit = async () => { if (formHasErrors(form, inputMessageForm)) return if (data && data.id !== undefined) { await handleUpdate() } else { await handleCreate() } onClose() } const handleClose = () => { onClose() } return ( <Modal opened={opened} onClose={handleClose} w={750} withCloseButton> <Stack justify="space-between"> <Stack> <Center> <Title order={3}>{data?.id ? 'Edit' : 'Create'} Template</Title> </Center> <TextInput label="Name" required {...form.getInputProps('name')} /> <InputMessage form={inputMessageForm} /> </Stack> <Group align="end" justify="end"> <Button onClick={handleSubmit}>Submit</Button> </Group> </Stack> </Modal> ) } export default ModalCreateUpdateTemplate \`\`\` # src/features/broadcast/components/Modal/ModalDetailHistory.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import { Status } from '@/constants' import type { Broadcast, BroadcastContact } from '@/libs/db' import db from '@/libs/db' import { Icon } from '@iconify/react' import { Card, Center, Group, SimpleGrid, Stack, Text, ThemeIcon, } from '@mantine/core' import dayjs from 'dayjs' import { useLiveQuery } from 'dexie-react-hooks' import { DataTable } from 'mantine-datatable' import React, { useEffect, useMemo, useState } from 'react' import MessageStatus from '../Datatable/MessageStatus' const PAGE_SIZE = 15 interface Props { opened: boolean onClose: () => void data?: Broadcast | null } const ModalDetailHistory: React.FC<Props> = ({ opened, onClose, data = null, }) => { // Fetch contacts specific to this broadcast const contacts = useLiveQuery(async () => { if (!data?.id) return [] return await db.broadcastContacts .where({ broadcastId: data.id }) .toArray() }, [data]) || [] const [page, setPage] = useState(1) const [records, setRecords] = useState<BroadcastContact[]>([]) // Client-side pagination useEffect(() => { const from = (page - 1) * PAGE_SIZE const to = from + PAGE_SIZE setRecords(contacts.slice(from, to)) }, [page, contacts]) const { summaryData, scheduledAt } = useMemo(() => { if (!contacts || contacts.length === 0) { return { summaryData: [], scheduledAt: null } } const scheduledAt = contacts[0]?.scheduledAt || null const stats = { success: contacts.filter((c) => c.status === Status.SUCCESS).length, failed: contacts.filter((c) => c.status === Status.FAILED).length, pending: contacts.filter((c) => c.status === Status.PENDING).length, running: contacts.filter((c) => c.status === Status.RUNNING).length, scheduled: contacts.filter((c) => c.status === Status.SCHEDULER).length, cancelled: contacts.filter((c) => c.status === Status.CANCELLED).length, } const summaryItems = [ { title: 'Success', value: stats.success, color: 'teal', icon: 'tabler:circle-check', }, { title: 'Failed', value: stats.failed, color: 'red', icon: 'tabler:circle-x', }, { title: 'Pending', value: stats.pending, color: 'yellow', icon: 'tabler:clock', }, { title: 'Running', value: stats.running, color: 'orange', icon: 'tabler:player-play', }, { title: 'Scheduled', value: stats.scheduled, color: 'blue', icon: 'tabler:calendar-event', }, { title: 'Cancelled', value: stats.cancelled, color: 'gray', icon: 'tabler:ban', }, ].filter((item) => item.value > 0) return { summaryData: summaryItems, scheduledAt } }, [contacts]) const renderSummaryCards = () => { return summaryData.map((item) => ( <Card withBorder radius="md" p="sm" key={item.title} shadow="none"> <Group wrap="nowrap"> <ThemeIcon color={item.color} variant="light" size={40} radius="md"> <Icon icon={item.icon} fontSize={24} /> </ThemeIcon> <div> <Text c="dimmed" size="xs" tt="uppercase" fw={700}> {item.title} </Text> <Text fw={700} size="xl"> {item.value} </Text> </div> </Group> </Card> )) } return ( <Modal opened={opened} onClose={onClose} w={850} withCloseButton> <Stack p="md"> {contacts && contacts.length > 0 && data ? ( <> <SimpleGrid cols={{ base: 2, sm: 3 }} spacing="lg"> {renderSummaryCards()} </SimpleGrid> {scheduledAt && ( <Card withBorder radius="md" mt="md" p="xs" shadow="none"> <Center> <Group> <Icon icon="tabler:calendar-time" color="var(--mantine-color-blue-7)" /> <Text size="sm" c="blue.7" fw={500}> Scheduled for:{' '} {dayjs(scheduledAt).format('DD MMMM YYYY, HH:mm')} </Text> </Group> </Center> </Card> )} {/* Removed the Button Group for Follow-up here */} <DataTable height={350} records={records} totalRecords={contacts.length} recordsPerPage={PAGE_SIZE} page={page} onPageChange={(p) => setPage(p)} noRecordsText="No recipient data available" striped highlightOnHover withTableBorder columns={[ { accessor: 'name', title: 'Name', render: (contact) => contact.name || '-', }, { accessor: 'number', title: 'Number', render: (contact) => contact.number.split('@')[0], }, { accessor: 'status', title: 'Status', render: (contact) => ( <MessageStatus status={contact.status} error={contact.error} /> ), }, { accessor: 'sentAt', title: 'Sent At', render: (contact) => contact.sendAt ? dayjs(contact.sendAt).format('DD/MM/YYYY HH:mm') : '-', }, ]} /> </> ) : ( <Center h={200}> <Stack align="center"> <Icon icon="tabler:database-off" fontSize={48} color="gray" /> <Text c="dimmed"> No recipient data found for this broadcast. </Text> </Stack> </Center> )} </Stack> </Modal> ) } export default ModalDetailHistory \`\`\` # src/features/broadcast/components/Modal/ModalDuplicateWarning.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import { Icon } from '@iconify/react' import { Button, Group, rem, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React from 'react' interface Props { opened: boolean onClose: () => void onConfirm: () => void } /** * @component ModalDuplicateWarning * @description A modal that warns users when they attempt to send a broadcast * with content identical to the previous one, encouraging message variation. */ const ModalDuplicateWarning: React.FC<Props> = ({ opened, onClose, onConfirm, }) => { return ( <Modal opened={opened} onClose={onClose} w={500} p="xl" withCloseButton> <Stack gap="lg" align="center"> <ThemeIcon variant="light" color="orange" size={rem(60)} radius="xl"> <Icon icon="tabler:alert-triangle" fontSize={rem(32)} /> </ThemeIcon> <Title order={3} ta="center"> Potential Duplicate Content </Title> <Text size="sm" ta="center"> This message appears to be identical to your last broadcast. We strongly recommend using Spintax or varying the content to avoid being blocked. </Text> <Group justify="center" mt="md" w="100%"> <Button variant="outline" onClick={onClose}> Edit Message </Button> <Button onClick={onConfirm} color="orange"> Send Anyway </Button> </Group> </Stack> </Modal> ) } export default ModalDuplicateWarning \`\`\` # src/features/broadcast/components/Modal/ModalEditRecipient.tsx \`\`\`tsx // src/features/broadcast/components/Modal/ModalEditRecipient.tsx import Modal from '@/components/Modal/Modal' import { Button, Center, Group, Stack, TextInput, Title } from '@mantine/core' import { useForm } from '@mantine/form' import React, { useEffect } from 'react' interface Props { opened: boolean onClose: () => void // MODIFIED: The onSubmit signature is updated to pass the original number // along with the new data, allowing the parent to identify the correct record. onSubmit: ( originalNumber: string, updatedData: { name: string; number: string }, ) => void recipientData: { number: string; name: string } | null } const ModalEditRecipient: React.FC<Props> = ({ opened, onClose, onSubmit, recipientData, }) => { const form = useForm({ initialValues: { name: '', number: '', }, validate: { name: (value) => value.trim().length > 0 ? null : 'Name cannot be empty', // ADDED: Validation to ensure the number field is not empty. number: (value) => value.trim().length > 0 ? null : 'Number cannot be empty', }, }) useEffect(() => { if (recipientData) { form.setValues({ name: recipientData.name, number: recipientData.number, }) } else { form.reset() } // eslint-disable-next-line react-hooks/exhaustive-deps }, [recipientData, opened]) const handleSubmit = (values: { name: string; number: string }) => { // MODIFIED: Passes the original recipient's number to the submit handler // to ensure the correct record is updated, even if the number itself was changed. if (recipientData) { onSubmit(recipientData.number, values) } onClose() } return ( <Modal opened={opened} onClose={onClose} withCloseButton w={500}> <form onSubmit={form.onSubmit(handleSubmit)}> <Stack> <Center> <Title order={4}>Edit Recipient</Title> </Center> <TextInput label="Name" placeholder="Enter contact name" {...form.getInputProps('name')} data-autofocus /> {/* MODIFIED: The `readOnly` prop has been removed to allow editing of the recipient's number. */} <TextInput label="Number" placeholder="Enter number with country code" {...form.getInputProps('number')} /> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button type="submit">Save Changes</Button> </Group> </Stack> </form> </Modal> ) } export default ModalEditRecipient \`\`\` # src/features/broadcast/components/Modal/ModalEditSchedule.tsx \`\`\`tsx // src/features/broadcast/components/Modal/ModalEditSchedule.tsx import Modal from '@/components/Modal/Modal' import type { Broadcast } from '@/libs/db' import toast from '@/utils/toast' import { Button, Center, Group, Stack, Title } from '@mantine/core' import { DateTimePicker } from '@mantine/dates' import { useForm } from '@mantine/form' import { isFuture } from 'date-fns' import React, { useEffect } from 'react' interface Props { opened: boolean onClose: () => void onSubmit: (broadcastId: number, newScheduledAt: Date) => void broadcastData: Broadcast | null } /** * @component ModalEditSchedule * @description A modal for editing the scheduled time of a broadcast. * It ensures the new time is in the future and provides a clean interface. */ const ModalEditSchedule: React.FC<Props> = ({ opened, onClose, onSubmit, broadcastData, }) => { const form = useForm({ initialValues: { scheduledAt: null as Date | null, }, validate: { scheduledAt: (value) => { if (!value) { return 'A date and time are required.' } if (!isFuture(new Date(value))) { return 'Scheduled time must be in the future.' } return null }, }, }) useEffect(() => { // Populate form with existing scheduled time when the modal opens if (broadcastData && opened) { // @ts-ignore - scheduledAt is added dynamically in PageBroadcast if (broadcastData.scheduledAt) { // @ts-ignore form.setValues({ scheduledAt: new Date(broadcastData.scheduledAt) }) } } else if (!opened) { form.reset() } // eslint-disable-next-line react-hooks/exhaustive-deps }, [broadcastData, opened]) const handleSubmit = (values: { scheduledAt: Date | null }) => { if (!broadcastData || !values.scheduledAt) { toast.error('Invalid data provided.') return } onSubmit(broadcastData.id, values.scheduledAt) } return ( <Modal opened={opened} onClose={onClose} withCloseButton w={500} h={500}> <form onSubmit={form.onSubmit(handleSubmit)}> <Stack> <Center> <Title order={4}>Edit Broadcast Schedule</Title> </Center> <DateTimePicker label="New Scheduled Time" placeholder="Pick date and time" minDate={new Date()} required {...form.getInputProps('scheduledAt')} /> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button type="submit">Save Changes</Button> </Group> </Stack> </form> </Modal> ) } export default ModalEditSchedule \`\`\` # src/features/broadcast/components/Modal/ModalFirstBroadcastWarning.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import { Icon } from '@iconify/react' import { Button, Checkbox, Group, List, Stack, Text, ThemeIcon, Title, } from '@mantine/core' import React, { useState } from 'react' interface Props { opened: boolean onClose: () => void onConfirm: () => void } const ModalFirstBroadcastWarning: React.FC<Props> = ({ opened, onClose, onConfirm, }) => { const [acknowledged, setAcknowledged] = useState(false) const handleConfirm = () => { if (acknowledged) { onConfirm() } } return ( <Modal opened={opened} onClose={onClose} w={600} withCloseButton> <Stack p="md"> <Title order={3} ta="center"> Important: Please Read Before Broadcasting </Title> <Text c="dimmed" ta="center" size="sm" mb="md"> Broadcasting on WhatsApp carries a risk of account blocking if not done carefully. To protect your account, please follow these best practices. </Text> <Stack gap="lg"> <div> <Text fw={500}>Best Practices (Do's)</Text> <List spacing="xs" size="sm" center icon={ <ThemeIcon color="teal" size={20} radius="xl"> <Icon icon="tabler:check" fontSize={14} /> </ThemeIcon> } > <List.Item> <b>Warm-Up Your Account:</b> Start by sending to a small number of contacts if your account is new or rarely used. </List.Item> <List.Item> <b>Use Personalization:</b> Utilize Spintax {'{Hi|Hello}'} and variables like {'{name}'} to make each message unique. </List.Item> <List.Item> <b>Prioritize Known Contacts:</b> Sending to contacts who have saved your number is significantly safer. </List.Item> <List.Item> <b>Provide an Opt-Out:</b> Include a message like "Reply STOP to unsubscribe" to reduce spam reports. </List.Item> </List> </div> <div> <Text fw={500}>Things to Avoid (Don'ts)</Text> <List spacing="xs" size="sm" center icon={ <ThemeIcon color="red" size={20} radius="xl"> <Icon icon="tabler:x" fontSize={14} /> </ThemeIcon> } > <List.Item> <b>Don't Bulk-Send to Strangers:</b> This is the fastest way to get your account banned. </List.Item> <List.Item> <b>Don't Send Identical Messages:</b> Always use message variation. </List.Item> </List> </div> </Stack> <Checkbox mt="xl" checked={acknowledged} onChange={(event) => setAcknowledged(event.currentTarget.checked)} label="I understand the risks and will use this feature responsibly." /> <Group justify="flex-end" mt="xl"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button onClick={handleConfirm} disabled={!acknowledged}> Continue </Button> </Group> </Stack> </Modal> ) } export default ModalFirstBroadcastWarning \`\`\` # src/features/broadcast/components/Modal/ModalLoadRecipientList.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import useDbQuery from '@/hooks/useDbQuery' import db, { type BroadcastRecipient } from '@/libs/db' import confirm from '@/utils/confirm' // ++ ADDED import { Icon } from '@iconify/react' import { ActionIcon, Button, Center, Group, Stack, TextInput, Title, Tooltip, } from '@mantine/core' import dayjs from 'dayjs' import { DataTable } from 'mantine-datatable' import React from 'react' interface Props { opened: boolean onClose: () => void onLoad: (list: BroadcastRecipient) => void } const ModalLoadRecipientList: React.FC<Props> = ({ opened, onClose, onLoad, }) => { const dataQuery = useDbQuery<BroadcastRecipient>({ table: db.broadcastRecipients, searchField: 'name', initialSort: { field: 'createdAt', direction: 'desc' }, }) const handleDelete = async (list: BroadcastRecipient) => { // -- MODIFIED: Use custom confirm const isConfirmed = await confirm.danger( 'Delete List', `Are you sure you want to delete the list "${list.name}"?`, ) if (isConfirmed) { await dataQuery._delete(list.id) } } return ( <Modal opened={opened} onClose={onClose} w={750} withCloseButton> <Stack h={500} justify="space-between"> <Stack> <Center> <Title order={4}>Load a Saved Recipient List</Title> </Center> <Group justify="flex-end"> <TextInput placeholder="Search by list name..." value={dataQuery.search} onChange={(e) => dataQuery.setSearch(e.currentTarget.value)} /> </Group> <DataTable height={350} records={dataQuery.data} columns={[ { accessor: 'name', title: 'List Name' }, { accessor: 'count', title: 'Recipients', render: (list) => list.recipients.length, }, { accessor: 'createdAt', title: 'Date Saved', render: (list) => dayjs(list.createdAt).format('DD MMM YYYY, HH:mm'), }, { accessor: 'actions', title: 'Actions', textAlign: 'right', render: (list) => ( <Group gap={4} justify="right" wrap="nowrap"> <Tooltip label="Load this list"> <ActionIcon variant="subtle" color="blue" onClick={() => { onLoad(list) onClose() }} > <Icon icon="tabler:upload" /> </ActionIcon> </Tooltip> <Tooltip label="Delete this list"> <ActionIcon variant="subtle" color="red" onClick={() => handleDelete(list)} > <Icon icon="tabler:trash" /> </ActionIcon> </Tooltip> </Group> ), }, ]} totalRecords={dataQuery.totalRecords} recordsPerPage={dataQuery.pageSize} page={dataQuery.page} onPageChange={dataQuery.setPage} noRecordsText="No saved lists found." /> </Stack> <Group justify="flex-end"> <Button variant="default" onClick={onClose}> Close </Button> </Group> </Stack> </Modal> ) } export default ModalLoadRecipientList \`\`\` # src/features/broadcast/components/Modal/ModalManageSources.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import db from '@/libs/db' import confirm from '@/utils/confirm' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { ActionIcon, Button, Group, Stack, Text, TextInput, Tooltip, } from '@mantine/core' import { useDebouncedValue, useDisclosure } from '@mantine/hooks' import _ from 'lodash' import { DataTable, type DataTableSortStatus } from 'mantine-datatable' import React, { useEffect, useMemo, useState } from 'react' import ModalSourceTags from '../Form/ModalSourceTags' import ModalLoadRecipientList from './ModalLoadRecipientList' import ModalSaveRecipientList from './ModalSaveRecipientList' import ModalSourceExcel from './ModalSourceExcel' import ModalSourceGroups from './ModalSourceGroups' import ModalSourceManual from './ModalSourceManual' import ModalSourcePhoneContacts from './ModalSourcePhoneContacts' // ++ ADDED: Import Smart Segment Modal import ModalSourceSmartSegment from './ModalSourceSmartSegment' interface Props { opened: boolean onClose: () => void onSubmit: (recipients: any[]) => void initialRecipients: any[] } const PAGE_SIZE = 10 const ModalManageSources: React.FC<Props> = ({ opened, onClose, onSubmit, initialRecipients, }) => { // State management const [recipients, setRecipients] = useState<any[]>([]) const [selectedRecords, setSelectedRecords] = useState<any[]>([]) const [page, setPage] = useState(1) const [paginatedRecipients, setPaginatedRecipients] = useState<any[]>([]) const [searchQuery, setSearchQuery] = useState('') const [debouncedSearchQuery] = useDebouncedValue(searchQuery, 300) const [isSaving, setIsSaving] = useState(false) // Inline editing state const [editingCell, setEditingCell] = useState<{ recordId: string columnId: string } | null>(null) const [editValue, setEditValue] = useState('') const [sortStatus, setSortStatus] = useState<DataTableSortStatus>({ columnAccessor: 'name', direction: 'asc', }) // Modal Disclosures const [showExcelModal, excelModalHandlers] = useDisclosure(false) const [showGroupsModal, groupsModalHandlers] = useDisclosure(false) const [showSaveListModal, saveListModalHandlers] = useDisclosure(false) const [showLoadListModal, loadListModalHandlers] = useDisclosure(false) const [showManualModal, manualModalHandlers] = useDisclosure(false) const [showphoneContactsModal, phoneContactsModalHandlers] = useDisclosure(false) const [showTagsModal, tagsModalHandlers] = useDisclosure(false) // ++ ADDED: Smart Segment Modal Handler const [showSmartSegmentModal, smartSegmentModalHandlers] = useDisclosure(false) // Initialize data when modal opens useEffect(() => { if (opened) { setRecipients(_.cloneDeep(initialRecipients)) setSelectedRecords([]) setPage(1) setSearchQuery('') setSortStatus({ columnAccessor: 'name', direction: 'asc' }) } }, [opened, initialRecipients]) // Filter and Sort Logic const filteredAndSortedRecipients = useMemo(() => { let data = [...recipients] if (debouncedSearchQuery) { const lowerCaseQuery = debouncedSearchQuery.toLowerCase() data = data.filter( (r) => r.name?.toLowerCase().includes(lowerCaseQuery) || r.number?.toLowerCase().includes(lowerCaseQuery), ) } const { columnAccessor, direction } = sortStatus if (columnAccessor) { data = _.orderBy(data, [columnAccessor], [direction]) } return data }, [recipients, debouncedSearchQuery, sortStatus]) // Pagination Logic useEffect(() => { const from = (page - 1) * PAGE_SIZE const to = from + PAGE_SIZE setPaginatedRecipients(filteredAndSortedRecipients.slice(from, to)) }, [filteredAndSortedRecipients, page]) useEffect(() => { setPage(1) }, [searchQuery, sortStatus]) const handleAddRecipients = (newRecipients: any[]) => { const formattedNewRecipients = newRecipients.map((rec) => { if (typeof rec === 'string') { return { number: rec, name: 'N/A', source: 'Manual' } } return { number: rec.number || rec.phoneNumber, name: rec.name || rec.savedName || rec.publicName || 'N/A', source: rec.source || 'Unknown', } }) const initialCount = recipients.length const combined = [...recipients, ...formattedNewRecipients] const uniqueRecipients = _.uniqBy(combined, 'number') const finalCount = uniqueRecipients.length setRecipients(uniqueRecipients) const addedCount = finalCount - initialCount const duplicateCount = combined.length - finalCount if (addedCount > 0 && duplicateCount > 0) { toast.info(`${addedCount} added. ${duplicateCount} duplicates skipped.`) } else if (addedCount > 0) { toast.success(`${addedCount} recipient(s) added successfully.`) } else if (duplicateCount > 0) { toast.info(`No new recipients. ${duplicateCount} duplicates found.`) } else { toast.info('No new recipients were added.') } } const handleDeleteRecipient = (numberToDelete: string) => { setRecipients((current) => current.filter((r) => r.number !== numberToDelete), ) } const handleBulkDelete = () => { const numbersToDelete = new Set(selectedRecords.map((r) => r.number)) setRecipients((current) => current.filter((r) => !numbersToDelete.has(r.number)), ) setSelectedRecords([]) toast.success(`${numbersToDelete.size} recipient(s) deleted.`) } const handleSaveCellEdit = () => { if (!editingCell) return const { recordId, columnId } = editingCell const finalValue = editValue.trim() if (columnId === 'number') { if (finalValue === '') { toast.error('Number cannot be empty.') return } const isDuplicate = recipients.some( (r) => r.number === finalValue && r.number !== recordId, ) if (isDuplicate) { toast.error(`The number ${finalValue} already exists in the list.`) return } } setRecipients((currentRecipients) => currentRecipients.map((r) => { if (r.number === recordId) { const valueToSet = finalValue === '' && columnId === 'name' ? r.name : finalValue return { ...r, [columnId]: valueToSet } } return r }), ) setEditingCell(null) } const handleOpenSaveListModal = async () => { saveListModalHandlers.open() } const handleSaveList = async (name: string) => { if (recipients.length === 0) { toast.error('Cannot save an empty list.') return } setIsSaving(true) try { await db.broadcastRecipients.add({ name, // @ts-ignore recipients, createdAt: new Date(), }) toast.success(`List "${name}" saved successfully.`) saveListModalHandlers.close() } catch (error) { console.error('Failed to save list:', error) toast.error('Failed to save the list.') } finally { setIsSaving(false) } } const handleLoadList = (list: any) => { handleAddRecipients(list.recipients || list) } const handleClearAll = async () => { const isConfirmed = await confirm.danger( 'Clear All', 'Are you sure you want to remove all recipients from this list?', ) if (isConfirmed) { setRecipients([]) } } const handleConfirm = () => { onSubmit(recipients) onClose() } // Datatable Columns const columns: any[] = [ { accessor: 'number', title: 'Number', sortable: true, ellipsis: true, render: (recipient: any) => { const isEditing = editingCell?.recordId === recipient.number && editingCell?.columnId === 'number' return isEditing ? ( <Group gap="xs" wrap="nowrap"> <TextInput value={editValue} onChange={(e) => setEditValue(e.currentTarget.value)} onBlur={handleSaveCellEdit} onKeyDown={(e) => { if (e.key === 'Enter') { e.preventDefault() handleSaveCellEdit() } else if (e.key === 'Escape') { setEditingCell(null) } }} autoFocus size="xs" style={{ flexGrow: 1 }} /> <Tooltip label="Save" withArrow position="top"> <ActionIcon variant="subtle" color="teal" onClick={handleSaveCellEdit} > <Icon icon="tabler:check" /> </ActionIcon> </Tooltip> </Group> ) : ( <Tooltip label="Click to edit" withArrow position="top"> <Text onClick={() => { setEditingCell({ recordId: recipient.number, columnId: 'number', }) setEditValue(recipient.number) }} style={{ cursor: 'pointer', width: '100%', padding: '6px 0', height: '100%', }} truncate > {recipient.number} </Text> </Tooltip> ) }, }, { accessor: 'name', title: 'Name', sortable: true, render: (recipient: any) => { const isEditing = editingCell?.recordId === recipient.number && editingCell?.columnId === 'name' return isEditing ? ( <Group gap="xs" wrap="nowrap"> <TextInput value={editValue} onChange={(e) => setEditValue(e.currentTarget.value)} onBlur={handleSaveCellEdit} onKeyDown={(e) => { if (e.key === 'Enter') { e.preventDefault() handleSaveCellEdit() } else if (e.key === 'Escape') { setEditingCell(null) } }} autoFocus size="xs" style={{ flexGrow: 1 }} /> <Tooltip label="Save" withArrow position="top"> <ActionIcon variant="subtle" color="teal" onClick={handleSaveCellEdit} > <Icon icon="tabler:check" /> </ActionIcon> </Tooltip> </Group> ) : ( <Tooltip label="Click to edit" withArrow position="top"> <Text onClick={() => { setEditingCell({ recordId: recipient.number, columnId: 'name', }) setEditValue(recipient.name) }} style={{ cursor: 'pointer', width: '100%', padding: '6px 0', height: '100%', }} truncate > {recipient.name} </Text> </Tooltip> ) }, }, { accessor: 'actions', title: <Text>Actions</Text>, textAlign: 'right', width: '0%', render: (recipient: any) => ( <Group gap={4} justify="right" wrap="nowrap"> <Tooltip label="Delete"> <ActionIcon size="sm" variant="subtle" color="red" onClick={() => handleDeleteRecipient(recipient.number)} > <Icon icon="tabler:trash" /> </ActionIcon> </Tooltip> </Group> ), }, ] return ( <> <Modal opened={opened} onClose={onClose} w={850} withCloseButton> <Stack justify="space-between" h={'calc(80vh)'} p="sm"> <Stack> {/* Header / Actions */} <Group justify="space-between"> <Group> <Text fw={500}>Current Recipients ({recipients.length})</Text> {selectedRecords.length > 0 && ( <Button size="xs" variant="light" color="red" leftSection={<Icon icon="tabler:trash" fontSize={16} />} onClick={handleBulkDelete} > Delete Selected ({selectedRecords.length}) </Button> )} </Group> <Group> <Button.Group> <Tooltip label="Enter numbers manually (copy-paste)" withArrow > <Button size="xs" variant="default" leftSection={<Icon icon="tabler:plus" fontSize={16} />} onClick={manualModalHandlers.open} > Manual </Button> </Tooltip> <Tooltip label="Select from phone contacts" withArrow> <Button size="xs" variant="default" leftSection={ <Icon icon="tabler:address-book" fontSize={16} /> } onClick={phoneContactsModalHandlers.open} > Phone </Button> </Tooltip> <Tooltip label="Import from Excel or CSV" withArrow> <Button size="xs" variant="default" leftSection={ <Icon icon="tabler:file-type-xls" fontSize={16} /> } onClick={excelModalHandlers.open} > Excel </Button> </Tooltip> <Tooltip label="Import from WhatsApp Groups" withArrow> <Button size="xs" variant="default" leftSection={<Icon icon="tabler:users" fontSize={16} />} onClick={groupsModalHandlers.open} > Groups </Button> </Tooltip> <Tooltip label="Import from Tags" withArrow> <Button size="xs" variant="default" leftSection={<Icon icon="tabler:tag" fontSize={16} />} onClick={tagsModalHandlers.open} > Tag </Button> </Tooltip> {/* ++ ADDED: Smart Segment Button */} <Tooltip label="Smart Segments (Filter Logic)" withArrow> <Button size="xs" variant="default" leftSection={<Icon icon="tabler:filter" fontSize={16} />} onClick={smartSegmentModalHandlers.open} > Segment </Button> </Tooltip> <Tooltip label="Load a saved recipient list" withArrow> <Button size="xs" variant="default" leftSection={ <Icon icon="tabler:database-import" fontSize={16} /> } onClick={loadListModalHandlers.open} > Load List </Button> </Tooltip> </Button.Group> <Tooltip label="Save current recipients as a reusable list" withArrow > <Button variant="default" size="xs" leftSection={ <Icon icon="tabler:device-floppy" fontSize={16} /> } onClick={handleOpenSaveListModal} disabled={recipients.length === 0} > Save List </Button> </Tooltip> <Tooltip label="Remove all recipients" withArrow> <Button size="xs" variant="light" color="red" disabled={recipients.length === 0} leftSection={<Icon icon="tabler:x" fontSize={16} />} onClick={handleClearAll} > Clear All </Button> </Tooltip> </Group> </Group> {/* Search Bar */} <TextInput placeholder={`Search in ${recipients.length} recipients...`} leftSection={<Icon icon="tabler:search" fontSize={16} />} value={searchQuery} size="sm" onChange={(e) => setSearchQuery(e.currentTarget.value)} disabled={recipients.length === 0} /> {/* Data Table */} <DataTable height={'calc(70vh - 160px)'} records={paginatedRecipients} columns={columns} totalRecords={filteredAndSortedRecipients.length} recordsPerPage={PAGE_SIZE} page={page} onPageChange={(p) => setPage(p)} minHeight={filteredAndSortedRecipients.length === 0 ? 150 : 0} noRecordsText={ searchQuery ? 'No recipients match your search' : 'No recipients added yet.' } withTableBorder={false} striped selectedRecords={selectedRecords} onSelectedRecordsChange={setSelectedRecords} idAccessor="number" sortStatus={sortStatus} onSortStatusChange={setSortStatus} /> </Stack> <Group justify="flex-end"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button onClick={handleConfirm}>Confirm & Close</Button> </Group> </Stack> </Modal> {/* Sub Modals */} <ModalSourceManual opened={showManualModal} onClose={manualModalHandlers.close} onSubmit={handleAddRecipients} /> <ModalSourcePhoneContacts opened={showphoneContactsModal} onClose={phoneContactsModalHandlers.close} onSubmit={handleAddRecipients} /> <ModalSourceExcel opened={showExcelModal} onClose={excelModalHandlers.close} onSubmit={handleAddRecipients} /> <ModalSourceGroups opened={showGroupsModal} onClose={groupsModalHandlers.close} onSubmit={handleAddRecipients} /> <ModalSourceTags opened={showTagsModal} onClose={tagsModalHandlers.close} onSubmit={handleAddRecipients} /> {/* ++ ADDED: Smart Segment Modal */} <ModalSourceSmartSegment opened={showSmartSegmentModal} onClose={smartSegmentModalHandlers.close} onSubmit={handleAddRecipients} /> <ModalSaveRecipientList opened={showSaveListModal} onClose={saveListModalHandlers.close} onSave={handleSaveList} isSaving={isSaving} /> <ModalLoadRecipientList opened={showLoadListModal} onClose={loadListModalHandlers.close} onLoad={handleLoadList} /> </> ) } export default ModalManageSources \`\`\` # src/features/broadcast/components/Modal/ModalManageTemplate.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import { Media, Message } from '@/constants' import useDbQuery from '@/hooks/useDbQuery' import useLicense from '@/hooks/useLicense' import type { BroadcastTemplate } from '@/libs/db' import db from '@/libs/db' import confirm from '@/utils/confirm' import toast from '@/utils/toast' // Import toast import { Icon } from '@iconify/react' import { ActionIcon, Button, Center, Group, Stack, Text, TextInput, Title, Tooltip, } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import { DataTable } from 'mantine-datatable' import React, { useState } from 'react' import MessageType from '../Datatable/MessageType' import ModalCreateUpdateTemplate from './ModalCreateUpdateTemplate' interface Props { opened: boolean onClose: () => void } const ModalManageTemplate: React.FC<Props> = ({ opened, onClose }) => { const license = useLicense() const dataQuery = useDbQuery<BroadcastTemplate>({ table: db.broadcastTemplates, }) const [editingTemplate, setEditingTemplate] = useState<Partial<BroadcastTemplate> | null>(null) const [showModalCreateUpdate, modalCreateUpdate] = useDisclosure(false) const handleDelete = async (template: BroadcastTemplate) => { const isConfirmed = await confirm.danger( 'Delete Template', 'Are you sure you want to delete this template?', ) if (!isConfirmed) return await db.media .where({ type: Media.BROADCAST_TEMPLATE, parentId: template.id }) .delete() await db.broadcastTemplates.delete(template.id) } const handleEdit = (template: BroadcastTemplate) => { setEditingTemplate(template) modalCreateUpdate.open() } const handleClone = (template: BroadcastTemplate) => { const { id, ...restOfTemplate } = template const clonedTemplate = { ...restOfTemplate, name: `${template.name} (Copy)`, } setEditingTemplate(clonedTemplate) modalCreateUpdate.open() } // ++ MODIFIED: Check limit before opening create modal const handleOpenCreateModal = async () => { if (license.isFree()) { const count = await db.broadcastTemplates.count() if (count >= 1) { toast.warning( 'Free plan limit reached (1 template). Upgrade for unlimited templates.', ) return } } setEditingTemplate(null) modalCreateUpdate.open() } const renderMessage = (broadcastTemplate: BroadcastTemplate) => { const { message } = broadcastTemplate if (!message) return '-' const typeContent: any = { [Message.TEXT]: typeof message === 'string' ? message : JSON.stringify(message), [Message.MEDIA]: (message as any).caption, [Message.IMAGE]: (message as any).caption, [Message.VIDEO]: (message as any).caption, [Message.FILE]: typeof message === 'string' ? message : (message as any).caption, [Message.BUTTON]: (message as any).title, [Message.LIST]: (message as any).title, [Message.LOCATION]: (message as any).name, [Message.POLL]: (message as any).name, [Message.VCARD]: '-', } return typeContent[broadcastTemplate.type] || JSON.stringify(message) } return ( <Modal opened={opened} onClose={onClose} w={850} withCloseButton> <Stack> <Center> <Title order={3}>Manage Templates</Title> </Center> <Stack gap="md" p={'md'}> <Group justify="space-between"> <TextInput placeholder={`Search by ${dataQuery.searchField}...`} size="sm" value={dataQuery.search} onChange={(e) => dataQuery.setSearch(e.currentTarget.value)} leftSection={<Icon icon="tabler:search" fontSize={16} />} style={{ flex: 1 }} /> <Button size="sm" leftSection={<Icon icon="tabler:plus" fontSize={18} />} onClick={handleOpenCreateModal} > Add Template </Button> </Group> <DataTable records={dataQuery?.data} totalRecords={dataQuery?.totalRecords} recordsPerPage={dataQuery?.pageSize} page={dataQuery?.page} onPageChange={dataQuery?.setPage} minHeight={300} noRecordsText="No templates found" columns={[ { accessor: 'name' }, { accessor: 'type', render: (record) => <MessageType type={record.type} />, }, { accessor: 'message', title: 'Message', render: renderMessage }, { accessor: 'actions', title: <Text mr="xs">Actions</Text>, textAlign: 'right', width: '0%', render: (template: BroadcastTemplate) => ( <Group gap={4} justify="right" wrap="nowrap"> <Tooltip label="Edit Template" position="top"> <ActionIcon color="blue" variant="subtle" onClick={() => handleEdit(template)} > <Icon icon="tabler:edit" fontSize={22} /> </ActionIcon> </Tooltip> <Tooltip label="Clone Template" position="top"> <ActionIcon color="teal" variant="subtle" onClick={() => handleClone(template)} > <Icon icon="tabler:copy" fontSize={22} /> </ActionIcon> </Tooltip> <Tooltip label="Delete Template" position="top"> <ActionIcon color="red" variant="subtle" onClick={async () => await handleDelete(template)} > <Icon icon="tabler:trash" fontSize={22} /> </ActionIcon> </Tooltip> </Group> ), }, ]} /> </Stack> <ModalCreateUpdateTemplate opened={showModalCreateUpdate} onClose={() => { modalCreateUpdate.close() setEditingTemplate(null) }} data={editingTemplate} /> </Stack> </Modal> ) } export default ModalManageTemplate \`\`\` # src/features/broadcast/components/Modal/ModalSaveRecipientList.tsx \`\`\`tsx // src/features/broadcast/components/Modal/ModalSaveRecipientList.tsx import Modal from '@/components/Modal/Modal' import { Button, Center, Group, Stack, TextInput, Title } from '@mantine/core' import { useForm } from '@mantine/form' import React from 'react' interface Props { opened: boolean onClose: () => void onSave: (name: string) => void isSaving: boolean } const ModalSaveRecipientList: React.FC<Props> = ({ opened, onClose, onSave, isSaving, }) => { const form = useForm({ initialValues: { name: '', }, validate: { name: (value) => value.trim().length > 0 ? null : 'List name is required', }, }) const handleSubmit = (values: { name: string }) => { onSave(values.name) } const handleClose = () => { form.reset() onClose() } return ( <Modal opened={opened} onClose={handleClose} withCloseButton w={500}> <form onSubmit={form.onSubmit(handleSubmit)}> <Stack> <Center> <Title order={4}>Save Recipient List</Title> </Center> <TextInput label="List Name" placeholder="e.g., Weekly Newsletter Leads" {...form.getInputProps('name')} data-autofocus /> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={handleClose}> Cancel </Button> <Button type="submit" loading={isSaving}> Save List </Button> </Group> </Stack> </form> </Modal> ) } export default ModalSaveRecipientList \`\`\` # src/features/broadcast/components/Modal/ModalSourceCommunities.tsx \`\`\`tsx // src/features/broadcast/components/Modal/ModalSourceGroups.tsx import Modal from '@/components/Modal/Modal' import { useAppStore } from '@/stores/app' import { Icon } from '@iconify/react' import { Avatar, Button, Card, Center, Checkbox, Group, Loader, ScrollArea, Stack, Text, TextInput, Title, } from '@mantine/core' // ++ ADDED: Import useDebouncedValue for search input debouncing import { useDebouncedValue } from '@mantine/hooks' import React, { useMemo, useState } from 'react' import { When } from 'react-if' interface Props { opened: boolean onClose: () => void onSubmit: (recipients: any[]) => void } /** * @component ModalSourceGroups * @description A modal component to select recipients from the user's WhatsApp groups. * It now includes a search functionality and displays group avatars for better identification. */ const ModalSourceCommunities: React.FC<Props> = ({ opened, onClose, onSubmit, }) => { const { groups } = useAppStore() const [selectedGroups, setSelectedGroups] = useState<string[]>([]) const [searchQuery, setSearchQuery] = useState('') // ++ ADDED: Debounce the search query with a 300ms delay to improve performance. const [debouncedSearchQuery] = useDebouncedValue(searchQuery, 300) // -- MODIFIED: This improves performance by re-computing the list only when groups or the debounced search query change. const filteredGroups = useMemo(() => { if (!groups) return [] if (!debouncedSearchQuery) return groups.filter( (group: any) => group.type === 'LINKED_ANNOUNCEMENT_GROUP', ) const lowerCaseQuery = debouncedSearchQuery.toLowerCase() return groups.filter((group: any) => { return ( group.name.toLowerCase().includes(lowerCaseQuery) && group.type === 'LINKED_ANNOUNCEMENT_GROUP' ) }) }, [groups, debouncedSearchQuery]) const allFilteredSelected = filteredGroups.length > 0 && filteredGroups.every((group) => selectedGroups.includes(group.id)) // ++ ADDED: Handler to toggle selection for all filtered groups. const handleToggleSelectAll = () => { if (allFilteredSelected) { // If all are selected, deselect only the filtered ones const filteredGroupIds = new Set(filteredGroups.map((g) => g.id)) setSelectedGroups((prev) => prev.filter((id) => !filteredGroupIds.has(id)), ) } else { // If not all are selected, add all filtered ones to the selection const filteredGroupIds = filteredGroups.map((g) => g.id) setSelectedGroups((prev) => [...new Set([...prev, ...filteredGroupIds])]) } } const handleToggleGroup = (groupId: string) => { setSelectedGroups((prev) => prev.includes(groupId) ? prev.filter((id) => id !== groupId) : [...prev, groupId], ) } const handleSubmit = () => { const finalRecipients = groups ?.filter((group: any) => selectedGroups.includes(group.id)) .map((group: any) => ({ number: group.id, // The group's ID (e.g., xxxxx@g.us) name: group.name, // The group's name source: 'Community', // The source identifier })) || [] onSubmit(finalRecipients) handleClose() } const handleClose = () => { setSelectedGroups([]) setSearchQuery('') // Reset search on close onClose() } return ( <> <Modal opened={opened} onClose={handleClose} withCloseButton w={500}> <Stack> <Center> <Title order={4}>Add Recipients from Communities</Title> </Center> <TextInput placeholder="Search community by name..." leftSection={<Icon icon="tabler:search" fontSize={16} />} value={searchQuery} size="sm" onChange={(event) => setSearchQuery(event.currentTarget.value)} disabled={groups.length === 0} /> <When condition={groups.length === 0}> <Center h={200}> <Loader /> <Text ml="md">Loading...</Text> </Center> </When> <When condition={groups.length > 0}> {/* ++ ADDED: "Select All" checkbox appears when there are filterable groups. */} {filteredGroups.length > 0 && ( <Checkbox label={allFilteredSelected ? 'Deselect All' : 'Select All'} checked={allFilteredSelected} onChange={handleToggleSelectAll} /> )} <ScrollArea h={300}> {filteredGroups.length > 0 ? ( <Stack> {filteredGroups.map((group: any) => ( <Card key={group.id} withBorder p="xs" radius="sm" shadow="none" style={{ cursor: 'pointer' }} onClick={() => handleToggleGroup(group.id)} > <Group wrap="nowrap"> <Checkbox checked={selectedGroups.includes(group.id)} readOnly aria-label={`Select group ${group.name}`} /> <Avatar src={group.avatar} radius="xl" variant="filled"> {group.name.charAt(0).toUpperCase()} </Avatar> <Text size="sm">{group.name}</Text> </Group> </Card> ))} </Stack> ) : ( <Center h={100}> <Text c="dimmed">No groups match your search.</Text> </Center> )} </ScrollArea> </When> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={handleClose}> Cancel </Button> <Button onClick={handleSubmit} disabled={selectedGroups.length === 0} > Add {selectedGroups.length} Group(s) </Button> </Group> </Stack> </Modal> </> ) } export default ModalSourceCommunities \`\`\` # src/features/broadcast/components/Modal/ModalSourceContacts.tsx \`\`\`tsx // src/features/broadcast/components/Modal/ModalSourceContacts.tsx import Modal from '@/components/Modal/Modal' import db from '@/libs/db' import { Icon } from '@iconify/react' import { Avatar, Button, Card, Center, Checkbox, Group, Loader, ScrollArea, Stack, Text, TextInput, Title, } from '@mantine/core' import { useDebouncedValue } from '@mantine/hooks' import { useLiveQuery } from 'dexie-react-hooks' import React, { useMemo, useState } from 'react' import { When } from 'react-if' interface Props { opened: boolean onClose: () => void onSubmit: (recipients: any[]) => void } /** * @component ModalSourceContacts * @description Modal to select recipients from CRM contacts (db.contacts) */ const ModalSourceContacts: React.FC<Props> = ({ opened, onClose, onSubmit, }) => { const contacts = useLiveQuery(() => db.contacts.toArray(), []) const [selectedContacts, setSelectedContacts] = useState<number[]>([]) const [searchQuery, setSearchQuery] = useState('') const [debouncedSearchQuery] = useDebouncedValue(searchQuery, 300) const filteredContacts = useMemo(() => { if (!contacts) return [] if (!debouncedSearchQuery) return contacts const lowerCaseQuery = debouncedSearchQuery.toLowerCase() return contacts.filter((contact) => { return ( contact.name?.toLowerCase().includes(lowerCaseQuery) || contact.number?.toLowerCase().includes(lowerCaseQuery) ) }) }, [contacts, debouncedSearchQuery]) const allFilteredSelected = filteredContacts.length > 0 && filteredContacts.every((contact) => selectedContacts.includes(contact.id!)) const handleToggleSelectAll = () => { if (allFilteredSelected) { const filteredContactIds = new Set(filteredContacts.map((c) => c.id!)) setSelectedContacts((prev) => prev.filter((id) => !filteredContactIds.has(id)), ) } else { const filteredContactIds = filteredContacts.map((c) => c.id!) setSelectedContacts((prev) => [ ...new Set([...prev, ...filteredContactIds]), ]) } } const handleToggleContact = (contactId: number) => { setSelectedContacts((prev) => prev.includes(contactId) ? prev.filter((id) => id !== contactId) : [...prev, contactId], ) } const handleSubmit = () => { const finalRecipients = contacts ?.filter((contact) => selectedContacts.includes(contact.id!)) .map((contact) => ({ number: contact.number.replace('@c.us', ''), name: contact.name || 'N/A', source: 'CRM', })) || [] onSubmit(finalRecipients) handleClose() } const handleClose = () => { setSelectedContacts([]) setSearchQuery('') onClose() } const isLoading = contacts === undefined return ( <> <Modal opened={opened} onClose={handleClose} withCloseButton w={500}> <Stack> <Center> <Title order={4}>Add Recipients from CRM Contacts</Title> </Center> <TextInput placeholder="Search contacts by name or number..." leftSection={<Icon icon="tabler:search" fontSize={16} />} value={searchQuery} size="sm" onChange={(event) => setSearchQuery(event.currentTarget.value)} disabled={isLoading || (contacts?.length || 0) === 0} /> <When condition={isLoading}> <Center h={200}> <Loader /> <Text ml="md">Loading contacts...</Text> </Center> </When> <When condition={!isLoading && (contacts?.length || 0) === 0}> <Center h={200}> <Stack align="center" gap="xs"> <Icon icon="tabler:database-off" fontSize={48} opacity={0.5} /> <Text c="dimmed">No contacts in database</Text> </Stack> </Center> </When> <When condition={!isLoading && (contacts?.length || 0) > 0}> {filteredContacts.length > 0 && ( <Checkbox label={allFilteredSelected ? 'Deselect All' : 'Select All'} checked={allFilteredSelected} onChange={handleToggleSelectAll} /> )} <ScrollArea h={300}> {filteredContacts.length > 0 ? ( <Stack> {filteredContacts.map((contact) => ( <Card key={contact.id} withBorder p="xs" radius="sm" shadow="none" style={{ cursor: 'pointer' }} onClick={() => handleToggleContact(contact.id!)} > <Group wrap="nowrap"> <Checkbox checked={selectedContacts.includes(contact.id!)} readOnly aria-label={`Select contact ${contact.name}`} /> <Avatar radius="xl" variant="filled"> {contact.name?.charAt(0)?.toUpperCase() || '?'} </Avatar> <Stack gap={0} style={{ flex: 1 }}> <Text size="sm">{contact.name || 'Unknown'}</Text> <Text size="xs" c="dimmed"> {contact.number?.replace('@c.us', '')} </Text> </Stack> </Group> </Card> ))} </Stack> ) : ( <Center h={100}> <Text c="dimmed">No contacts match your search.</Text> </Center> )} </ScrollArea> </When> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={handleClose}> Cancel </Button> <Button onClick={handleSubmit} disabled={selectedContacts.length === 0} > Add {selectedContacts.length} Contact(s) </Button> </Group> </Stack> </Modal> </> ) } export default ModalSourceContacts \`\`\` # src/features/broadcast/components/Modal/ModalSourceExcel.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import ExcelUploadPopover from '@/features/broadcast/components/Excel/ExcelUploadPopover' import { Center, Stack, Title } from '@mantine/core' import React from 'react' import ExcelUploader from '../Excel/ExcelUploader' interface Props { opened: boolean onClose: () => void onSubmit: (recipients: any[]) => void } const ModalSourceExcel: React.FC<Props> = ({ opened, onClose, onSubmit }) => { // This handler receives the raw parsed data from the uploader and formats it // for the broadcast recipient list before passing it up to the parent. const handleConfirmUpload = (parsedData: any[]) => { const newRecipients = parsedData .map((item) => ({ number: item.number?.toString(), name: item.name?.toString() || 'From Excel', source: 'Excel', })) .filter((item) => item.number) if (newRecipients.length > 0) { onSubmit(newRecipients) } } return ( <Modal opened={opened} onClose={onClose} withCloseButton w={500}> <Stack> <Center> <Title order={4}>Add Numbers From Excel</Title> </Center> <ExcelUploader onConfirm={handleConfirmUpload} onClose={onClose} /> </Stack> </Modal> ) } export default ModalSourceExcel \`\`\` # src/features/broadcast/components/Modal/ModalSourceGroups.tsx \`\`\`tsx // src/features/broadcast/components/Modal/ModalSourceGroups.tsx import Modal from '@/components/Modal/Modal' import { useAppStore } from '@/stores/app' import { Icon } from '@iconify/react' import { Avatar, Button, Card, Center, Checkbox, Group, Loader, ScrollArea, Stack, Text, TextInput, Title, } from '@mantine/core' // ++ ADDED: Import useDebouncedValue for search input debouncing import { useDebouncedValue } from '@mantine/hooks' import React, { useMemo, useState } from 'react' import { When } from 'react-if' interface Props { opened: boolean onClose: () => void onSubmit: (recipients: any[]) => void } /** * @component ModalSourceGroups * @description A modal component to select recipients from the user's WhatsApp groups. * It now includes a search functionality and displays group avatars for better identification. */ const ModalSourceGroups: React.FC<Props> = ({ opened, onClose, onSubmit }) => { const { groups } = useAppStore() const [selectedGroups, setSelectedGroups] = useState<string[]>([]) const [searchQuery, setSearchQuery] = useState('') // ++ ADDED: Debounce the search query with a 300ms delay to improve performance. const [debouncedSearchQuery] = useDebouncedValue(searchQuery, 300) // -- MODIFIED: This improves performance by re-computing the list only when groups or the debounced search query change. const filteredGroups = useMemo(() => { if (!groups) return [] if (!debouncedSearchQuery) return groups.filter((group: any) => group.type === 'DEFAULT') const lowerCaseQuery = debouncedSearchQuery.toLowerCase() return groups.filter((group: any) => { return ( group.name.toLowerCase().includes(lowerCaseQuery) && group.type === 'DEFAULT' ) }) }, [groups, debouncedSearchQuery]) // ++ ADDED: Check if all currently filtered groups are selected. const allFilteredSelected = filteredGroups.length > 0 && filteredGroups.every((group) => selectedGroups.includes(group.id)) // ++ ADDED: Handler to toggle selection for all filtered groups. const handleToggleSelectAll = () => { if (allFilteredSelected) { // If all are selected, deselect only the filtered ones const filteredGroupIds = new Set(filteredGroups.map((g) => g.id)) setSelectedGroups((prev) => prev.filter((id) => !filteredGroupIds.has(id)), ) } else { // If not all are selected, add all filtered ones to the selection const filteredGroupIds = filteredGroups.map((g) => g.id) setSelectedGroups((prev) => [...new Set([...prev, ...filteredGroupIds])]) } } const handleToggleGroup = (groupId: string) => { setSelectedGroups((prev) => prev.includes(groupId) ? prev.filter((id) => id !== groupId) : [...prev, groupId], ) } const handleSubmit = () => { const finalRecipients = groups ?.filter((group: any) => selectedGroups.includes(group.id)) .map((group: any) => ({ number: group.id, // The group's ID (e.g., xxxxx@g.us) name: group.name, // The group's name source: 'Group', // The source identifier })) || [] onSubmit(finalRecipients) handleClose() } const handleClose = () => { setSelectedGroups([]) setSearchQuery('') // Reset search on close onClose() } return ( <> <Modal opened={opened} onClose={handleClose} withCloseButton w={500}> <Stack> <Center> <Title order={4}>Add Recipients from Groups</Title> </Center> <TextInput placeholder="Search groups by name..." leftSection={<Icon icon="tabler:search" fontSize={16} />} value={searchQuery} size="sm" onChange={(event) => setSearchQuery(event.currentTarget.value)} disabled={groups.length === 0} /> <When condition={groups.length === 0}> <Center h={200}> <Loader /> <Text ml="md">Loading groups...</Text> </Center> </When> <When condition={groups.length > 0}> {/* ++ ADDED: "Select All" checkbox appears when there are filterable groups. */} {filteredGroups.length > 0 && ( <Checkbox label={allFilteredSelected ? 'Deselect All' : 'Select All'} checked={allFilteredSelected} onChange={handleToggleSelectAll} /> )} <ScrollArea h={300}> {filteredGroups.length > 0 ? ( <Stack> {filteredGroups.map((group: any) => ( <Card key={group.id} withBorder p="xs" radius="sm" shadow="none" style={{ cursor: 'pointer' }} onClick={() => handleToggleGroup(group.id)} > <Group wrap="nowrap"> <Checkbox checked={selectedGroups.includes(group.id)} readOnly aria-label={`Select group ${group.name}`} /> <Avatar src={group.avatar} radius="xl" variant="filled"> {group.name.charAt(0).toUpperCase()} </Avatar> <Text size="sm">{group.name}</Text> </Group> </Card> ))} </Stack> ) : ( <Center h={100}> <Text c="dimmed">No groups match your search.</Text> </Center> )} </ScrollArea> </When> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={handleClose}> Cancel </Button> <Button onClick={handleSubmit} disabled={selectedGroups.length === 0} > Add {selectedGroups.length} Group(s) </Button> </Group> </Stack> </Modal> </> ) } export default ModalSourceGroups \`\`\` # src/features/broadcast/components/Modal/ModalSourceManual.tsx \`\`\`tsx // src/features/broadcast/components/Modal/ModalSourceManual.tsx import Modal from '@/components/Modal/Modal' import { Button, Center, Group, ScrollArea, Stack, Textarea, Title, } from '@mantine/core' import { useForm } from '@mantine/form' import React from 'react' interface Props { opened: boolean onClose: () => void onSubmit: (numbers: string[]) => void } const ModalSourceManual: React.FC<Props> = ({ opened, onClose, onSubmit }) => { const form = useForm({ // MODIFIED: Changed initial value to a string to support the Textarea component. initialValues: { numbers: '', }, // MODIFIED: Adapted validation to check if the trimmed string is empty. validate: { numbers: (value) => value.trim().length === 0 ? 'Please enter at least one number.' : null, }, }) /** * English: Handles form submission by parsing the newline-separated numbers * from the textarea, cleaning them, ensuring uniqueness, and then * passing the result to the parent component. */ const handleSubmit = (values: { numbers: string }) => { // 1. Split the string by newlines. // 2. Clean each line by removing non-numeric characters (except '+') and trimming whitespace. // 3. Filter out any empty lines that might result from the split. const cleanedNumbers = values.numbers .split('\n') .map((num) => num.replace(/[^0-9+]/g, '').trim()) .filter((num) => num.length > 0) // Use a Set to automatically handle duplicates before submitting. const uniqueNumbers = [...new Set(cleanedNumbers)] onSubmit(uniqueNumbers) form.reset() onClose() } return ( <> <Modal opened={opened} onClose={onClose} withCloseButton w={500}> <form onSubmit={form.onSubmit(handleSubmit)}> <Stack> <Center> <Title order={4}>Add Numbers Manually</Title> </Center> {/* MODIFIED: Replaced TagsInput with a more suitable Textarea for lists. */} <ScrollArea h={200}> <Textarea label="Phone Numbers" placeholder="Enter one number per line, including the country code." {...form.getInputProps('numbers')} autosize minRows={5} data-autofocus /> </ScrollArea> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button type="submit">Add Numbers</Button> </Group> </Stack> </form> </Modal> </> ) } export default ModalSourceManual \`\`\` # src/features/broadcast/components/Modal/ModalSourcePhoneContacts.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import wa from '@/libs/wa' import filterBy from '@/utils/filterBy' import { getContactName } from '@/utils/util' import { Icon } from '@iconify/react' import { Avatar, Button, Card, Center, Checkbox, Group, Loader, ScrollArea, Stack, Text, TextInput, Title, } from '@mantine/core' import { useDebouncedValue } from '@mantine/hooks' import _ from 'lodash' import React, { useEffect, useMemo, useState } from 'react' import { When } from 'react-if' interface Props { opened: boolean onClose: () => void onSubmit: (recipients: any[]) => void } const ModalSourcePhoneContacts: React.FC<Props> = ({ opened, onClose, onSubmit, }) => { const [contacts, setContacts] = useState<any[]>([]) const [loading, setLoading] = useState(true) const [selectedContacts, setSelectedContacts] = useState<string[]>([]) const [searchQuery, setSearchQuery] = useState('') const [debouncedSearchQuery] = useDebouncedValue(searchQuery, 300) useEffect(() => { if (opened) { const fetchContacts = async () => { setLoading(true) try { const contactList = _.uniqBy( await wa.contact.list({ onlyMyContacts: true }), 'id', ) const sortedContacts = [...contactList].sort((a, b) => getContactName(a).localeCompare(getContactName(b)), ) setContacts(sortedContacts) } catch (error) { console.error('Failed to fetch contacts:', error) setContacts([]) } finally { setLoading(false) } } fetchContacts() } else { setContacts([]) setSelectedContacts([]) setSearchQuery('') } }, [opened]) const filteredContacts = useMemo(() => { if (!debouncedSearchQuery) return contacts const lowerCaseQuery = debouncedSearchQuery.toLowerCase() return contacts.filter( (c) => getContactName(c).toLowerCase().includes(lowerCaseQuery) || // Check both direct phoneNumber (if available) or the ID (c.phoneNumber && c.phoneNumber.includes(lowerCaseQuery)) || (c.id && c.id.includes(lowerCaseQuery)), ) }, [contacts, debouncedSearchQuery]) const allFilteredSelected = filteredContacts.length > 0 && filteredContacts.every((contact) => selectedContacts.includes(contact.id)) const handleToggleSelectAll = () => { if (allFilteredSelected) { const filteredContactIds = new Set(filteredContacts.map((c) => c.id)) setSelectedContacts((prev) => prev.filter((id) => !filteredContactIds.has(id)), ) } else { const filteredContactIds = filteredContacts.map((c) => c.id) setSelectedContacts((prev) => [ ...new Set([...prev, ...filteredContactIds]), ]) } } const handleToggleContact = (contactId: string) => { setSelectedContacts((prev) => prev.includes(contactId) ? prev.filter((id) => id !== contactId) : [...prev, contactId], ) } const handleClose = () => { onClose() } const handleSubmit = () => { const finalRecipients = contacts .filter((c) => selectedContacts.includes(c.id)) .map((contact) => { // ++ FIXED: Extract number from ID correctly if 'number' or 'phoneNumber' prop is missing // The serializer returns id like '12345@c.us'. We need '12345'. const extractedNumber = contact.id ? contact.id.split('@')[0] : contact.number || contact.phoneNumber return { number: extractedNumber, name: getContactName(contact), } }) onSubmit(finalRecipients) handleClose() } return ( <Modal opened={opened} onClose={handleClose} withCloseButton w={500}> <Stack> <Center> <Title order={4}>Add Recipients from Phone</Title> </Center> <TextInput placeholder="Search contacts by name or number..." leftSection={<Icon icon="tabler:search" fontSize={16} />} value={searchQuery} size="sm" onChange={(event) => setSearchQuery(event.currentTarget.value)} disabled={loading || contacts.length === 0} /> <When condition={loading}> <Center h={300}> <Loader /> <Text ml="md">Loading your contacts...</Text> </Center> </When> <When condition={!loading && contacts.length > 0}> {filteredContacts.length > 0 && ( <Checkbox label={allFilteredSelected ? 'Deselect All' : 'Select All'} checked={allFilteredSelected} onChange={handleToggleSelectAll} /> )} <ScrollArea h={400}> {filteredContacts.length > 0 ? ( <Stack> {filteredContacts.map((contact) => ( <Card key={contact.id} withBorder p="xs" radius="sm" shadow="none" style={{ cursor: 'pointer' }} onClick={() => handleToggleContact(contact.id)} > <Group wrap="nowrap"> <Checkbox checked={selectedContacts.includes(contact.id)} readOnly aria-label={`Select contact ${getContactName(contact)}`} /> <Avatar src={contact.avatar} radius="xl" variant="filled"> {getContactName(contact).charAt(0).toUpperCase()} </Avatar> <Stack gap={0}> <Text size="sm">{getContactName(contact)}</Text> <Text size="xs" c="dimmed"> {contact.phoneNumber || contact.id.split('@')[0]} </Text> </Stack> </Group> </Card> ))} </Stack> ) : ( <Center h={100}> <Text c="dimmed">No contacts match your search.</Text> </Center> )} </ScrollArea> </When> <When condition={!loading && contacts.length === 0}> <Center h={300}> <Text c="dimmed">No saved contacts found.</Text> </Center> </When> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={handleClose}> Cancel </Button> <Button onClick={handleSubmit} disabled={selectedContacts.length === 0} > Add {selectedContacts.length} Contact(s) </Button> </Group> </Stack> </Modal> ) } export default ModalSourcePhoneContacts \`\`\` # src/features/broadcast/components/Modal/ModalSourceSmartSegment.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import ModalSegmentBuilder from '@/features/contacts/components/Modal/ModalSegmentBuilder' import { evaluateSegment } from '@/features/contacts/helpers/segmentEvaluator' import useLicense from '@/hooks/useLicense' import db, { type SegmentRule, type SmartSegment } from '@/libs/db' import confirm from '@/utils/confirm' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { ActionIcon, Badge, Button, Center, Group, Paper, ScrollArea, SimpleGrid, Stack, Text, Title, Tooltip, } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import { useLiveQuery } from 'dexie-react-hooks' import React, { useCallback, useMemo, useState } from 'react' interface Props { opened: boolean onClose: () => void onSubmit: (recipients: any[]) => void } // Helper function to generate rule summary const generateRuleSummary = ( rules: SegmentRule[], logic: 'AND' | 'OR', ): string => { if (!rules || rules.length === 0) return 'No rules defined' const summaries = rules.slice(0, 3).map((rule) => { const fieldLabel = rule.field === 'tag' ? 'Tag' : rule.field === 'name' ? 'Name' : rule.field === 'number' ? 'Number' : rule.field.startsWith('cf_') ? 'Field' : rule.field const operatorLabel = rule.operator === 'equals' ? '=' : rule.operator === 'contains' ? '~' : rule.operator === 'startsWith' ? '^' : rule.operator === 'greaterThan' ? '>' : rule.operator === 'lessThan' ? '<' : rule.operator === 'isEmpty' ? 'empty' : rule.operator === 'isNotEmpty' ? 'not empty' : rule.operator if (['isEmpty', 'isNotEmpty'].includes(rule.operator)) { return `${fieldLabel} is ${operatorLabel}` } const valueLabel = typeof rule.value === 'string' && rule.value.length > 15 ? rule.value.substring(0, 15) + '...' : rule.value || '?' return `${fieldLabel} ${operatorLabel} "${valueLabel}"` }) const connector = logic === 'AND' ? ' + ' : ' | ' let result = summaries.join(connector) if (rules.length > 3) { result += ` +${rules.length - 3} more` } return result } const ModalSourceSmartSegment: React.FC<Props> = ({ opened, onClose, onSubmit, }) => { const [loadingId, setLoadingId] = useState<number | null>(null) const license = useLicense() // Free user limit: 1 segment const FREE_SEGMENT_LIMIT = 1 // Builder Modal State const [showBuilder, builderHandlers] = useDisclosure(false) const [editingSegment, setEditingSegment] = useState<SmartSegment | null>( null, ) // Fetch all saved segments const segments = useLiveQuery(() => db.smartSegments.toArray(), []) // Apply segment - process and add contacts const handleApply = useCallback( async (segment: SmartSegment) => { setLoadingId(segment.id!) try { const matchedContacts = await evaluateSegment(segment) const recipients = matchedContacts.map((c) => ({ name: c.name || 'Unknown', number: c.number?.replace('@c.us', '') || '', source: `Segment: ${segment.name}`, })) onSubmit(recipients) onClose() } catch (error) { console.error('Error processing segment:', error) } finally { setLoadingId(null) } }, [onSubmit, onClose], ) // Handle Edit Action const handleEdit = useCallback( (segment: SmartSegment) => { setEditingSegment(segment) builderHandlers.open() }, [builderHandlers], ) // Handle Delete Action const handleDelete = useCallback(async (segment: SmartSegment) => { const isConfirmed = await confirm.danger( 'Delete Segment', `Are you sure you want to delete "${segment.name}"? This action is irreversible.`, ) if (isConfirmed) { await db.smartSegments.delete(segment.id!) } }, []) // Handle Pin/Unpin Action const handlePin = useCallback(async (segment: SmartSegment) => { const newPinned = segment.pinned ? 0 : 1 await db.smartSegments.update(segment.id!, { pinned: newPinned }) }, []) // Sort segments: pinned first, then by name const sortedSegments = useMemo(() => { if (!segments) return [] return [...segments].sort((a, b) => { if ((a.pinned || 0) !== (b.pinned || 0)) { return (b.pinned || 0) - (a.pinned || 0) } return a.name.localeCompare(b.name) }) }, [segments]) // Open Create Modal const handleCreate = () => { // Check free user limit if (license.isFree() && segments && segments.length >= FREE_SEGMENT_LIMIT) { toast.warning( `Free users can only create ${FREE_SEGMENT_LIMIT} segment. Upgrade for unlimited segments.`, 'Limit Reached', ) return } setEditingSegment(null) builderHandlers.open() } const hasSegments = segments && segments.length > 0 const canCreateMore = license.isPro() || !segments || segments.length < FREE_SEGMENT_LIMIT return ( <> <Modal opened={opened} onClose={onClose} withCloseButton w={700}> <Stack> <Center> <Title order={4}>Smart Segments</Title> </Center> <Text size="sm" c="dimmed" ta="center"> Dynamically filter contacts based on tags, names, and custom fields. </Text> {/* Segment Grid */} <ScrollArea h={350} type="auto" offsetScrollbars> {!hasSegments ? ( <Center h={250}> <Stack align="center" gap="xs"> <Icon icon="tabler:filter-off" fontSize={48} opacity={0.5} /> <Text c="dimmed">No segments created yet</Text> <Button variant="light" size="sm" leftSection={<Icon icon="tabler:plus" />} onClick={handleCreate} > Create Your First Segment </Button> </Stack> </Center> ) : ( <SimpleGrid cols={2} spacing="sm"> {sortedSegments.map((segment) => { const ruleSummary = generateRuleSummary( segment.rules, segment.logic, ) const isLoading = loadingId === segment.id const isPinned = segment.pinned === 1 return ( <Paper key={segment.id} p="sm" withBorder radius="md"> <Group justify="space-between" wrap="nowrap" mb={4}> <Text fw={500} size="sm" truncate style={{ flex: 1 }}> {segment.name} </Text> {/* Direct Action Icons */} <Group gap={4}> <Tooltip label={isPinned ? 'Unpin' : 'Pin to top'}> <ActionIcon size="sm" variant={isPinned ? 'filled' : 'subtle'} color="yellow" onClick={() => handlePin(segment)} > <Icon icon={ isPinned ? 'tabler:pinned-filled' : 'tabler:pin' } fontSize={14} /> </ActionIcon> </Tooltip> <Tooltip label="Apply segment"> <ActionIcon size="sm" variant="light" color="teal" loading={isLoading} onClick={() => handleApply(segment)} > <Icon icon="tabler:check" fontSize={14} /> </ActionIcon> </Tooltip> <Tooltip label="Edit segment"> <ActionIcon size="sm" variant="subtle" color="blue" onClick={() => handleEdit(segment)} > <Icon icon="tabler:edit" fontSize={14} /> </ActionIcon> </Tooltip> <Tooltip label="Delete segment"> <ActionIcon size="sm" variant="subtle" color="red" onClick={() => handleDelete(segment)} > <Icon icon="tabler:trash" fontSize={14} /> </ActionIcon> </Tooltip> </Group> </Group> {/* Logic Badge */} <Group gap={4} mb={4}> <Badge size="xs" variant="light" color={segment.logic === 'AND' ? 'blue' : 'orange'} > {segment.logic} </Badge> <Badge size="xs" variant="outline" color="gray"> {segment.rules.length} rule {segment.rules.length !== 1 ? 's' : ''} </Badge> </Group> {/* Rule Summary */} <Tooltip label={ruleSummary} multiline maw={250} position="bottom" withArrow > <Text size="xs" c="dimmed" lineClamp={1}> {ruleSummary} </Text> </Tooltip> </Paper> ) })} </SimpleGrid> )} </ScrollArea> {/* Create Button */} {hasSegments && ( <Button variant="light" leftSection={<Icon icon="tabler:plus" />} onClick={handleCreate} fullWidth > Create New Segment </Button> )} <Group justify="flex-end" mt="md"> <Button variant="default" onClick={onClose}> Close </Button> </Group> </Stack> </Modal> {/* Builder Modal */} <ModalSegmentBuilder opened={showBuilder} onClose={builderHandlers.close} onSave={() => { // Dexie LiveQuery will automatically update the list }} editingSegment={editingSegment} /> </> ) } export default ModalSourceSmartSegment \`\`\` # src/features/broadcast/helpers/broadcastActions.ts \`\`\`ts // src/features/Broadcast/helpers/broadcastActions.ts import { Message } from '@/constants' import MediaModel from '@/features/media/models/MediaModel' import type { Broadcast, BroadcastContact } from '@/libs/db' import wa from '@/libs/wa' import parse from '@/utils/parse' import throwError from '@/utils/throwError' import { generateRandomDelay } from '@/utils/util' /** * @description Returns the appropriate sending function based on broadcast type. * @param {Broadcast} broadcast - The parent broadcast record. * @param {BroadcastContact} contact - The recipient contact. * @returns {Function | null} The async function to send the message, or null. */ export const getBroadcastAction = ( broadcast: Broadcast, contact: BroadcastContact, ) => { const sendOptions = { ...(broadcast.isTyping && { delay: generateRandomDelay(1000, 3000) }), } const actions: { [key: string]: () => Promise<any> } = { [Message.TEXT]: async () => { const text = parse.text(broadcast.message as string, contact) return wa.send.text(contact.number, text, sendOptions) }, [Message.IMAGE]: async () => { const file = await MediaModel.firstByBroadcastId(broadcast.id) if (!file) throwError.mediaNotFound() const message = broadcast.message as { caption?: string } return wa.send.file(contact.number, file.file, { type: 'image', caption: message.caption, ...sendOptions, }) }, [Message.VIDEO]: async () => { const file = await MediaModel.firstByBroadcastId(broadcast.id) if (!file) throwError.mediaNotFound() const message = broadcast.message as { caption?: string } return wa.send.file(contact.number, file.file, { type: 'video', caption: message.caption, ...sendOptions, }) }, [Message.AUDIO]: async () => { const file = await MediaModel.firstByBroadcastId(broadcast.id) if (!file) throwError.mediaNotFound() return wa.send.file(contact.number, file.file, { type: 'audio', ...sendOptions, }) }, [Message.FILE]: async () => { const file = await MediaModel.firstByBroadcastId(broadcast.id) if (!file) throwError.mediaNotFound() return wa.send.file(contact.number, file.file, { type: 'document', caption: broadcast.message as string, ...sendOptions, }) }, [Message.LOCATION]: async () => { const message = broadcast.message as any return wa.send.location(contact.number, { ...message, ...sendOptions }) }, [Message.POLL]: async () => { const { name, choices } = broadcast.message as any return wa.send.poll(contact.number, name, choices, sendOptions) }, [Message.VCARD]: async () => { return wa.send.vcard( contact.number, broadcast.message as any[], sendOptions, ) }, } return actions[broadcast.type] || null } \`\`\` # src/features/broadcast/helpers/executeAction.ts \`\`\`ts import ContactNoteModel from '@/features/contacts/models/ContactNoteModel' import CustomFieldModel from '@/features/contacts/models/CustomFieldModel' import { handleArchiveChat, handleClearChat, handleDeleteChat, handlePinChat, } from '@/features/workflow/engine/handlers/chatHandlers' import { handleAddTag, handleRemoveTag, } from '@/features/workflow/engine/handlers/crmHandlers' import type { Broadcast, BroadcastAction, DelayPayload, ExportReportPayload, GroupReportPayload, IncrementFieldPayload, NotePayload, SelfMessagePayload, SendStatsSelfPayload, UpdateFieldPayload, } from '@/libs/db' import db from '@/libs/db' import wa from '@/libs/wa' import toast from '@/utils/toast' import { delay } from '@/utils/util' import dayjs from 'dayjs' import FileSaver from 'file-saver' import * as XLSX from 'xlsx' /** * Executes a single post-broadcast action. * Reuses logic from Workflow handlers to avoid code duplication. */ export const executeBroadcastAction = async ( action: BroadcastAction, contactNumber: string, contactId?: number, broadcast?: Broadcast, // Optional: for COMPLETE actions that need broadcast context ) => { // Ensure format includes suffix if missing const chatId = contactNumber.includes('@') ? contactNumber : `${contactNumber}@c.us` try { switch (action.type) { case 'ADD_TAG': if (contactId && action.payload) { await handleAddTag( { tagName: action.payload as string }, { contactId }, ) } break case 'REMOVE_TAG': if (contactId && action.payload) { await handleRemoveTag( { tagName: action.payload as string }, { contactId }, ) } break case 'ARCHIVE_CHAT': await delay(2000) await handleArchiveChat(chatId, true) break case 'UPDATE_FIELD': if (contactId && action.payload) { const { customFieldId, value } = action.payload as UpdateFieldPayload await CustomFieldModel.updateValue(contactId, customFieldId, value) } break case 'INCREMENT_FIELD': if (contactId && action.payload) { const { customFieldId, incrementBy } = action.payload as IncrementFieldPayload // Get current value and increment const currentValue = await CustomFieldModel.getValue( contactId, customFieldId, ) const numericValue = parseInt(currentValue || '0', 10) || 0 const newValue = numericValue + (incrementBy || 1) await CustomFieldModel.updateValue( contactId, customFieldId, String(newValue), ) } break case 'CLEAR_CHAT': await delay(2000) await handleClearChat(chatId, true) // keepStarred = true break case 'DELETE_CHAT': await delay(2000) await handleDeleteChat(chatId) break case 'PIN_CHAT': await delay(2000) await handlePinChat(chatId, true) break case 'UNPIN_CHAT': await delay(2000) await handlePinChat(chatId, false) break case 'SELF_MESSAGE': if (action.payload) { const { message } = action.payload as SelfMessagePayload // Apply random delay 3-6 seconds before sending const randomDelay = Math.floor(Math.random() * 4) + 3 // 3-6 seconds await delay(randomDelay * 1000) // Send message to "Note to Self" (own number) const myUserId = await wa.conn.getMyUserId() const selfChatId = myUserId?._serialized if (selfChatId && message) { await wa.send.text(selfChatId, message) } } break case 'ADD_NOTE': if (contactId && action.payload) { const { content } = action.payload as NotePayload await ContactNoteModel.add(contactId, content) } break case 'DELAY': if (action.payload) { const { seconds } = action.payload as DelayPayload await delay(seconds * 1000) } break case 'EXPORT_REPORT': if (broadcast && action.payload) { const { format } = action.payload as ExportReportPayload // Fetch broadcast contacts const contacts = await db.broadcastContacts .where({ broadcastId: broadcast.id }) .toArray() if (contacts.length === 0) { toast.info('No data to export.') break } // Prepare export data const dataForExport = contacts.map((contact) => ({ Name: contact.name || 'N/A', Number: contact.number.split('@')[0], Status: contact.status, 'Sent At': contact.sendAt ? dayjs(contact.sendAt).format('YYYY-MM-DD HH:mm:ss') : '-', Notes: contact.error || '-', })) // Generate filename const broadcastName = ( broadcast.name || 'Untitled_Broadcast' ).replace(/[^a-zA-Z0-9]/g, '_') const exportDate = dayjs().format('YYYYMMDD_HHmm') const filename = `${broadcastName}_${exportDate}` // Create workbook and export const worksheet = XLSX.utils.json_to_sheet(dataForExport) const workbook = XLSX.utils.book_new() XLSX.utils.book_append_sheet(workbook, worksheet, 'Broadcast Results') const fileExtension = format === 'xlsx' ? 'xlsx' : 'csv' const mimeType = format === 'xlsx' ? 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8' : 'text/csv;charset=utf-8;' const fileBuffer = XLSX.write(workbook, { bookType: format, type: 'array', }) const blob = new Blob([fileBuffer], { type: mimeType }) FileSaver.saveAs(blob, `${filename}.${fileExtension}`) toast.success('Report exported successfully.') } break case 'MUTE_CHAT': await delay(2000) // Mute chat for 8 hours (default) await wa.chat.mute(chatId, { duration: 8 * 60 * 60 }) break case 'BLOCK_CONTACT': await delay(2000) await wa.blocklist.blockContact(chatId) break case 'SEND_STATS_SELF': if (broadcast) { // Apply random delay 3-6 seconds before sending const randomDelay = Math.floor(Math.random() * 4) + 3 // 3-6 seconds await delay(randomDelay * 1000) // Fetch broadcast contacts and calculate stats const contacts = await db.broadcastContacts .where({ broadcastId: broadcast.id }) .toArray() const total = contacts.length const success = contacts.filter((c) => c.status === 'SUCCESS').length const failed = contacts.filter((c) => c.status === 'FAILED').length const cancelled = contacts.filter( (c) => c.status === 'CANCELLED', ).length const successRate = total > 0 ? ((success / total) * 100).toFixed(1) : '0' // Generate stats message const statsMessage = `*Broadcast Report* *${broadcast.name || 'Untitled'}* ${dayjs().format('DD MMM YYYY, HH:mm')} âœ… Success: ${success} âŒ Failed: ${failed} â›” Cancelled: ${cancelled} ðŸ“ Total: ${total} ðŸŽ¯ Success Rate: ${successRate}%` // Send to self const myUserId = await wa.conn.getMyUserId() const selfChatId = myUserId?._serialized if (selfChatId) { await wa.send.text(selfChatId, statsMessage) } } break case 'SEND_REPORT_GROUP': if (broadcast && action.payload) { const { groupId } = action.payload as GroupReportPayload if (!groupId) break // Apply random delay 3-6 seconds before sending const randomDelay = Math.floor(Math.random() * 4) + 3 // 3-6 seconds await delay(randomDelay * 1000) // Fetch broadcast contacts and calculate stats const contacts = await db.broadcastContacts .where({ broadcastId: broadcast.id }) .toArray() const total = contacts.length const success = contacts.filter((c) => c.status === 'SUCCESS').length const failed = contacts.filter((c) => c.status === 'FAILED').length const successRate = total > 0 ? ((success / total) * 100).toFixed(1) : '0' // Generate report message const reportMessage = `*Broadcast Report* *${broadcast.name || 'Untitled'}* ${dayjs().format('DD MMM YYYY, HH:mm')} Success: ${success} Failed: ${failed} Total: ${total} Success Rate: ${successRate}%` await wa.send.text(groupId, reportMessage) } break } } catch (error) { console.error(`Failed to execute broadcast action (${action.type}):`, error) } } \`\`\` # src/features/broadcast/hooks/useBroadcast.ts \`\`\`ts import { Status } from '@/constants' import type { Broadcast, BroadcastContact } from '@/libs/db' import db from '@/libs/db' import wa from '@/libs/wa' import toast from '@/utils/toast' import { delay } from '@/utils/util' import dayjs from 'dayjs' import _ from 'lodash' import { useRef } from 'react' import { getBroadcastAction } from '../helpers/broadcastActions' import { executeBroadcastAction } from '../helpers/executeAction' import BroadcastContactModel from '../models/BroadcastContactModel' import BroadcastModel from '../models/BroadcastModel' const useBroadcast = () => { const processingState = useRef<'IDLE' | 'PROCESSING'>('IDLE') const validationRef = useRef(true) const runBroadcast = async ( broadcast: Broadcast, contact: BroadcastContact, ) => { const action = getBroadcastAction(broadcast, contact) if (action) { await action() } else { throw new Error(`Unsupported broadcast message type: ${broadcast.type}`) } } const checkAllContactsDone = async (broadcast: Broadcast) => { // Check for any contacts that are NOT finished (Pending, Running, or Scheduled) const incompleteCount = await db.broadcastContacts .where('broadcastId') .equals(broadcast.id) .and((c) => [Status.PENDING, Status.RUNNING, Status.SCHEDULER].includes(c.status), ) .count() // If all contacts are done (Success, Failed, or Cancelled) if (incompleteCount === 0) { const freshBroadcast = await BroadcastModel.get(broadcast.id) // Prevent marking as success if user manually paused/cancelled it if ( freshBroadcast.status === Status.PAUSED || freshBroadcast.status === Status.CANCELLED || freshBroadcast.status === Status.SUCCESS // Already success ) { return } await BroadcastModel.success(broadcast.id) if (broadcast.actions && broadcast.actions.length > 0) { const completeActions = broadcast.actions.filter( (a) => a.trigger === 'COMPLETE', ) if (completeActions.length > 0) { for (const action of completeActions) { await executeBroadcastAction(action, '', undefined, broadcast) } } } toast.success( `Broadcast "${broadcast.name || 'Untitled'}" has been completed.`, ) } } // ++ ADDED: Safety mechanism to fix "Stuck Running" broadcasts const checkStuckBroadcasts = async () => { try { // Find all broadcasts that are currently marked as RUNNING const runningBroadcasts = await db.broadcasts .where('status') .equals(Status.RUNNING) .toArray() for (const broadcast of runningBroadcasts) { // Double check if they really have work left to do const hasWorkLeft = await db.broadcastContacts .where('broadcastId') .equals(broadcast.id) .and((c) => [Status.PENDING, Status.RUNNING, Status.SCHEDULER].includes( c.status, ), ) .count() // If no work left, force complete it if (hasWorkLeft === 0) { console.log( `[Broadcaster] Fixing stuck broadcast: ${broadcast.id} - ${broadcast.name}`, ) await checkAllContactsDone(broadcast) } } } catch (error) { console.error('[Broadcaster] Error checking stuck broadcasts:', error) } } const processBroadcastQueue = async () => { if (processingState.current === 'PROCESSING') return processingState.current = 'PROCESSING' try { while (true) { const contacts = await BroadcastContactModel.getStatusPendingBatch(20) if (!contacts.length) break const contactsByBroadcast = _.groupBy(contacts, 'broadcastId') for (const broadcastIdStr in contactsByBroadcast) { const broadcastId = parseInt(broadcastIdStr, 10) const contactGroup = contactsByBroadcast[broadcastId] const broadcast = await BroadcastModel.get(broadcastId) if (!broadcast) { const contactIds = contactGroup.map((c) => c.id) await db.broadcastContacts .bulkUpdate( contactIds.map((id) => ({ key: id, changes: { status: Status.FAILED, error: 'Broadcast record missing.', }, })), ) .catch(console.error) continue } if (broadcast.status !== Status.RUNNING) { await BroadcastModel.running(broadcast.id) } for (const contact of contactGroup) { if (!validationRef.current) return const triggerActions = async ( triggerStatus: 'SUCCESS' | 'FAILED', ) => { if (!broadcast.actions || broadcast.actions.length === 0) return const relevantActions = broadcast.actions.filter( (a) => a.trigger === triggerStatus, ) if (relevantActions.length === 0) return let dbContactId: number | undefined = undefined if (relevantActions.some((a) => a.type.includes('TAG'))) { const dbContact = await db.contacts .where({ number: contact.number }) .first() dbContactId = dbContact?.id } for (const action of relevantActions) { await executeBroadcastAction( action, contact.number, dbContactId, ) } } try { await BroadcastContactModel.running(contact.id) // --- VALIDASI NOMOR RUNTIME --- if (broadcast.validateNumber) { const checkId = contact.number.includes('@') ? contact.number : `${contact.number}@c.us` const isValid = await wa.contact.isExist(checkId) if (!isValid) { throw new Error('Number is not registered on WhatsApp') } await delay(500) } // ------------------------------ const randomDelay = Math.floor( Math.random() * (broadcast.delayMax - broadcast.delayMin + 1), ) + broadcast.delayMin await delay(randomDelay) await runBroadcast(broadcast, contact) await BroadcastContactModel.success(contact.id) await triggerActions('SUCCESS') } catch (error: any) { await BroadcastContactModel.failed(contact.id, error.message) await triggerActions('FAILED') } } // Check after batch for this broadcast await checkAllContactsDone(broadcast) } } } catch (e) { console.error( 'An unexpected error occurred in the broadcast processor:', e, ) } finally { // ++ ADDED: Ensure any broadcasts that finished during this cycle are marked done await checkStuckBroadcasts() processingState.current = 'IDLE' } } const checkScheduledAndPaused = async () => { const now = new Date() await db.broadcastContacts .where('status') .equals(Status.SCHEDULER) .and((contact) => dayjs(contact.scheduledAt).isBefore(now)) .modify({ status: Status.PENDING }) await processBroadcastQueue() } const cancel = async (broadcastId: number) => { validationRef.current = false while (processingState.current === 'PROCESSING') { await delay(200) } processingState.current = 'PROCESSING' try { await db.broadcastContacts .where({ broadcastId }) .and((c) => [Status.PENDING, Status.SCHEDULER, Status.RUNNING].includes(c.status), ) .modify({ status: Status.CANCELLED, error: 'Cancelled by user' }) await BroadcastModel.cancel(broadcastId) toast.info('Broadcast has been cancelled.') } catch (e) { console.error(`Error during cancellation of broadcast ${broadcastId}:`, e) toast.error('Failed to cancel broadcast.') } finally { validationRef.current = true processingState.current = 'IDLE' } } const initializeBroadcaster = async () => { await BroadcastContactModel.resetRunningStatuses() await processBroadcastQueue() } return { init: initializeBroadcaster, checkScheduled: checkScheduledAndPaused, cancel, } } export default useBroadcast \`\`\` # src/features/broadcast/hooks/useBroadcastForm.ts \`\`\`ts import useInputMessage from '@/components/Input/Message/useInputMessage' import { Media, Message, Setting, Status } from '@/constants' import useLicense from '@/hooks/useLicense' import db, { type Broadcast } from '@/libs/db' // import wa from '@/libs/wa' // Hapus import wa karena tidak dipakai lagi disini import toast from '@/utils/toast' import { formHasErrors, isTypeMessageMedia, showModalUpgrade, } from '@/utils/util' import { useForm } from '@mantine/form' import { useStorage } from '@plasmohq/storage/hook' import { addMinutes, isFuture } from 'date-fns' import _ from 'lodash' import { useEffect } from 'react' const hashMessage = (obj: any): string => { const str = JSON.stringify(obj) if (str.length === 0) return '0' const hash = str .split('') .reduce((a, b) => ((a << 5) - a + b.charCodeAt(0)) | 0, 0) return hash.toString() } interface useBroadcastFormProps { cloneData?: (Broadcast & { recipients?: any[] }) | null onSuccess: () => void onClose: () => void } export const useBroadcastForm = ({ cloneData = null, onSuccess, onClose, }: useBroadcastFormProps) => { const license = useLicense() const [globalDelayMin] = useStorage(Setting.BROADCAST_DEFAULT_DELAY_MIN, '5') const [globalDelayMax] = useStorage(Setting.BROADCAST_DEFAULT_DELAY_MAX, '15') const defaultDelayMin = parseInt(globalDelayMin, 10) || 5 const defaultDelayMax = parseInt(globalDelayMax, 10) || 15 const form = useForm({ initialValues: { name: '', numbers: [] as any[], isTyping: true, validateNumber: false, delayMin: defaultDelayMin, delayMax: defaultDelayMax, scheduler: { enabled: false, scheduledAt: addMinutes(new Date(), 5), }, batching: { enabled: false, size: 50, delay: 5, }, actions: [] as any[], }, validate: { delayMin: (value, values) => { if (value < 5) return 'Minimum delay must be at least 5 seconds' if (value > values.delayMax) return 'Min delay cannot exceed Max delay' return null }, delayMax: (value, values) => { if (value < values.delayMin) return 'Max delay cannot be lower than Min' return null }, scheduler: (value) => { if (value.enabled && !value.scheduledAt) { return 'Scheduled date and time is required.' } if ( value.enabled && value.scheduledAt && !isFuture(new Date(value.scheduledAt)) ) { return 'Scheduled time must be in the future.' } return null }, }, validateInputOnChange: [ 'scheduler.scheduledAt', 'scheduler.enabled', 'delayMin', 'delayMax', ], }) useEffect(() => { if (!cloneData) { form.setFieldValue('delayMin', defaultDelayMin) form.setFieldValue('delayMax', defaultDelayMax) } }, [defaultDelayMin, defaultDelayMax]) const { form: inputMessageForm, getMessage, insertBroadcastFile, } = useInputMessage() useEffect(() => { const populateForm = async () => { if (cloneData) { let recipientsToSet: any[] = [] let nameSuffix = ' (Copy)' const broadcastName = `${cloneData.name || 'Broadcast'}` if (cloneData.recipients && cloneData.recipients.length > 0) { recipientsToSet = cloneData.recipients nameSuffix = ' (Resend)' } else { const originalRecipients = await db.broadcastContacts .where({ broadcastId: cloneData.id }) .toArray() recipientsToSet = originalRecipients.map((contact) => ({ number: contact.number, name: contact.name, })) } form.setValues({ name: `${broadcastName}${nameSuffix}`, numbers: recipientsToSet, isTyping: !!cloneData.isTyping, validateNumber: !!cloneData.validateNumber, delayMin: cloneData.delayMin ? cloneData.delayMin / 1000 : 5, delayMax: cloneData.delayMax ? cloneData.delayMax / 1000 : 10, scheduler: { enabled: false, scheduledAt: addMinutes(new Date(), 5), }, batching: { enabled: !!cloneData.batchSize, size: cloneData.batchSize || 50, delay: cloneData.batchDelay || 5, }, actions: cloneData.actions || [], }) const { type, message } = cloneData inputMessageForm.setFieldValue('type', type) switch (type) { case Message.TEXT: inputMessageForm.setFieldValue('inputText', message as string) break case Message.IMAGE: case Message.VIDEO: case Message.AUDIO: case Message.FILE: const mediaFile = await db.media .where({ parentId: cloneData.id, type: Media.BROADCAST }) .first() const caption = (message as any)?.caption || (typeof message === 'string' ? message : '') if (type === Message.IMAGE) { inputMessageForm.setFieldValue('inputImage', { file: mediaFile?.file || null, caption, }) } else if (type === Message.VIDEO) { inputMessageForm.setFieldValue('inputVideo', { file: mediaFile?.file || null, caption, }) } else if (type === Message.AUDIO) { inputMessageForm.setFieldValue('inputAudio', { file: mediaFile?.file || null, }) } else { inputMessageForm.setFieldValue('inputFile', { file: mediaFile?.file || null, caption, }) } break case Message.LOCATION: inputMessageForm.setFieldValue('inputLocation', message) break case Message.POLL: inputMessageForm.setFieldValue('inputPoll', message) break } } } if (cloneData) { populateForm().catch(console.error) } }, [cloneData]) const handleClose = () => { form.reset() inputMessageForm.reset() onClose() } const saveAndDispatchBroadcast = async (finalRecipients: any[]) => { const messagePayload = getMessage() const messageType = inputMessageForm.values.type const delayMinMs = form.values.delayMin * 1000 const delayMaxMs = form.values.delayMax * 1000 const { scheduler, batching } = form.values const isScheduled = scheduler.enabled || batching.enabled const broadcastData = { name: form.values.name, type: messageType, message: messagePayload, contentHash: hashMessage(messagePayload), isTyping: form.values.isTyping ? 1 : 0, validateNumber: form.values.validateNumber ? 1 : 0, // Flag ini tetap disimpan isScheduler: isScheduled ? 1 : 0, status: isScheduled ? Status.SCHEDULER : Status.PENDING, delayMin: delayMinMs, delayMax: delayMaxMs, batchSize: batching.enabled ? batching.size : undefined, batchDelay: batching.enabled ? batching.delay : undefined, actions: form.values.actions, } try { //@ts-ignore const broadcastId = await db.broadcasts.add(broadcastData as Broadcast) if (isTypeMessageMedia(inputMessageForm.values.type)) { await insertBroadcastFile(broadcastId, Media.BROADCAST) } let baseTime = scheduler.enabled ? new Date(scheduler.scheduledAt) : new Date() const contacts = finalRecipients.map((recipient: any, index: number) => { let scheduledAt = scheduler.enabled ? baseTime : null if (batching.enabled) { const batchIndex = Math.floor(index / batching.size) if (batchIndex > 0) { const delayMs = batchIndex * batching.delay * 60 * 1000 scheduledAt = new Date(baseTime.getTime() + delayMs) } else if (scheduler.enabled) { scheduledAt = baseTime } else { scheduledAt = baseTime } } return { broadcastId, number: recipient.number, name: recipient.name, status: isScheduled ? Status.SCHEDULER : Status.PENDING, scheduledAt, } }) as any await db.broadcastContacts.bulkAdd(contacts) onSuccess() } catch (error) { console.error('Failed to save broadcast:', error) toast.error('An error occurred while saving the broadcast.') } } const handleSendBroadcast = async (finalRecipients: any[]) => { if (formHasErrors(form, inputMessageForm)) return 'VALIDATION_ERROR' if (_.isEmpty(finalRecipients)) { toast.error('At least one recipient is required') return 'VALIDATION_ERROR' } // --- PERUBAHAN: Menghapus logika validasi nomor yang memblokir di sini --- // Kita mengirim semua recipient ke database. // Validasi akan dilakukan per-item di useBroadcast.ts saat runtime. await saveAndDispatchBroadcast(finalRecipients) return 'SUCCESS' } return { form, inputMessageForm, handleClose, handleSendBroadcast, getMessage, } } \`\`\` # src/features/broadcast/hooks/useRecipientManager.ts \`\`\`ts import useLicense from '@/hooks/useLicense' import db from '@/libs/db' import toast from '@/utils/toast' import { showModalUpgrade } from '@/utils/util' import { useDebouncedValue, useDisclosure } from '@mantine/hooks' import _ from 'lodash' import type { DataTableSortStatus } from 'mantine-datatable' import { useEffect, useMemo, useRef, useState } from 'react' interface Recipient { number: string name: string source?: string } interface useRecipientManagerProps { initialRecipients: Recipient[] } const PAGE_SIZE = 10 const FREE_PLAN_LIMIT = 5 export const useRecipientManager = ({ initialRecipients, }: useRecipientManagerProps) => { const license = useLicense() // State for data and UI const [recipients, setRecipients] = useState<Recipient[]>([]) const [selectedRecords, setSelectedRecords] = useState<Recipient[]>([]) const [editingRecipient, setEditingRecipient] = useState<Recipient | null>( null, ) const prevInitialRecipientsRef = useRef<Recipient[]>(initialRecipients) const [page, setPage] = useState(1) const [searchQuery, setSearchQuery] = useState('') const [debouncedSearchQuery] = useDebouncedValue(searchQuery, 300) const [sortStatus, setSortStatus] = useState<DataTableSortStatus>({ columnAccessor: 'name', direction: 'asc', }) const [editingCell, setEditingCell] = useState<{ recordId: string columnId: string } | null>(null) const [editValue, setEditValue] = useState('') const [isSaving, setIsSaving] = useState(false) const [listToLoad, setListToLoad] = useState<{ name: string recipients: Recipient[] } | null>(null) // Modal handlers const [showManualModal, manualModalHandlers] = useDisclosure(false) const [showExcelModal, excelModalHandlers] = useDisclosure(false) const [showGroupsModal, groupsModalHandlers] = useDisclosure(false) const [showCommunitiesModal, communitiesModalHandlers] = useDisclosure(false) const [showTagsModal, tagsModalHandlers] = useDisclosure(false) // ++ ADDED: Smart Segment Modal Handler const [showSmartSegmentModal, smartSegmentModalHandlers] = useDisclosure(false) const [showEditModal, editModalHandlers] = useDisclosure(false) const [showMyContactsModal, myContactsModalHandlers] = useDisclosure(false) const [showSaveListModal, saveListModalHandlers] = useDisclosure(false) const [showLoadListModal, loadListModalHandlers] = useDisclosure(false) const [showConfirmLoadModal, confirmLoadModalHandlers] = useDisclosure(false) const [showCrmContactsModal, crmContactsModalHandlers] = useDisclosure(false) // Effect to initialize or reset state useEffect(() => { if (!_.isEqual(initialRecipients, prevInitialRecipientsRef.current)) { setRecipients(_.cloneDeep(initialRecipients)) prevInitialRecipientsRef.current = initialRecipients setSelectedRecords([]) setPage(1) setSearchQuery('') setSortStatus({ columnAccessor: 'name', direction: 'asc' }) } else if (recipients.length === 0 && initialRecipients.length > 0) { setRecipients(_.cloneDeep(initialRecipients)) prevInitialRecipientsRef.current = initialRecipients } }, [initialRecipients]) // Memoized filtering and sorting const filteredAndSortedRecipients = useMemo(() => { let data = [...recipients] if (debouncedSearchQuery) { const lowerCaseQuery = debouncedSearchQuery.toLowerCase() data = data.filter( (r) => r.name?.toLowerCase().includes(lowerCaseQuery) || r.number?.toLowerCase().includes(lowerCaseQuery), ) } const { columnAccessor, direction } = sortStatus if (columnAccessor) { data = _.orderBy(data, [columnAccessor], [direction]) } return data }, [recipients, debouncedSearchQuery, sortStatus]) // Memoized pagination const paginatedRecipients = useMemo(() => { const from = (page - 1) * PAGE_SIZE const to = from + PAGE_SIZE return filteredAndSortedRecipients.slice(from, to) }, [filteredAndSortedRecipients, page]) useEffect(() => { setPage(1) }, [debouncedSearchQuery, sortStatus]) // Handlers const handleAddRecipients = (newRecipients: any[]) => { const formatted = newRecipients.map((rec) => { if (typeof rec === 'string') { return { number: rec, name: 'N/A', source: 'Manual' } } return { number: rec.number || rec.phoneNumber, name: rec.name || rec.savedName || rec.publicName || 'N/A', } }) let combined = [...recipients, ...formatted] let unique = _.uniqBy(combined, 'number') // Limit Check Logic for Free Users if (license.isFree()) { if (unique.length > FREE_PLAN_LIMIT) { toast.warning( `Max ${FREE_PLAN_LIMIT} recipients allowed on Free plan.`, 'Limit Reached', ) return } } setRecipients(unique) const addedCount = unique.length - recipients.length if (addedCount === 0) { toast.info('No new recipients added (duplicates skipped).') } } const handleDeleteRecipient = (numberToDelete: string) => { setRecipients((current) => current.filter((r) => r.number !== numberToDelete), ) } const handleBulkDelete = () => { const numbersToDelete = new Set(selectedRecords.map((r) => r.number)) setRecipients((current) => current.filter((r) => !numbersToDelete.has(r.number)), ) setSelectedRecords([]) toast.success(`${numbersToDelete.size} recipient(s) deleted.`) } const handleOpenEditModal = (recipient: Recipient) => { setEditingRecipient(recipient) editModalHandlers.open() } const handleUpdateRecipientFromModal = ( originalNumber: string, updatedData: { number: string; name: string }, ) => { const isDuplicate = recipients.some( (r) => r.number === updatedData.number && r.number !== originalNumber, ) if (isDuplicate) { toast.error(`The number ${updatedData.number} already exists.`) return } setRecipients((current) => current.map((r) => r.number === originalNumber ? { ...r, name: updatedData.name, number: updatedData.number } : r, ), ) editModalHandlers.close() } const handleSaveCellEdit = () => { if (!editingCell) return const { recordId, columnId } = editingCell const finalValue = editValue.trim() if (columnId === 'number') { if (finalValue === '') { toast.error('Number cannot be empty.') return } const isDuplicate = recipients.some( (r) => r.number === finalValue && r.number !== recordId, ) if (isDuplicate) { toast.error(`The number ${finalValue} already exists.`) return } } setRecipients((current) => current.map((r) => r.number === recordId ? { ...r, [columnId]: finalValue || r[columnId as keyof Recipient] } : r, ), ) setEditingCell(null) } const handleSaveList = async (name: string) => { if (recipients.length === 0) return toast.error('Cannot save an empty list.') if (license.isFree()) { const count = await db.broadcastRecipients.count() if (count >= 1) { toast.error('Free plan limit: 1 saved list. Upgrade to Pro.') return } } setIsSaving(true) try { await db.broadcastRecipients.add({ name, //@ts-ignore recipients, createdAt: new Date(), }) toast.success(`List "${name}" saved successfully.`) saveListModalHandlers.close() } catch (error) { toast.error('Failed to save the list.') } finally { setIsSaving(false) } } const handleLoadList = (list: { name: string; recipients: Recipient[] }) => { setListToLoad(list) confirmLoadModalHandlers.open() } const confirmLoadList = (mode: 'merge' | 'replace') => { if (!listToLoad) return let nextRecipients: Recipient[] = [] if (mode === 'replace') { nextRecipients = listToLoad.recipients } else { const combined = [...recipients, ...listToLoad.recipients] nextRecipients = _.uniqBy(combined, 'number') } // Limit Check if (license.isFree()) { if (nextRecipients.length > FREE_PLAN_LIMIT) { toast.warning( `Max ${FREE_PLAN_LIMIT} recipients allowed on Free plan.`, 'Limit Reached', ) return } } setRecipients(nextRecipients) if (mode === 'replace') { toast.success(`Loaded ${nextRecipients.length} recipients.`) } else { const addedCount = nextRecipients.length - recipients.length toast.success(`${addedCount} new recipient(s) merged successfully.`) } confirmLoadModalHandlers.close() setListToLoad(null) } const handleClearAll = () => setRecipients([]) return { // State recipients, paginatedRecipients, filteredAndSortedRecipients, selectedRecords, editingRecipient, editingCell, editValue, isSaving, page, searchQuery, sortStatus, listToLoad, // State Setters setSelectedRecords, setPage, setSearchQuery, setSortStatus, setEditingCell, setEditValue, // Handlers handleAddRecipients, handleDeleteRecipient, handleBulkDelete, handleOpenEditModal, handleUpdateRecipientFromModal, handleSaveCellEdit, handleSaveList, handleLoadList, confirmLoadList, handleClearAll, modals: { manual: { opened: showManualModal, ...manualModalHandlers }, excel: { opened: showExcelModal, ...excelModalHandlers }, groups: { opened: showGroupsModal, ...groupsModalHandlers }, communities: { opened: showCommunitiesModal, ...communitiesModalHandlers, }, tags: { opened: showTagsModal, ...tagsModalHandlers }, // ++ ADDED: Expose Smart Segment Modal Handlers smartSegment: { opened: showSmartSegmentModal, ...smartSegmentModalHandlers, }, edit: { opened: showEditModal, ...editModalHandlers }, myContacts: { opened: showMyContactsModal, ...myContactsModalHandlers }, saveList: { opened: showSaveListModal, ...saveListModalHandlers }, loadList: { opened: showLoadListModal, ...loadListModalHandlers }, confirmLoad: { opened: showConfirmLoadModal, ...confirmLoadModalHandlers, }, crmContacts: { opened: showCrmContactsModal, ...crmContactsModalHandlers, }, }, } } \`\`\` # src/features/broadcast/models/BroadcastContactModel.ts \`\`\`ts import { Status } from '@/constants' import db from '@/libs/db' const success = async (id: number) => { return await db.broadcastContacts.update(id, { status: Status.SUCCESS, sendAt: new Date(), }) } const running = async (id: number) => { return await db.broadcastContacts.update(id, { status: Status.RUNNING }) } const pending = async (id: number) => { return await db.broadcastContacts.update(id, { status: Status.PENDING }) } const failed = async (id: number, message: string | null = null) => { return await db.broadcastContacts.update(id, { status: Status.FAILED, error: message, }) } // ++ MODIFIED: This function now fetches a batch of pending contacts instead of just one. // This reduces the number of database queries in the main processing loop. const getStatusPendingBatch = async (limit: number = 20) => { return await db.broadcastContacts .where('status') .equals(Status.PENDING) .limit(limit) .toArray() } const resetRunningStatuses = async () => { const updatedContacts = await db.broadcastContacts .where('status') .equals(Status.RUNNING) .modify({ status: Status.PENDING }) if (updatedContacts > 0) { await db.broadcasts .where('status') .equals(Status.RUNNING) .modify({ status: Status.PENDING }) console.log( `Reset ${updatedContacts} contacts and potentially their broadcasts.`, ) } else { console.log('No stuck RUNNING statuses found.') } } export default { getStatusPendingBatch, success, failed, running, pending, resetRunningStatuses, } \`\`\` # src/features/broadcast/models/BroadcastModel.ts \`\`\`ts import { Status } from '@/constants' import db, { type Broadcast } from '@/libs/db' const running = async (id: number) => { await db.broadcasts.update(id, { status: Status.RUNNING }) } const success = async (id: number) => { await db.broadcasts.update(id, { status: Status.SUCCESS }) } const cancel = async (id: number) => { await db.broadcasts.update(id, { status: Status.CANCELLED }) } const pause = async (id: number) => { await db.broadcasts.update(id, { status: Status.PAUSED }) } const pending = async (id: number) => { await db.broadcasts.update(id, { status: Status.PENDING }) } const get = async (id: number): Promise<Broadcast> => { return await db.broadcasts.get(id) } export default { get, running, success, pause, cancel, pending, } \`\`\` # src/features/broadcast/PageBroadcast.tsx \`\`\`tsx import LayoutPage from '@/components/Layout/LayoutPage' import { Media, Status } from '@/constants' import useDataQuery from '@/hooks/useDbQuery' import useFile from '@/hooks/useFile' import useLicense from '@/hooks/useLicense' // ++ ADDED import type { Broadcast, BroadcastContact } from '@/libs/db' import db from '@/libs/db' import confirm from '@/utils/confirm' import toast from '@/utils/toast' import { showModalUpgrade } from '@/utils/util' // ++ ADDED import { Icon } from '@iconify/react' import { Box, Button, Group, LoadingOverlay, Stack, TextInput, } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import dayjs from 'dayjs' import { DataTable } from 'mantine-datatable' import React, { useState } from 'react' import { getBroadcastColumns } from './components/Datatable/BroadcastColumns' import ModalCreateBroadcast from './components/Modal/ModalCreateBroadcast' import ModalDetailHistory from './components/Modal/ModalDetailHistory' import ModalEditSchedule from './components/Modal/ModalEditSchedule' import useBroadcast from './hooks/useBroadcast' const PageBroadcast: React.FC = () => { const license = useLicense() // ++ ADDED const dataQuery = useDataQuery<Broadcast>({ table: db.broadcasts, initialPageSize: 10, searchField: 'name', initialSort: { field: 'id', direction: 'desc' }, }) const broadcastHook = useBroadcast() const fileExporter = useFile() const [showModalCreate, modalCreateHandlers] = useDisclosure(false) const [showModalDetail, modalDetailHandlers] = useDisclosure(false) const [showEditScheduleModal, editScheduleModalHandlers] = useDisclosure(false) const [editingBroadcast, setEditingBroadcast] = useState<Broadcast | null>( null, ) const [detailData, setDetailData] = useState<Broadcast | null>(null) const [resendData, setResendData] = useState<{ broadcast: Broadcast recipients: any[] } | null>(null) const [isExporting, setIsExporting] = useState(false) const [selectedRecords, setSelectedRecords] = useState<Broadcast[]>([]) const handleOpenCreateModal = () => { setResendData(null) modalCreateHandlers.open() } const handleResend = async ( broadcast: Broadcast, target: 'ALL' | 'FAILED' | 'SUCCESS', ) => { const contacts = await db.broadcastContacts .where({ broadcastId: broadcast.id }) .toArray() if (contacts.length === 0) { toast.error('No recipients found for this broadcast.') return } let filteredRecipients: BroadcastContact[] = [] switch (target) { case 'ALL': filteredRecipients = contacts break case 'FAILED': filteredRecipients = contacts.filter((r) => r.status === Status.FAILED) break case 'SUCCESS': filteredRecipients = contacts.filter((r) => r.status === Status.SUCCESS) break } if (filteredRecipients.length === 0) { toast.error(`No ${target.toLowerCase()} recipients to resend.`) return } const cloneData = { ...broadcast, id: undefined, name: `${broadcast.name || 'Untitled'} (Resend)`, status: Status.PENDING, recipients: filteredRecipients.map((r) => ({ number: r.number, name: r.name, })), } setResendData({ broadcast: cloneData as Broadcast, recipients: cloneData.recipients, }) modalCreateHandlers.open() } const handleViewDetails = (broadcast: Broadcast) => { setDetailData(broadcast) modalDetailHandlers.open() } const handleEditSchedule = async (broadcast: Broadcast) => { const firstContact = await db.broadcastContacts .where({ broadcastId: broadcast.id }) .first() if (firstContact && firstContact.scheduledAt) { const broadcastWithSchedule = { ...broadcast, scheduledAt: firstContact.scheduledAt, } setEditingBroadcast(broadcastWithSchedule as Broadcast) editScheduleModalHandlers.open() } else { toast.error('Could not find schedule information for this broadcast.') } } const handleUpdateSchedule = async ( broadcastId: number, newScheduledAt: Date, ) => { try { await db.broadcastContacts .where({ broadcastId: broadcastId, status: Status.SCHEDULER }) .modify({ scheduledAt: newScheduledAt }) await db.broadcasts.update(broadcastId, { status: Status.SCHEDULER }) toast.success('Broadcast schedule updated successfully.') editScheduleModalHandlers.close() } catch (error) { console.error('Failed to update schedule:', error) toast.error('Failed to update the schedule.') } } const deleteBroadcasts = async (broadcastsToDelete: Broadcast[]) => { if (broadcastsToDelete.length === 0) return const isPlural = broadcastsToDelete.length > 1 const isConfirmed = await confirm.danger( 'Delete Broadcasts', `Are you sure you want to delete ${broadcastsToDelete.length} broadcast${ isPlural ? 's' : '' }? This action is irreversible.`, ) if (!isConfirmed) return try { const broadcastIds = broadcastsToDelete.map((b) => b.id) await db.transaction( 'rw', db.broadcasts, db.broadcastContacts, db.media, async () => { await db.broadcastContacts .where('broadcastId') .anyOf(broadcastIds) .delete() await db.media .where('parentId') .anyOf(broadcastIds) .and((item) => item.type === Media.BROADCAST) .delete() await db.broadcasts.bulkDelete(broadcastIds) }, ) toast.success( `${broadcastsToDelete.length} broadcast${ isPlural ? 's' : '' } deleted successfully.`, ) setSelectedRecords([]) } catch (error) { console.error('Failed to delete broadcast(s):', error) toast.error('Failed to delete the broadcast(s).') } } const handleDelete = (broadcast: Broadcast) => { deleteBroadcasts([broadcast]) } const handleBulkDelete = () => { deleteBroadcasts(selectedRecords) } const handleClearAll = async () => { const allBroadcasts = await db.broadcasts.toArray() if (allBroadcasts.length === 0) { toast.info('There are no broadcasts to clear.') return } await deleteBroadcasts(allBroadcasts) } const handleExport = async (broadcast: Broadcast, format: string) => { if (license.isFree()) { toast.warning( 'Export is a Pro feature. Upgrade for unlimited exports.', 'Pro Feature', ) return } setIsExporting(true) try { const contacts = await db.broadcastContacts .where({ broadcastId: broadcast.id }) .toArray() if (contacts.length === 0) { toast.info('No data to export.') return } const dataForExport = contacts.map((contact) => ({ Name: contact.name || 'N/A', Number: contact.number.split('@')[0], Status: contact.status, 'Sent At': contact.sendAt ? dayjs(contact.sendAt).format('YYYY-MM-DD HH:mm:ss') : '-', Notes: contact.error || '-', })) const broadcastName = (broadcast.name || 'Untitled_Broadcast').replace( /[^a-zA-Z0-9]/g, '_', ) const exportDate = dayjs().format('YYYYMMDD') const filename = `${broadcastName}_${exportDate}` await fileExporter.saveAs(format, dataForExport, filename) } catch (error) { console.error('Failed to export broadcast data:', error) toast.error('An error occurred during export.') } finally { setIsExporting(false) } } const columns = getBroadcastColumns({ onViewDetails: handleViewDetails, onExport: handleExport, onCancel: broadcastHook.cancel, onDelete: handleDelete, onEditSchedule: handleEditSchedule, onResend: handleResend, }) return ( <LayoutPage width={900} icon={<Icon icon="tabler:broadcast" fontSize={24} color="#34d399" />} title="Broadcast" description="Send bulk messages to multiple recipients efficiently." > <Stack style={{ height: '100%' }}> <Group justify="space-between" mb="md"> <Group> <TextInput placeholder="Search by Name..." value={dataQuery.search} size="sm" onChange={(e) => dataQuery.setSearch(e.currentTarget.value)} leftSection={<Icon icon="tabler:search" fontSize={16} />} /> </Group> <Group> {selectedRecords.length > 0 && ( <Button variant="outline" color="red" size="sm" leftSection={<Icon icon="tabler:trash" fontSize={18} />} onClick={handleBulkDelete} > Delete Selected ({selectedRecords.length}) </Button> )} {dataQuery.data && dataQuery.data.length > 0 && selectedRecords.length === 0 && ( <Button variant="default" color="red" size="sm" leftSection={<Icon icon="tabler:clear-all" fontSize={18} />} onClick={handleClearAll} > Clear All </Button> )} <Button size="sm" leftSection={<Icon icon="tabler:plus" fontSize={18} />} onClick={handleOpenCreateModal} > Create </Button> </Group> </Group> <Box style={{ position: 'relative' }}> <LoadingOverlay visible={isExporting || dataQuery.data === undefined} zIndex={1000} overlayProps={{ radius: 'sm', blur: 2 }} /> <DataTable selectedRecords={selectedRecords} onSelectedRecordsChange={setSelectedRecords} records={dataQuery.data} columns={columns} totalRecords={dataQuery.totalRecords} recordsPerPage={dataQuery.pageSize} page={dataQuery.page} onPageChange={dataQuery.setPage} sortStatus={ dataQuery.sort ? { columnAccessor: dataQuery.sort.field, direction: dataQuery.sort.direction, } : undefined } onSortStatusChange={(status) => { if (typeof status.columnAccessor === 'string') { dataQuery.toggleSort(status.columnAccessor) } }} minHeight={435} noRecordsText="No broadcasts found" striped highlightOnHover withTableBorder borderRadius="sm" shadow="xs" verticalAlign="top" /> </Box> </Stack> <ModalCreateBroadcast opened={showModalCreate} onClose={() => { modalCreateHandlers.close() setResendData(null) }} onSuccess={() => { modalCreateHandlers.close() setResendData(null) }} cloneData={resendData} /> <ModalDetailHistory opened={showModalDetail} onClose={modalDetailHandlers.close} data={detailData} /> <ModalEditSchedule opened={showEditScheduleModal} onClose={editScheduleModalHandlers.close} onSubmit={handleUpdateSchedule} broadcastData={editingBroadcast} /> </LayoutPage> ) } export default PageBroadcast \`\`\` # src/features/contacts/components/CustomFieldRenderer.tsx \`\`\`tsx import { Icon } from '@iconify/react' import { ActionIcon, Anchor, Box, FileInput, Group, Image, MultiSelect, // Added NumberInput, Rating, // Added Select, Switch, Text, Textarea, TextInput, } from '@mantine/core' import { DatePickerInput } from '@mantine/dates' import type { UseFormReturnType } from '@mantine/form' import React, { useMemo } from 'react' interface Props { field: any index: number form: UseFormReturnType<any> contactId: number onValueChange: (contactId: number, customFieldId: number, value: any) => void } const CustomFieldRenderer: React.FC<Props> = ({ field, index, form, contactId, onValueChange, }) => { const handleBlur = () => { onValueChange(contactId, field.id, form.values.customFields[index]?.value) } const handleChange = (newValue: any) => { form.setFieldValue(`customFields.${index}.value`, newValue) } const handleImmediateChange = (newValue: any) => { handleChange(newValue) onValueChange(contactId, field.id, newValue) } const props = { key: field.id, label: field.name, mb: 'xs', } const currentValue = form.values.customFields[index]?.value // Helper to generate a preview URL for files (blob/file) const filePreviewUrl = useMemo(() => { if (currentValue instanceof File || currentValue instanceof Blob) { return URL.createObjectURL(currentValue) } return null }, [currentValue]) const renderFilePreview = (type: 'image' | 'document') => { if (!currentValue) return null return ( <Group mt={4} gap="xs"> {type === 'image' && filePreviewUrl && ( <Image src={filePreviewUrl} w={60} h={60} radius="md" fit="cover" style={{ border: '1px solid var(--mantine-color-default-border)' }} /> )} <Box style={{ flex: 1, overflow: 'hidden' }}> <Text size="xs" truncate c="dimmed"> {currentValue.name || 'File stored'} </Text> {filePreviewUrl && ( <Anchor href={filePreviewUrl} target="_blank" size="xs" download={currentValue.name || 'download'} > Download </Anchor> )} </Box> <ActionIcon color="red" variant="subtle" size="sm" onClick={() => handleImmediateChange(null)} > <Icon icon="tabler:x" /> </ActionIcon> </Group> ) } switch (field.type) { case 'text': return ( <TextInput {...props} size="sm" value={currentValue || ''} onChange={(e) => handleChange(e.currentTarget.value)} onBlur={handleBlur} /> ) case 'textarea': return ( <Textarea {...props} size="sm" value={currentValue || ''} onChange={(e) => handleChange(e.currentTarget.value)} onBlur={handleBlur} autosize minRows={2} /> ) case 'number': return ( <NumberInput {...props} size="sm" value={currentValue ?? ''} onChange={handleChange} onBlur={handleBlur} /> ) case 'date': let dateValue = currentValue if (typeof dateValue === 'string') dateValue = new Date(dateValue) return ( <DatePickerInput size="sm" {...props} value={dateValue || null} onChange={handleImmediateChange} clearable /> ) case 'select': return ( <Select {...props} size="sm" data={field.config?.options || []} value={currentValue || null} onChange={handleImmediateChange} clearable comboboxProps={{ withinPortal: false }} /> ) case 'multiSelect': return ( <MultiSelect {...props} size="sm" data={field.config?.options || []} value={Array.isArray(currentValue) ? currentValue : []} onChange={handleImmediateChange} clearable searchable hidePickedOptions comboboxProps={{ withinPortal: false }} /> ) case 'toggle': const isChecked = !!currentValue return ( <Group key={field.id} justify="space-between" mt="xs"> <Text size="sm" fw={500}> {field.name} </Text> <Switch checked={isChecked} onChange={(e) => handleImmediateChange(e.currentTarget.checked)} /> </Group> ) case 'rating': return ( <Group key={field.id} justify="space-between" mt="xs" mb="xs"> <Text size="sm" fw={500}> {field.name} </Text> <Group gap="xs"> {/* Optional: Clear button for rating */} {currentValue > 0 && ( <ActionIcon size="xs" variant="transparent" color="gray" onClick={() => handleImmediateChange(0)} > <Icon icon="tabler:circle-x" /> </ActionIcon> )} <Rating value={Number(currentValue) || 0} onChange={handleImmediateChange} /> </Group> </Group> ) case 'url': return ( <TextInput {...props} size="sm" value={currentValue || ''} onChange={(e) => handleChange(e.currentTarget.value)} onBlur={handleBlur} rightSection={ currentValue ? ( <ActionIcon component="a" href={ currentValue.startsWith('http') ? currentValue : `https://${currentValue}` } target="_blank" variant="transparent" size="sm" > <Icon icon="tabler:external-link" /> </ActionIcon> ) : null } /> ) case 'image': return ( <Box mb="xs"> <FileInput {...props} mb={0} placeholder="Upload image" accept="image/*" value={currentValue instanceof File ? currentValue : null} onChange={handleImmediateChange} leftSection={<Icon icon="tabler:photo" fontSize={16} />} clearable /> {renderFilePreview('image')} </Box> ) case 'document': return ( <Box mb="xs"> <FileInput {...props} mb={0} placeholder="Upload document" value={currentValue instanceof File ? currentValue : null} onChange={handleImmediateChange} leftSection={<Icon icon="tabler:file" fontSize={16} />} clearable /> {renderFilePreview('document')} </Box> ) default: return null } } export default CustomFieldRenderer \`\`\` # src/features/contacts/components/Modal/ModalCustomField.tsx \`\`\`tsx import AlertBanner from '@/components/AlertBanner' import Modal from '@/components/Modal/Modal' import CustomFieldModel from '@/features/contacts/models/CustomFieldModel' import useLicense from '@/hooks/useLicense' // ++ ADDED import db, { type CustomField } from '@/libs/db' import confirm from '@/utils/confirm' import toast from '@/utils/toast' import { showModalUpgrade } from '@/utils/util' // ++ ADDED import { Icon } from '@iconify/react' import { ActionIcon, Button, Group, Select, Stack, TagsInput, TextInput, Title, Tooltip, } from '@mantine/core' import { useForm } from '@mantine/form' import { useDisclosure } from '@mantine/hooks' import { useLiveQuery } from 'dexie-react-hooks' import { DataTable } from 'mantine-datatable' import React, { useState } from 'react' import { When } from 'react-if' interface Props { opened: boolean onClose: () => void } const ModalCustomField: React.FC<Props> = ({ opened, onClose }) => { const license = useLicense() // ++ ADDED const customFields = useLiveQuery(() => db.customFields.toArray(), []) const [showForm, formHandlers] = useDisclosure(false) const [editingId, setEditingId] = useState<number | null>(null) const form = useForm({ initialValues: { name: '', type: 'text', options: [] as string[], }, validate: { name: (value) => (value.trim() ? null : 'Name is required'), options: (value, values) => ['select', 'multiSelect'].includes(values.type) && value.length === 0 ? 'At least one option is required' : null, }, }) const handleOpenCreate = () => { setEditingId(null) form.reset() formHandlers.open() } const handleEdit = (field: CustomField) => { setEditingId(field.id) form.setValues({ name: field.name, type: field.type, options: field.config?.options || [], }) formHandlers.open() } const handleCancelForm = () => { formHandlers.close() setEditingId(null) form.reset() } const handleSubmit = async () => { if (form.validate().hasErrors) return try { const config = ['select', 'multiSelect'].includes(form.values.type) ? { options: form.values.options } : {} if (editingId) { await CustomFieldModel.update(editingId, { name: form.values.name, type: form.values.type, config, }) toast.success('Custom field updated') } else { if (license.isFree()) { const count = await db.customFields.count() if (count >= 2) { toast.warning( 'Free plan limit reached (2 custom fields). Upgrade to Pro.', ) return } } await CustomFieldModel.add(form.values.name, form.values.type, config) toast.success('Custom field created') } handleCancelForm() } catch (error) { console.error(error) toast.error('Failed to save field') } } const handleDelete = async (field: CustomField) => { if ( await confirm.danger( 'Delete Field', `Delete "${field.name}" and all associated data?`, ) ) { await CustomFieldModel.deleteById(field.id) toast.success('Field deleted') } } return ( <Modal opened={opened} onClose={onClose} w={700} withCloseButton> <Stack> <Group justify="space-between"> <Title order={4}>Manage Custom Fields</Title> <Button size="xs" leftSection={<Icon icon="tabler:plus" />} onClick={showForm ? handleCancelForm : handleOpenCreate} color={showForm ? 'red' : 'emerald'} variant="light" > {showForm ? 'Cancel' : 'New Field'} </Button> </Group> <AlertBanner message="Limited to 2 custom fields in the free version. Go unlimited" /> <When condition={showForm}> <Stack p="md" bg="rgba(255,255,255,0.03)" style={{ borderRadius: 8 }}> <Title order={5} size="sm" c="dimmed"> {editingId ? 'Edit Field' : 'Create New Field'} </Title> <TextInput label="Field Name" placeholder="e.g. Interests or Priority" {...form.getInputProps('name')} data-autofocus /> <Select label="Type" data={[ { group: 'Basic', items: [ { value: 'text', label: 'Text' }, { value: 'textarea', label: 'Long Text' }, { value: 'number', label: 'Number' }, { value: 'url', label: 'URL / Link' }, ], }, { group: 'Selection', items: [ { value: 'toggle', label: 'Toggle (Yes/No)' }, { value: 'select', label: 'Select (Dropdown)' }, { value: 'multiSelect', label: 'Multi Select' }, { value: 'rating', label: 'Rating (1-5)' }, { value: 'date', label: 'Date' }, ], }, { group: 'Media', items: [ { value: 'image', label: 'Image' }, { value: 'document', label: 'Document' }, ], }, ]} {...form.getInputProps('type')} comboboxProps={{ withinPortal: false }} /> {/* Show Options input for Select OR MultiSelect */} <When condition={['select', 'multiSelect'].includes(form.values.type)} > <TagsInput label="Options" placeholder="Press Enter to add option" description="Add choices for the selection list" {...form.getInputProps('options')} /> </When> <Group justify="flex-end" mt="xs"> <Button onClick={handleSubmit} size="xs"> {editingId ? 'Update' : 'Create'} </Button> </Group> </Stack> </When> <DataTable records={customFields} columns={[ { accessor: 'name', title: 'Name' }, { accessor: 'type', title: 'Type', width: 150 }, { accessor: 'actions', title: 'Actions', textAlign: 'right', width: 100, render: (field) => ( <Group gap={4} justify="flex-end" wrap="nowrap"> <Tooltip label="Edit"> <ActionIcon color="blue" variant="subtle" onClick={() => handleEdit(field)} > <Icon icon="tabler:edit" /> </ActionIcon> </Tooltip> <Tooltip label="Delete"> <ActionIcon color="red" variant="subtle" onClick={() => handleDelete(field)} > <Icon icon="tabler:trash" /> </ActionIcon> </Tooltip> </Group> ), }, ]} minHeight={150} noRecordsText="No custom fields yet." striped highlightOnHover /> </Stack> </Modal> ) } export default ModalCustomField \`\`\` # src/features/contacts/components/Modal/ModalImportContacts.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import ExcelUploader from '@/features/broadcast/components/Excel/ExcelUploader' import db from '@/libs/db' import toast from '@/utils/toast' import { Center, Stack, Text, Title } from '@mantine/core' import React from 'react' interface Props { opened: boolean onClose: () => void } const ModalImportContacts: React.FC<Props> = ({ opened, onClose }) => { const handleImport = async (data: any[]) => { if (!data.length) return let count = 0 try { await db.transaction('rw', db.contacts, async () => { for (const row of data) { const rawNumber = row.number?.toString().replace(/\D/g, '') if (!rawNumber) continue const number = rawNumber.includes('@c.us') ? rawNumber : `${rawNumber}@c.us` const existing = await db.contacts.where({ number }).first() if (!existing) { await db.contacts.add({ number, name: row.name?.toString() || number, }) count++ } } }) toast.success(`Imported ${count} new contacts.`) onClose() } catch (error) { console.error(error) toast.error('Failed to import contacts.') } } return ( <Modal opened={opened} onClose={onClose} withCloseButton w={500}> <Stack> <Center> <Title order={4}>Import Contacts</Title> </Center> <Text size="sm" c="dimmed" ta="center"> Upload an Excel/CSV file. Columns required: 'number', 'name'. </Text> <ExcelUploader onConfirm={handleImport} onClose={onClose} /> </Stack> </Modal> ) } export default ModalImportContacts \`\`\` # src/features/contacts/components/Modal/ModalSegmentBuilder.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import { evaluateSegment } from '@/features/contacts/helpers/segmentEvaluator' import db, { type SegmentRule, type SmartSegment } from '@/libs/db' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { ActionIcon, Badge, Box, Button, Divider, Group, NumberInput, Paper, SegmentedControl, Select, Stack, Text, TextInput, Title, Tooltip, } from '@mantine/core' import { DatePickerInput } from '@mantine/dates' import { useForm } from '@mantine/form' import { randomId, useDebouncedValue } from '@mantine/hooks' import { useLiveQuery } from 'dexie-react-hooks' import React, { useCallback, useEffect, useMemo, useState } from 'react' interface Props { opened: boolean onClose: () => void onSave: () => void editingSegment?: SmartSegment | null } const ModalSegmentBuilder: React.FC<Props> = ({ opened, onClose, onSave, editingSegment, }) => { // Fetch metadata for dropdowns const tags = useLiveQuery(() => db.tags.toArray(), []) || [] const customFields = useLiveQuery(() => db.customFields.toArray(), []) || [] // Estimated audience state const [estimatedCount, setEstimatedCount] = useState<number | null>(null) const [isCalculating, setIsCalculating] = useState(false) // Combine basic fields and custom fields into one options list with type info const fieldOptions = useMemo(() => { const basic = [ { value: 'name', label: 'Contact Name', type: 'text' }, { value: 'number', label: 'Phone Number', type: 'text' }, { value: 'tag', label: 'Has Tag', type: 'tag' }, ] const cfOptions = customFields.map((cf) => ({ value: `cf_${cf.id}`, label: `Field: ${cf.name}`, type: cf.type || 'text', // text, number, date, toggle })) return [...basic, ...cfOptions] }, [customFields]) // Helper to get field type const getFieldType = useCallback( (fieldValue: string) => { const field = fieldOptions.find((f) => f.value === fieldValue) return field?.type || 'text' }, [fieldOptions], ) const form = useForm({ initialValues: { name: '', logic: 'AND' as 'AND' | 'OR', rules: [ { field: 'name', operator: 'contains', value: '', key: randomId() }, ] as (SegmentRule & { key: string })[], }, validate: { name: (val) => val.trim().length === 0 ? 'Segment name is required' : null, rules: { value: (val, values, path) => { const index = parseInt(path.split('.')[1], 10) const rule = values.rules[index] if ( ['isEmpty', 'isNotEmpty'].includes(rule.operator) || rule.field === 'tag' || rule.value ) { return null } return 'Value required' }, }, }, }) // Debounce rules for calculation const [debouncedRules] = useDebouncedValue(form.values.rules, 500) const [debouncedLogic] = useDebouncedValue(form.values.logic, 500) // Calculate estimated audience whenever rules change useEffect(() => { const calculateAudience = async () => { if (!opened) return // Skip if no valid rules const hasValidRules = debouncedRules.some( (r) => ['isEmpty', 'isNotEmpty'].includes(r.operator) || r.field === 'tag' || r.value, ) if (!hasValidRules) { setEstimatedCount(null) return } setIsCalculating(true) try { const tempSegment: SmartSegment = { id: 0, name: 'temp', logic: debouncedLogic, rules: debouncedRules.map(({ key, ...r }) => r), createdAt: new Date(), } const results = await evaluateSegment(tempSegment) setEstimatedCount(results.length) } catch (error) { console.error('Error calculating audience:', error) setEstimatedCount(null) } finally { setIsCalculating(false) } } calculateAudience() }, [debouncedRules, debouncedLogic, opened]) // Populate form on open useEffect(() => { if (opened) { if (editingSegment) { form.setValues({ name: editingSegment.name, logic: editingSegment.logic, rules: editingSegment.rules.map((r) => ({ ...r, key: randomId() })), }) } else { form.reset() form.setValues({ name: '', logic: 'AND', rules: [ { field: 'name', operator: 'contains', value: '', key: randomId() }, ], }) } setEstimatedCount(null) } }, [opened, editingSegment]) const handleAddRule = () => { form.insertListItem('rules', { field: 'name', operator: 'contains', value: '', key: randomId(), }) } const handleDuplicateRule = (index: number) => { const ruleToDuplicate = form.values.rules[index] form.insertListItem('rules', { ...ruleToDuplicate, key: randomId(), }) } const handleClearRule = (index: number) => { form.setFieldValue(`rules.${index}.value`, '') } const handleSubmit = async (values: typeof form.values) => { try { const payload = { name: values.name, logic: values.logic, rules: values.rules.map(({ key, ...r }) => r), createdAt: new Date(), } if (editingSegment && editingSegment.id) { await db.smartSegments.update(editingSegment.id, payload) toast.success('Segment updated successfully') } else { await db.smartSegments.add(payload as SmartSegment) toast.success('Segment created successfully') } onSave() onClose() } catch (error) { console.error(error) toast.error('Failed to save segment') } } // Dynamic input renderer based on field type const renderRuleInput = (index: number) => { const rule = form.values.rules[index] const fieldType = getFieldType(rule.field) // No input needed for existence checks if (['isEmpty', 'isNotEmpty'].includes(rule.operator)) { return ( <Text size="sm" c="dimmed" style={{ flex: 1, alignSelf: 'center' }}> (No value needed) </Text> ) } // Tag Selector if (rule.field === 'tag') { return ( <Select placeholder="Select Tag" data={tags.map((t) => ({ value: t.name, label: t.name }))} {...form.getInputProps(`rules.${index}.value`)} searchable comboboxProps={{ withinPortal: false }} style={{ flex: 1 }} /> ) } // Date input for date fields if (fieldType === 'date') { const dateValue = rule.value ? new Date(rule.value) : null return ( <DatePickerInput placeholder="Select date" value={dateValue} // @ts-ignore - Mantine types can be inconsistent onChange={(val: any) => { const dateObj = val instanceof Date ? val : val ? new Date(val) : null form.setFieldValue( `rules.${index}.value`, dateObj?.toISOString() || '', ) }} style={{ flex: 1 }} popoverProps={{ withinPortal: false }} /> ) } // Toggle/boolean input if (fieldType === 'toggle') { return ( <SegmentedControl data={[ { value: 'true', label: 'Yes' }, { value: 'false', label: 'No' }, ]} value={rule.value?.toString() || 'true'} onChange={(val) => form.setFieldValue(`rules.${index}.value`, val)} style={{ flex: 1 }} /> ) } // Number input for number fields if (fieldType === 'number') { return ( <NumberInput placeholder="Value" value={rule.value ? parseFloat(rule.value) : undefined} onChange={(val) => form.setFieldValue(`rules.${index}.value`, val?.toString() || '') } style={{ flex: 1 }} /> ) } // Default Text Input return ( <TextInput placeholder="Value" {...form.getInputProps(`rules.${index}.value`)} style={{ flex: 1 }} /> ) } return ( <Modal opened={opened} onClose={onClose} withCloseButton w={750}> <form onSubmit={form.onSubmit(handleSubmit)}> <Stack gap="lg"> <Group justify="space-between"> <Title order={4}> {editingSegment ? 'Edit Smart Segment' : 'New Smart Segment'} </Title> </Group> {/* Header Controls */} <TextInput label="Segment Name" required {...form.getInputProps('name')} /> {/* Rules Builder */} <Stack gap={0} p="md" style={{ borderRadius: 8 }}> <Text size="sm" fw={500} c="dimmed" mb="sm"> Rules </Text> {form.values.rules.map((rule, index) => ( <Box key={rule.key}> {/* Visual Connector */} {index > 0 && ( <Divider my="xs" label={ <Badge size="sm" variant="light" color={form.values.logic === 'AND' ? 'blue' : 'orange'} > {form.values.logic} </Badge> } labelPosition="center" /> )} {/* Rule Row */} <Group align="center" wrap="nowrap"> <Select placeholder="Field" data={fieldOptions} {...form.getInputProps(`rules.${index}.field`)} w={180} size="sm" searchable comboboxProps={{ withinPortal: false }} /> <Select placeholder="Operator" data={[ { value: 'equals', label: 'Equals' }, { value: 'contains', label: 'Contains' }, { value: 'startsWith', label: 'Starts With' }, { value: 'greaterThan', label: 'Greater Than (>)' }, { value: 'lessThan', label: 'Less Than (<)' }, { value: 'isEmpty', label: 'Is Empty' }, { value: 'isNotEmpty', label: 'Is Not Empty' }, ]} {...form.getInputProps(`rules.${index}.operator`)} w={150} size="sm" comboboxProps={{ withinPortal: false }} /> {renderRuleInput(index)} {/* Actions */} <Group gap={4}> <Tooltip label="Duplicate rule"> <ActionIcon color="blue" variant="subtle" size="sm" onClick={() => handleDuplicateRule(index)} > <Icon icon="tabler:copy" /> </ActionIcon> </Tooltip> <Tooltip label="Delete rule"> <ActionIcon color="red" variant="subtle" size="sm" onClick={() => form.removeListItem('rules', index)} disabled={form.values.rules.length === 1} > <Icon icon="tabler:trash" /> </ActionIcon> </Tooltip> </Group> </Group> </Box> ))} <Button variant="light" size="xs" leftSection={<Icon icon="tabler:plus" />} onClick={handleAddRule} mt="sm" > Add Rule </Button> </Stack> {/* Estimated Audience */} <Box p="sm" radius="md"> <Group justify="space-between"> <Group gap="xs"> <Icon icon="tabler:users" fontSize={18} /> <Text size="sm" fw={500}> Estimated Audience </Text> </Group> {isCalculating ? ( <Badge color="gray" variant="light"> Calculating... </Badge> ) : estimatedCount !== null ? ( <Badge color="teal" variant="filled" size="lg"> {estimatedCount} contacts </Badge> ) : ( <Badge color="gray" variant="light"> Add rules to calculate </Badge> )} </Group> </Box> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button type="submit" color="teal"> Save Segment </Button> </Group> </Stack> </form> </Modal> ) } export default ModalSegmentBuilder \`\`\` # src/features/contacts/components/Tabs/TabNotes.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import ContactNoteModel from '@/features/contacts/models/ContactNoteModel' import db from '@/libs/db' import type { Contact } from '@/libs/db' import confirm from '@/utils/confirm' import { Icon } from '@iconify/react' import { ActionIcon, Button, Group, Stack, Text, Textarea, Timeline, Title, Tooltip, } from '@mantine/core' import { useForm } from '@mantine/form' import { useDisclosure } from '@mantine/hooks' import dayjs from 'dayjs' import { useLiveQuery } from 'dexie-react-hooks' import React from 'react' interface Props { contactInfo: Contact } const TabNotes: React.FC<Props> = ({ contactInfo }) => { const [opened, { open, close }] = useDisclosure(false) const notes = useLiveQuery( () => contactInfo.id ? ContactNoteModel.getByContactId(contactInfo.id) : [], [contactInfo], ) const form = useForm({ initialValues: { content: '' }, validate: { content: (value) => (value.trim() ? null : 'Required'), }, }) const handleSubmit = async (values: { content: string }) => { if (contactInfo.id) { await ContactNoteModel.add(contactInfo.id, values.content) form.reset() close() } } const handleDelete = async (noteId: number) => { if ( await confirm.danger( 'Delete Note', 'Are you sure you want to delete this note?', ) ) { await db.contactNotes.delete(noteId) } } return ( <Stack> <Group justify="flex-end"> <Button size="xs" leftSection={<Icon icon="tabler:plus" />} onClick={open} variant="light" > Add Note </Button> </Group> <Timeline active={-1} bulletSize={24} lineWidth={2}> {notes?.map((note) => ( <Timeline.Item key={note.id} bullet={<Icon icon="tabler:note" fontSize={14} />} title={ <Group justify="space-between"> <Text c="dimmed" size="xs"> {dayjs(note.createdAt).format('DD MMM YYYY, HH:mm')} </Text> <Tooltip label="Delete Note"> <ActionIcon color="red" variant="subtle" size="xs" onClick={() => handleDelete(note.id)} > <Icon icon="tabler:trash" fontSize={14} /> </ActionIcon> </Tooltip> </Group> } > <Text size="sm" mt={4} style={{ whiteSpace: 'pre-wrap' }}> {note.content} </Text> </Timeline.Item> ))} </Timeline> <Modal opened={opened} onClose={close} w={500} withCloseButton> <Stack> <Title order={4}>New Note</Title> <Textarea placeholder="Write interaction notes here..." minRows={4} autosize data-autofocus {...form.getInputProps('content')} /> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={close}> Cancel </Button> <Button onClick={() => { form.onSubmit(handleSubmit)() }} > Save Note </Button> </Group> </Stack> </Modal> </Stack> ) } export default TabNotes \`\`\` # src/features/contacts/components/Tabs/TabProfile.tsx \`\`\`tsx import CustomFieldModel from '@/features/contacts/models/CustomFieldModel' import TagModel from '@/features/contacts/models/TagModel' import { type Contact } from '@/libs/db' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { Button, Group, Stack, TagsInput, // -- CHANGED: Use TagsInput instead of MultiSelect TextInput, Tooltip, } from '@mantine/core' import { useForm } from '@mantine/form' import { useDisclosure } from '@mantine/hooks' import { useLiveQuery } from 'dexie-react-hooks' import React, { useEffect, useState } from 'react' import CustomFieldRenderer from '../CustomFieldRenderer' import ModalCustomField from '../Modal/ModalCustomField' interface Props { contactInfo: Contact } const TabProfile: React.FC<Props> = ({ contactInfo }) => { const [showModal, modalHandlers] = useDisclosure(false) // State for tags const [selectedTags, setSelectedTags] = useState<string[]>([]) const customFields = useLiveQuery( () => contactInfo.id ? CustomFieldModel.getByContactId(contactInfo.id) : [], [contactInfo], ) // Fetch available tags and current contact's tags const allTags = useLiveQuery(() => TagModel.getAll(), []) const contactTags = useLiveQuery( () => (contactInfo.id ? TagModel.getByContactId(contactInfo.id) : []), [contactInfo], ) const form = useForm({ initialValues: { name: '', number: '', customFields: [], }, }) useEffect(() => { form.setValues({ name: contactInfo.name || '', number: contactInfo.number?.split('@')[0] || '', }) }, [contactInfo]) useEffect(() => { if (customFields) { form.setFieldValue('customFields', customFields) } }, [customFields]) // Sync tags state when database returns data useEffect(() => { if (contactTags) { setSelectedTags(contactTags.map((t) => t.name)) } }, [contactTags]) // Handle Tag Change (Auto-save) const handleTagChange = async (tags: string[]) => { setSelectedTags(tags) if (contactInfo.id) { try { await TagModel.updateContactTags(contactInfo.id, tags) } catch (error) { toast.error('Failed to update tags') } } } const handleUpdateValue = async ( contactId: number, customFieldId: number, value: any, ) => { await CustomFieldModel.updateValue(contactId, customFieldId, value) } return ( <Stack> <Group justify="flex-end"> <Tooltip label="Add or edit custom fields" withArrow> <Button size="xs" variant="outline" onClick={modalHandlers.open}> Manage Fields </Button> </Tooltip> </Group> <TextInput label="Name" disabled size="sm" readOnly {...form.getInputProps('name')} /> <TextInput label="Number" size="sm" disabled readOnly {...form.getInputProps('number')} /> {/* -- CHANGED: Using TagsInput for creatable functionality -- */} <TagsInput label="Tags" placeholder="Press Enter to create a new tag" data={allTags?.map((t) => t.name) || []} value={selectedTags} onChange={handleTagChange} splitChars={[',', ' ']} // Optional: allows splitting by comma or space /> {customFields?.map((field, index) => ( <CustomFieldRenderer key={field.id} field={field} index={index} form={form} contactId={contactInfo.id!} onValueChange={handleUpdateValue} /> ))} <ModalCustomField opened={showModal} onClose={modalHandlers.close} /> </Stack> ) } export default TabProfile \`\`\` # src/features/contacts/components/Tabs/TabScheduler.tsx \`\`\`tsx import MessageType from '@/features/broadcast/components/Datatable/MessageType' import ModalScheduleMessage from '@/features/schedule-message/components/ModalScheduleMessage' import ScheduledMessageModel from '@/features/schedule-message/models/ScheduledMessageModel' import { type Contact, type ScheduledMessage } from '@/libs/db' import confirm from '@/utils/confirm' import toast from '@/utils/toast' import { truncate } from '@/utils/util' import { Icon } from '@iconify/react' import { ActionIcon, Badge, Center, Group, Stack, Text, Timeline, Tooltip, } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import dayjs from 'dayjs' import { useLiveQuery } from 'dexie-react-hooks' import React, { useState } from 'react' import { When } from 'react-if' interface Props { contactInfo: Contact } const TabScheduler: React.FC<Props> = ({ contactInfo }) => { const [editingItem, setEditingItem] = useState<ScheduledMessage | null>(null) const [showModal, modalHandlers] = useDisclosure(false) const scheduledMessages = useLiveQuery( () => contactInfo.number ? ScheduledMessageModel.getByChatId(contactInfo.number) : [], [contactInfo], ) const handleDelete = async (id: number) => { const isConfirmed = await confirm.danger( 'Delete Message', 'Are you sure you want to delete this message? This action is irreversible.', ) if (isConfirmed) { try { await ScheduledMessageModel.deleteById(id) toast.success('Message deleted.') } catch (error) { console.error(error) toast.error('Failed to delete message.') } } } const handleEdit = (item: ScheduledMessage) => { setEditingItem(item) modalHandlers.open() } const handleModalClose = () => { setEditingItem(null) modalHandlers.close() } const getStatusColor = (status: string) => { switch (status) { case 'PENDING': return 'blue' case 'RUNNING': return 'yellow' case 'SUCCESS': return 'green' case 'FAILED': return 'red' default: return 'gray' } } const renderContentPreview = (msg: any) => { if (typeof msg.message === 'string') return msg.message if (msg.message?.caption) return msg.message.caption if (msg.message?.name) return `Poll: ${msg.message.name}` return 'Media/Attachment' } if (!scheduledMessages || scheduledMessages.length === 0) { return ( <Center h={200}> <Stack align="center" gap="xs"> <Icon icon="tabler:calendar-time" fontSize={40} color="var(--mantine-color-dimmed)" /> <Text c="dimmed" size="sm"> No scheduled messages found. </Text> </Stack> </Center> ) } return ( <> <Stack mt="md"> <Timeline active={-1} bulletSize={32} lineWidth={2}> {scheduledMessages.map((item) => ( <Timeline.Item key={item.id} bullet={ <Icon icon="tabler:clock" fontSize={18} style={{ color: '#fff' }} /> } color={getStatusColor(item.status)} title={ <Group justify="space-between" align="center"> <Badge color={getStatusColor(item.status)} variant="light" size="sm" > {item.status} </Badge> <Group gap={4}> {/* EDIT BUTTON */} {/* Only allow editing if not running and not successfully sent (unless you want to allow resending/cloning logic which acts as update) */} <Tooltip label="Edit Schedule"> <ActionIcon color="blue" variant="subtle" size="sm" onClick={() => handleEdit(item)} disabled={ item.status === 'RUNNING' || item.status === 'SUCCESS' } > <Icon icon="tabler:edit" fontSize={16} /> </ActionIcon> </Tooltip> {/* DELETE BUTTON */} {/* Allow deleting Sent (History) and Pending messages */} <Tooltip label="Delete"> <ActionIcon color="red" variant="subtle" size="sm" onClick={() => handleDelete(item.id)} disabled={item.status === 'RUNNING'} > <Icon icon="tabler:trash" fontSize={16} /> </ActionIcon> </Tooltip> </Group> </Group> } > <Stack gap={4} mt={4}> <Group gap={8}> <Text size="xs" c="dimmed"> {item.status === 'SUCCESS' ? 'Sent at:' : 'Scheduled for:'} </Text> <Text size="xs" fw={600}> {dayjs(item.scheduledAt).format('DD MMM YYYY, HH:mm')} </Text> </Group> <Group gap="xs" align="center" mb={4}> <MessageType type={item.type} /> </Group> <Text size="sm" style={{ whiteSpace: 'pre-wrap' }}> {truncate(renderContentPreview(item), 100)} </Text> <When condition={item.error}> <Text c="red" size="xs" mt={4}> Error: {item.error} </Text> </When> </Stack> </Timeline.Item> ))} </Timeline> </Stack> {/* Reusing the Modal for Editing */} <ModalScheduleMessage opened={showModal} onClose={handleModalClose} chat={{ id: { _serialized: contactInfo.number } }} // Passing ID context data={editingItem} // Passing data triggers Edit Mode /> </> ) } export default TabScheduler \`\`\` # src/features/contacts/helpers/segmentEvaluator.ts \`\`\`ts import db, { type Contact, type SegmentRule, type SmartSegment, } from '@/libs/db' import _ from 'lodash' /** * Helper to retrieve the value of a specific custom field for a contact. * It searches within the pre-fetched array of all contact fields. */ const getCustomFieldValue = ( contactCustomFields: any[], contactId: number, fieldId: number, ) => { const record = contactCustomFields.find( (f) => f.contactId === contactId && f.customFieldId === fieldId, ) return record ? record.value : null } /** * Helper to check if a contact has a specific tag assigned. */ const hasTag = (contactTags: any[], contactId: number, tagName: string) => { return contactTags.some( (ct) => ct.contactId === contactId && ct.tagName?.toLowerCase() === tagName.toLowerCase(), ) } /** * Evaluates a Smart Segment against the database. * Returns an array of Contacts that match the segment's rules. * * Strategy: Eager Loading. * Since IndexedDB is local and fast, we fetch all contacts and relations first, * then filter them in memory using JavaScript. This avoids N+1 query issues. */ export const evaluateSegment = async ( segment: SmartSegment, ): Promise<Contact[]> => { // 1. Fetch all required data const contacts = await db.contacts.toArray() const contactTagsRaw = await db.contactTags.toArray() const tags = await db.tags.toArray() const contactFields = await db.contactCustomFields.toArray() // 2. Map Tag Names to ContactTags for easier lookup const contactTags = contactTagsRaw.map((ct) => ({ ...ct, tagName: tags.find((t) => t.id === ct.tagId)?.name || '', })) // 3. Filter Contacts return contacts.filter((contact) => { if (!contact.id) return false // Function to check a single rule const checkRule = (rule: SegmentRule): boolean => { let dataValue: any // A. Extract Data Value if (rule.field === 'name') { dataValue = contact.name } else if (rule.field === 'number') { dataValue = contact.number } else if (rule.field === 'tag') { // Special logic for Tags: check existence const exists = hasTag(contactTags, contact.id!, rule.value) // If operator is isEmpty, it means "Does NOT have tag" if (rule.operator === 'isEmpty') return !exists // If operator is isNotEmpty, it means "HAS tag" if (rule.operator === 'isNotEmpty') return exists // Standard check (equals/contains implies "Has Tag" matching value) return exists } else if (rule.field.startsWith('cf_')) { // Handle Custom Fields (e.g. 'cf_15') const cfId = parseInt(rule.field.replace('cf_', ''), 10) dataValue = getCustomFieldValue(contactFields, contact.id!, cfId) } // B. Evaluate Operator // Handle Empty/Not Empty checks regardless of value type if (rule.operator === 'isEmpty') { return dataValue === '' || dataValue === null || dataValue === undefined } if (rule.operator === 'isNotEmpty') { return dataValue !== '' && dataValue !== null && dataValue !== undefined } // For other operators, null data fails immediately if (dataValue === null || dataValue === undefined) return false const valString = String(dataValue).toLowerCase() const ruleValString = String(rule.value).toLowerCase() switch (rule.operator) { case 'equals': return valString === ruleValString case 'contains': return valString.includes(ruleValString) case 'startsWith': return valString.startsWith(ruleValString) case 'greaterThan': // Numeric comparison return parseFloat(dataValue) > parseFloat(rule.value) case 'lessThan': // Numeric comparison return parseFloat(dataValue) < parseFloat(rule.value) default: return false } } // 4. Apply Logic (AND / OR) if (segment.rules.length === 0) return true // Default to match all if no rules if (segment.logic === 'AND') { return segment.rules.every(checkRule) } else { return segment.rules.some(checkRule) } }) } \`\`\` # src/features/contacts/models/ContactNoteModel.ts \`\`\`ts import db from '@/libs/db' const add = async (contactId: number, content: string) => { if (!contactId || !content.trim()) return await db.contactNotes.add({ contactId, content, createdAt: new Date(), }) } const getByContactId = async (contactId: number) => { return await db.contactNotes.where({ contactId }).reverse().toArray() } export default { add, getByContactId } \`\`\` # src/features/contacts/models/CustomFieldModel.ts \`\`\`ts import db, { type CustomField } from '@/libs/db' // ++ ADDED: Helper to get all fields const getAll = async () => { return await db.customFields.toArray() } // ... existing code ... const add = async (name: string, type: string, config?: any) => { const customFieldId = await db.customFields.add({ name, type, config: config || {}, }) const contacts = await db.contacts.toArray() const contactCustomFields = contacts.map((contact) => ({ contactId: contact.id, customFieldId, value: type === 'toggle' ? false : null, })) await db.contactCustomFields.bulkAdd(contactCustomFields) return customFieldId } const getByContactId = async (contactId: number) => { const customFields = await db.customFields.toArray() const contactCustomFields = await db.contactCustomFields .where({ contactId }) .toArray() return customFields.map((field) => ({ ...field, value: contactCustomFields.find((c) => c.customFieldId === field.id)?.value ?? (field.type === 'toggle' ? false : null), })) } const updateValue = async ( contactId: number, customFieldId: number, value: any, ) => { const existing = await db.contactCustomFields .where({ contactId, customFieldId }) .first() let valueToStore = value if (value instanceof Date) { valueToStore = value.toISOString() } if (existing) { await db.contactCustomFields.update(existing.id, { value: valueToStore }) } else { await db.contactCustomFields.add({ contactId, customFieldId, value: valueToStore, }) } } const getValue = async ( contactId: number, customFieldId: number, ): Promise<string | null> => { const existing = await db.contactCustomFields .where({ contactId, customFieldId }) .first() return existing?.value != null ? String(existing.value) : null } const update = async (id: number, data: Partial<CustomField>) => { await db.customFields.update(id, data) } const deleteById = async (customFieldId: number) => { await db.transaction( 'rw', db.customFields, db.contactCustomFields, async () => { await db.contactCustomFields.where({ customFieldId }).delete() await db.customFields.delete(customFieldId) }, ) } export default { add, getByContactId, updateValue, getValue, update, deleteById, getAll, } \`\`\` # src/features/contacts/models/TagModel.tsx \`\`\`tsx import db from '@/libs/db' import _ from 'lodash' const getRandomColor = () => { const colors = [ 'red', 'pink', 'grape', 'violet', 'indigo', 'blue', 'cyan', 'teal', 'green', 'lime', 'yellow', 'orange', ] return colors[Math.floor(Math.random() * colors.length)] } const getAll = async () => { return await db.tags.toArray() } const createOrGet = async (tagName: string) => { const existing = await db.tags.where({ name: tagName }).first() if (existing) return existing const id = await db.tags.add({ name: tagName, color: getRandomColor(), }) return await db.tags.get(id) } const getByContactId = async (contactId: number) => { const links = await db.contactTags.where({ contactId }).toArray() const tagIds = links.map((link) => link.tagId) return await db.tags.where('id').anyOf(tagIds).toArray() } const updateContactTags = async (contactId: number, tagNames: string[]) => { await db.transaction('rw', db.tags, db.contactTags, async () => { // 1. Ensure tags exist const tagIds: number[] = [] for (const name of tagNames) { const tag = await createOrGet(name) if (tag && tag.id) tagIds.push(tag.id) } // 2. Remove old links const existingLinks = await db.contactTags.where({ contactId }).toArray() const linksToRemove = existingLinks.filter( (link) => !tagIds.includes(link.tagId), ) const linkIdsToRemove = linksToRemove.map((l) => l.id) if (linkIdsToRemove.length > 0) { await db.contactTags.bulkDelete(linkIdsToRemove) } // 3. Add new links const existingTagIds = existingLinks.map((l) => l.tagId) const newTagIds = tagIds.filter((id) => !existingTagIds.includes(id)) if (newTagIds.length > 0) { await db.contactTags.bulkAdd( newTagIds.map((tagId) => ({ contactId, tagId })), ) } }) } const getRecipientsByTagIds = async (tagIds: number[]) => { const links = await db.contactTags.where('tagId').anyOf(tagIds).toArray() const contactIds = _.uniq(links.map((l) => l.contactId)) const contacts = await db.contacts.where('id').anyOf(contactIds).toArray() return contacts.map((c) => ({ name: c.name || 'Unknown', number: c.number || '', source: 'Tag', })) } const getContactCountByTagId = async (tagId: number) => { return await db.contactTags.where({ tagId }).count() } const getContactCountsForTags = async (tagIds: number[]) => { const counts: Record<number, number> = {} for (const tagId of tagIds) { counts[tagId] = await db.contactTags.where({ tagId }).count() } return counts } export default { getAll, createOrGet, getByContactId, updateContactTags, getRecipientsByTagIds, getContactCountByTagId, getContactCountsForTags, } \`\`\` # src/features/contacts/PageContactInfo.tsx \`\`\`tsx import LayoutPage from '@/components/Layout/LayoutPage' import useWa from '@/hooks/useWa' import db from '@/libs/db' import { useAppStore } from '@/stores/app' import { truncate } from '@/utils/util' import { Icon } from '@iconify/react' import { Center, Loader, SegmentedControl, Stack, Text } from '@mantine/core' import { useLiveQuery } from 'dexie-react-hooks' import _ from 'lodash' import React, { useState } from 'react' import TabNotes from './components/Tabs/TabNotes' import TabProfile from './components/Tabs/TabProfile' // ++ ADDED Import import TabScheduler from './components/Tabs/TabScheduler' const PageContactInfo: React.FC = () => { const { activeChat } = useWa() const { selectedContact } = useAppStore() const [activeTab, setActiveTab] = useState('profile') const contactInfo = useLiveQuery(async () => { // 1. Determine which contact to look for let targetNumber = '' let targetName = '' if (selectedContact && selectedContact.number) { targetNumber = selectedContact.number targetName = selectedContact.name } else if (!_.isEmpty(activeChat) && activeChat.number) { targetNumber = activeChat.number targetName = activeChat.name || activeChat.formattedTitle } else { return null } // 2. Normalize Number const number = targetNumber.includes('@c.us') ? targetNumber : `${targetNumber}@c.us` // 3. Fetch from DB let contact = await db.contacts.where({ number }).first() // 4. Create if not exists if (!contact) { try { const newId = await db.contacts.add({ name: targetName || number, number: number, }) // Initialize custom fields const fields = await db.customFields.toArray() if (fields.length > 0) { await db.contactCustomFields.bulkAdd( fields.map((f) => ({ contactId: newId as number, customFieldId: f.id, value: f.type === 'toggle' ? false : null, })), ) } contact = await db.contacts.get(newId) } catch (e) { console.error('Error creating contact:', e) return null } } return contact }, [activeChat, selectedContact]) if (!contactInfo) { return ( <LayoutPage title="Contact Info" width={450}> <Center h="50vh"> <Loader /> </Center> </LayoutPage> ) } const renderContent = () => { switch (activeTab) { case 'profile': return <TabProfile contactInfo={contactInfo} /> case 'scheduler': return <TabScheduler contactInfo={contactInfo} /> case 'notes': return <TabNotes contactInfo={contactInfo} /> default: return null } } return ( <LayoutPage title={truncate(contactInfo.name, 15) || 'Contact Info'} width={450} icon={<Icon icon="tabler:user-circle" fontSize={24} color="#34d399" />} > <Stack gap="md"> <SegmentedControl value={activeTab} onChange={setActiveTab} fullWidth radius="md" data={[ { value: 'profile', label: ( <Center> <Icon icon="tabler:user" style={{ marginRight: 8 }} /> <Text size="sm">Profile</Text> </Center> ), }, { value: 'scheduler', label: ( <Center> <Icon icon="tabler:clock" style={{ marginRight: 8 }} /> <Text size="sm">Scheduler</Text> </Center> ), }, { value: 'notes', label: ( <Center> <Icon icon="tabler:note" style={{ marginRight: 8 }} /> <Text size="sm">Notes</Text> </Center> ), }, // ++ ADDED Tab Item ]} /> {renderContent()} </Stack> </LayoutPage> ) } export default PageContactInfo \`\`\` # src/features/contacts/PageContacts.tsx \`\`\`tsx import AlertBanner from '@/components/AlertBanner' import LayoutPage from '@/components/Layout/LayoutPage' import { Action } from '@/constants' import { evaluateSegment } from '@/features/contacts/helpers/segmentEvaluator' import useFile from '@/hooks/useFile' import db, { type Contact, type SegmentRule, type SmartSegment, } from '@/libs/db' import confirm from '@/utils/confirm' import toast from '@/utils/toast' import { postMessage } from '@/utils/util' import { Icon } from '@iconify/react' import { ActionIcon, Anchor, Badge, Box, Button, Checkbox, Collapse, CopyButton, Divider, Group, Menu, NumberInput, Rating, ScrollArea, SegmentedControl, Select, Stack, Text, TextInput, Tooltip, } from '@mantine/core' import { DatePickerInput } from '@mantine/dates' import { randomId, useDebouncedValue, useDisclosure } from '@mantine/hooks' import dayjs from 'dayjs' import { useLiveQuery } from 'dexie-react-hooks' import { DataTable } from 'mantine-datatable' import React, { useCallback, useEffect, useMemo, useState } from 'react' interface FilterRule extends SegmentRule { key: string } const PageContacts: React.FC = () => { const fileExporter = useFile() const [isExporting, setIsExporting] = useState(false) const [showFilters, { toggle: toggleFilters }] = useDisclosure(false) // -- Pagination State -- const [page, setPage] = useState(1) const [search, setSearch] = useState('') const pageSize = 15 // -- Filter State (Inline Rule Builder) -- const [filterLogic, setFilterLogic] = useState<'AND' | 'OR'>('AND') const [filterRules, setFilterRules] = useState<FilterRule[]>([]) // -- Column Visibility State -- const [hiddenColumns, setHiddenColumns] = useState<Set<string>>(new Set()) // -- Filtered Data State -- const [filteredContactIds, setFilteredContactIds] = useState<number[] | null>( null, ) // 1. Fetch Metadata (Tags & Fields) const allCustomFields = useLiveQuery(() => db.customFields.toArray(), []) || [] const allTags = useLiveQuery(() => db.tags.toArray(), []) || [] // Field options for rule builder const fieldOptions = useMemo(() => { const basic = [ { value: 'name', label: 'Contact Name', type: 'text' }, { value: 'number', label: 'Phone Number', type: 'text' }, { value: 'tag', label: 'Has Tag', type: 'tag' }, ] const cfOptions = allCustomFields.map((cf) => ({ value: `cf_${cf.id}`, label: `Field: ${cf.name}`, type: cf.type || 'text', })) return [...basic, ...cfOptions] }, [allCustomFields]) const getFieldType = useCallback( (fieldValue: string) => { const field = fieldOptions.find((f) => f.value === fieldValue) return field?.type || 'text' }, [fieldOptions], ) // Debounce filter rules for evaluation const [debouncedRules] = useDebouncedValue(filterRules, 300) const [debouncedLogic] = useDebouncedValue(filterLogic, 300) const [debouncedSearch] = useDebouncedValue(search, 300) // 2. Evaluate filters when rules change useEffect(() => { const applyFilters = async () => { // If no rules, clear filter if (debouncedRules.length === 0) { setFilteredContactIds(null) return } // Check if any rules have values (or are isEmpty/isNotEmpty operators) const hasValidRules = debouncedRules.some( (r) => ['isEmpty', 'isNotEmpty'].includes(r.operator) || r.field === 'tag' || r.value, ) if (!hasValidRules) { setFilteredContactIds(null) return } try { const tempSegment: SmartSegment = { id: 0, name: 'temp', logic: debouncedLogic, rules: debouncedRules.map(({ key, ...r }) => r), createdAt: new Date(), } const results = await evaluateSegment(tempSegment) setFilteredContactIds(results.map((c) => c.id!)) setPage(1) // Reset to first page } catch (error) { console.error('Error evaluating filter:', error) setFilteredContactIds(null) } } applyFilters() }, [debouncedRules, debouncedLogic]) // 3. Main Data Query with filters const allContacts = useLiveQuery(() => db.contacts.toArray(), []) || [] const filteredData = useMemo(() => { let data = allContacts // Apply segment filter if (filteredContactIds !== null) { const idSet = new Set(filteredContactIds) data = data.filter((c) => idSet.has(c.id!)) } // Apply search if (debouncedSearch) { const searchLower = debouncedSearch.toLowerCase() data = data.filter((c) => c.name?.toLowerCase().includes(searchLower)) } // Sort by name data.sort((a, b) => (a.name || '').localeCompare(b.name || '')) return data }, [allContacts, filteredContactIds, debouncedSearch]) // Paginate const paginatedData = useMemo(() => { const start = (page - 1) * pageSize return filteredData.slice(start, start + pageSize) }, [filteredData, page, pageSize]) // 4. Resolve relations for Visible rows const visibleContactIds = useMemo(() => { return paginatedData.map((c) => c.id!) || [] }, [paginatedData]) const visibleFieldValues = useLiveQuery(async () => { if (visibleContactIds.length === 0) return [] return await db.contactCustomFields .where('contactId') .anyOf(visibleContactIds) .toArray() }, [visibleContactIds]) || [] const visibleContactTags = useLiveQuery(async () => { if (visibleContactIds.length === 0) return [] return await db.contactTags .where('contactId') .anyOf(visibleContactIds) .toArray() }, [visibleContactIds]) || [] // 5. Merge Data for Display const processedData = useMemo(() => { return paginatedData.map((contact) => { const fieldValues: Record<string, any> = {} visibleFieldValues .filter((v) => v.contactId === contact.id) .forEach((v) => { fieldValues[`cf_${v.customFieldId}`] = v.value }) const tagIds = visibleContactTags .filter((ct) => ct.contactId === contact.id) .map((ct) => ct.tagId) const tags = allTags.filter((t) => tagIds.includes(t.id)) return { ...contact, ...fieldValues, tags, } }) }, [paginatedData, visibleFieldValues, visibleContactTags, allTags]) // 6. Rule Builder Handlers const handleAddRule = () => { setFilterRules((prev) => [ ...prev, { field: 'name', operator: 'contains', value: '', key: randomId() }, ]) } const handleRemoveRule = (index: number) => { setFilterRules((prev) => prev.filter((_, i) => i !== index)) } const handleRuleChange = (index: number, field: string, value: any) => { setFilterRules((prev) => prev.map((r, i) => (i === index ? { ...r, [field]: value } : r)), ) } const handleClearFilters = () => { setFilterRules([]) setFilterLogic('AND') } // 7. Handle Export const handleExport = async (format: 'csv' | 'xlsx') => { setIsExporting(true) try { const contacts = filteredData if (contacts.length === 0) { toast.warning('No contacts to export') setIsExporting(false) return } const [customFields, contactCustomFields, tags, contactTags] = await Promise.all([ db.customFields.toArray(), db.contactCustomFields.toArray(), db.tags.toArray(), db.contactTags.toArray(), ]) const exportData = contacts.map((contact) => { const row: any = { Name: contact.name, Number: contact.number?.split('@')[0], } const myTagIds = contactTags .filter((ct) => ct.contactId === contact.id) .map((ct) => ct.tagId) const myTags = tags .filter((t) => myTagIds.includes(t.id)) .map((t) => t.name) .join(', ') row['Tags'] = myTags customFields.forEach((cf) => { const val = contactCustomFields.find( (ccf) => ccf.contactId === contact.id && ccf.customFieldId === cf.id, ) if (val) { if (val.value instanceof Date) { row[cf.name] = dayjs(val.value).format('YYYY-MM-DD') } else if (typeof val.value === 'boolean') { row[cf.name] = val.value ? 'Yes' : 'No' } else if (val.value instanceof File || val.value instanceof Blob) { row[cf.name] = '[File]' } else { row[cf.name] = val.value } } else { row[cf.name] = '' } }) return row }) const filename = `Contacts_${dayjs().format('YYYYMMDD_HHmm')}` await fileExporter.saveAs(format, exportData, filename) } catch (error) { console.error('Export failed', error) } finally { setIsExporting(false) } } // 8. Render Rule Input based on field type const renderRuleInput = (rule: FilterRule, index: number) => { const fieldType = getFieldType(rule.field) if (['isEmpty', 'isNotEmpty'].includes(rule.operator)) { return ( <Text size="sm" c="dimmed" style={{ flex: 1, alignSelf: 'center' }}> (No value needed) </Text> ) } if (rule.field === 'tag') { return ( <Select placeholder="Select Tag" data={allTags.map((t) => ({ value: t.name, label: t.name }))} value={rule.value} onChange={(val) => handleRuleChange(index, 'value', val)} searchable size="xs" style={{ flex: 1 }} /> ) } if (fieldType === 'date') { const dateValue = rule.value ? new Date(rule.value) : null return ( <DatePickerInput placeholder="Select date" value={dateValue} onChange={(val: any) => { const dateObj = val instanceof Date ? val : val ? new Date(val) : null handleRuleChange(index, 'value', dateObj?.toISOString() || '') }} size="xs" style={{ flex: 1 }} /> ) } if (fieldType === 'toggle') { return ( <SegmentedControl data={[ { value: 'true', label: 'Yes' }, { value: 'false', label: 'No' }, ]} value={rule.value?.toString() || 'true'} onChange={(val) => handleRuleChange(index, 'value', val)} size="xs" style={{ flex: 1 }} /> ) } if (fieldType === 'number') { return ( <NumberInput placeholder="Value" value={rule.value ? parseFloat(rule.value) : undefined} onChange={(val) => handleRuleChange(index, 'value', val?.toString() || '') } size="xs" style={{ flex: 1 }} /> ) } return ( <TextInput placeholder="Value" value={rule.value || ''} onChange={(e) => handleRuleChange(index, 'value', e.currentTarget.value) } size="xs" style={{ flex: 1 }} /> ) } // 9. Define Columns const columns = useMemo(() => { const baseCols: any[] = [ { accessor: 'name', title: 'Name', sortable: true, width: 180, id: 'name', }, { accessor: 'number', title: 'Number', sortable: true, width: 180, id: 'number', render: (r: any) => { const phoneNumber = r.number?.split('@')[0] if (!phoneNumber) return ( <Text size="xs" c="dimmed"> - </Text> ) return ( <Group gap={4} wrap="nowrap"> <Text size="sm">{phoneNumber}</Text> <CopyButton value={phoneNumber}> {({ copied, copy }) => ( <Tooltip label={copied ? 'Copied!' : 'Copy'}> <ActionIcon size="xs" variant="subtle" color={copied ? 'emerald' : 'gray'} onClick={(e) => { e.stopPropagation() copy() }} > <Icon icon={copied ? 'tabler:check' : 'tabler:copy'} fontSize={14} /> </ActionIcon> </Tooltip> )} </CopyButton> </Group> ) }, }, { accessor: 'tags', title: 'Tags', width: 200, id: 'tags', render: (r: any) => { if (!r.tags || r.tags.length === 0) { return ( <Text size="xs" c="dimmed"> - </Text> ) } const visibleTags = r.tags.slice(0, 2) const remainingTags = r.tags.slice(2) const hasMore = remainingTags.length > 0 return ( <Group gap={4}> {visibleTags.map((tag: any) => ( <Badge key={tag.id} variant="light" size="xs" color={tag.color || 'gray'} style={{ textTransform: 'none' }} > {tag.name} </Badge> ))} {hasMore && ( <Tooltip label={ <Stack gap={2}> {remainingTags.map((tag: any) => ( <Text key={tag.id} size="xs"> {tag.name} </Text> ))} </Stack> } position="top" withArrow > <Badge variant="outline" size="xs" color="gray" style={{ cursor: 'pointer' }} > +{remainingTags.length} </Badge> </Tooltip> )} </Group> ) }, }, ] const fieldCols = allCustomFields.map((cf) => ({ accessor: `cf_${cf.id}`, title: cf.name, width: 150, id: `cf_${cf.id}`, render: (r: any) => { const val = r[`cf_${cf.id}`] if (cf.type === 'rating') return <Rating value={Number(val) || 0} readOnly size="xs" /> if (cf.type === 'toggle') return val ? 'Yes' : 'No' if (val instanceof Date) return val.toLocaleDateString() if (cf.type === 'url' && val) { return ( <Anchor href={ String(val).startsWith('http') ? String(val) : `https://${val}` } target="_blank" size="sm" onClick={(e) => e.stopPropagation()} > <Group gap={4} wrap="nowrap"> <Icon icon="tabler:link" fontSize={14} /> <Text size="sm" truncate maw={120}> Link </Text> </Group> </Anchor> ) } if ( (cf.type === 'image' || cf.type === 'document') && val instanceof File ) { return ( <Group gap={4} wrap="nowrap" c="dimmed" style={{ opacity: 0.8 }}> <Icon icon={cf.type === 'image' ? 'tabler:photo' : 'tabler:file'} fontSize={16} /> <Text size="sm" truncate maw={120}> {val.name} </Text> </Group> ) } if (cf.type === 'multiSelect' && Array.isArray(val)) { return ( <Group gap={4}> {val.map((item: string, idx: number) => ( <Badge key={idx} variant="outline" size="xs" color="gray"> {item} </Badge> ))} </Group> ) } return typeof val === 'object' && val !== null ? '-' : val || '-' }, })) const actionCol = { accessor: 'actions', title: ' ', width: 80, textAlign: 'right' as const, render: (r: Contact) => ( <Group gap={4} justify="flex-end" wrap="nowrap"> <Tooltip label="View Details"> <ActionIcon color="blue" variant="subtle" onClick={() => postMessage(Action.Window.GO_TO_PAGE, { page: 'CONTACT_INFO', data: r, }) } > <Icon icon="tabler:eye" /> </ActionIcon> </Tooltip> <ActionIcon color="red" variant="subtle" onClick={async () => { if (await confirm.danger('Delete Contact', 'Are you sure?')) { await db.contacts.delete(r.id!) await db.contactCustomFields .where({ contactId: r.id! }) .delete() await db.contactTags.where({ contactId: r.id! }).delete() await db.contactNotes.where({ contactId: r.id! }).delete() } }} > <Icon icon="tabler:trash" /> </ActionIcon> </Group> ), } return [...baseCols, ...fieldCols, actionCol] }, [allCustomFields, allTags]) // Toggle column visibility const toggleColumn = (columnId: string) => { setHiddenColumns((prev) => { const next = new Set(prev) if (next.has(columnId)) { next.delete(columnId) } else { next.add(columnId) } return next }) } // Filter visible columns const visibleColumns = useMemo(() => { return columns.filter((col: any) => !hiddenColumns.has(col.id)) }, [columns, hiddenColumns]) // Column options for dropdown (only custom fields) const columnOptions = useMemo(() => { return allCustomFields.map((cf) => ({ id: `cf_${cf.id}`, label: cf.name, })) }, [allCustomFields]) const hasActiveFilters = filterRules.length > 0 return ( <LayoutPage width={1000} icon={<Icon icon="tabler:address-book" fontSize={24} color="#34d399" />} title="Contacts" p={0} description="Manage your contacts, tags, and custom fields." > <AlertBanner message="Limited to 10 contacts in the free version. Go unlimited" /> <Stack h="100%" gap="md" px={'md'}> <Group justify="space-between"> <Group> <TextInput placeholder="Search name..." leftSection={<Icon icon="tabler:search" />} size="sm" value={search} onChange={(e) => setSearch(e.currentTarget.value)} /> <Button variant={showFilters || hasActiveFilters ? 'light' : 'subtle'} color={hasActiveFilters ? 'emerald' : 'gray'} leftSection={<Icon icon="tabler:filter" />} onClick={toggleFilters} size="sm" > Filters {hasActiveFilters && `(${filterRules.length})`} </Button> </Group> <Group> {/* Column Visibility Dropdown */} {columnOptions.length > 0 && ( <Menu shadow="md" position="bottom-end" closeOnItemClick={false}> <Menu.Target> <Button variant="subtle" size="sm" leftSection={<Icon icon="tabler:columns" />} > Columns </Button> </Menu.Target> <Menu.Dropdown> <Menu.Label>Custom Fields</Menu.Label> {columnOptions.map((col) => ( <Menu.Item key={col.id} onClick={() => toggleColumn(col.id)} leftSection={ <Checkbox size="xs" checked={!hiddenColumns.has(col.id)} onChange={() => {}} style={{ pointerEvents: 'none' }} /> } > {col.label} </Menu.Item> ))} </Menu.Dropdown> </Menu> )} <Menu shadow="md" position="bottom-end"> <Menu.Target> <Button variant="outline" leftSection={<Icon icon="tabler:download" />} loading={isExporting} > Export </Button> </Menu.Target> <Menu.Dropdown> <Menu.Item leftSection={ <Icon icon="tabler:file-spreadsheet" fontSize={16} /> } onClick={() => handleExport('xlsx')} > Excel (.xlsx) </Menu.Item> <Menu.Item leftSection={<Icon icon="tabler:file-text" fontSize={16} />} onClick={() => handleExport('csv')} > CSV (.csv) </Menu.Item> </Menu.Dropdown> </Menu> </Group> </Group> {/* Collapsible Filter Section - Inline Rule Builder */} <Collapse in={showFilters}> <Stack p="sm" style={{ backgroundColor: 'rgba(255,255,255,0.03)', borderRadius: 8, border: '1px solid rgba(255,255,255,0.05)', }} > <Group justify="space-between"> <Group gap="xs"> <Icon icon="tabler:filter" fontSize={16} /> <Text size="sm" fw={500}> Filter Rules </Text> {hasActiveFilters && ( <Badge size="sm" variant="light" color="emerald"> {filteredData.length} contacts </Badge> )} </Group> <Group gap="xs"> <SegmentedControl value={filterLogic} onChange={(val) => setFilterLogic(val as 'AND' | 'OR')} data={[ { value: 'AND', label: 'Match All' }, { value: 'OR', label: 'Match Any' }, ]} size="xs" /> {hasActiveFilters && ( <Button variant="subtle" size="xs" color="red" onClick={handleClearFilters} > Clear </Button> )} </Group> </Group> {/* Rules */} <Stack gap="xs"> {filterRules.map((rule, index) => ( <Box key={rule.key}> {index > 0 && ( <Divider my={4} label={ <Badge size="xs" variant="light" color={filterLogic === 'AND' ? 'blue' : 'orange'} > {filterLogic} </Badge> } labelPosition="center" /> )} <Group align="center" wrap="nowrap" gap="xs"> <Select placeholder="Field" data={fieldOptions} value={rule.field} onChange={(val) => handleRuleChange(index, 'field', val)} w={160} size="xs" searchable /> <Select placeholder="Operator" data={[ { value: 'equals', label: 'Equals' }, { value: 'contains', label: 'Contains' }, { value: 'startsWith', label: 'Starts With' }, { value: 'greaterThan', label: '>' }, { value: 'lessThan', label: '<' }, { value: 'isEmpty', label: 'Is Empty' }, { value: 'isNotEmpty', label: 'Is Not Empty' }, ]} value={rule.operator} onChange={(val) => handleRuleChange(index, 'operator', val) } w={130} size="xs" /> {renderRuleInput(rule, index)} <ActionIcon color="red" variant="subtle" size="sm" onClick={() => handleRemoveRule(index)} > <Icon icon="tabler:x" /> </ActionIcon> </Group> </Box> ))} <Button variant="light" size="xs" leftSection={<Icon icon="tabler:plus" />} onClick={handleAddRule} w="fit-content" > Add Rule </Button> </Stack> </Stack> </Collapse> {/* Data Table */} <ScrollArea style={{ flexGrow: 1 }}> <DataTable records={processedData} columns={visibleColumns as any} totalRecords={filteredData.length} recordsPerPage={pageSize} page={page} onPageChange={setPage} minHeight={300} striped highlightOnHover withTableBorder noRecordsText="No contacts found." /> </ScrollArea> </Stack> </LayoutPage> ) } export default PageContacts \`\`\` # src/features/direct-chat/ModalDirectChat.tsx \`\`\`tsx import InputMessage from '@/components/Input/Message/InputMessage' import useInputMessage from '@/components/Input/Message/useInputMessage' import LayoutModal from '@/components/Layout/LayoutModal' import { Message } from '@/constants' import useWa from '@/hooks/useWa' import toast from '@/utils/toast' import { delay, generateRandomDelay } from '@/utils/util' import { Icon } from '@iconify/react' import { Button, Group, Stack, Switch, Text, TextInput, Tooltip, } from '@mantine/core' import { useForm } from '@mantine/form' import React, { useState } from 'react' interface Props { opened: boolean onClose: () => void } const ModalDirectChat: React.FC<Props> = ({ opened, onClose }) => { const wa = useWa() const [loading, setLoading] = useState(false) const { form: messageForm, getMessage } = useInputMessage() const mainForm = useForm({ initialValues: { number: '', isTyping: false, }, validate: { number: (value) => value.trim().length === 0 ? 'Phone number is required' : null, }, }) const handleClose = () => { mainForm.reset() messageForm.reset() onClose() } const handleSubmit = async () => { const mainValidation = mainForm.validate() const messageValidation = messageForm.validate() if (mainValidation.hasErrors || messageValidation.hasErrors) { return } setLoading(true) try { let formattedNumber = mainForm.values.number.replace(/\D/g, '') if (formattedNumber.length < 5) { mainForm.setFieldError('number', 'Number seems too short') setLoading(false) return } if (!formattedNumber.includes('@c.us')) { formattedNumber = `${formattedNumber}@c.us` } const exists = await wa.contact.isExist(formattedNumber) if (!exists) { mainForm.setFieldError( 'number', 'This number does not exist on WhatsApp', ) setLoading(false) return } await wa.chat.openChatBottom(formattedNumber) const messageData = getMessage() const type = messageForm.values.type let hasContent = false if (type === Message.TEXT && messageData) hasContent = true if ( [Message.IMAGE, Message.VIDEO, Message.AUDIO, Message.FILE].includes( type, ) && (messageForm.values.inputImage.file || messageForm.values.inputVideo.file || messageForm.values.inputAudio.file || messageForm.values.inputFile.file) ) { hasContent = true } if ([Message.LOCATION, Message.POLL].includes(type)) hasContent = true if (!hasContent) { toast.info('Chat opened (No message sent).') handleClose() return } if (mainForm.values.isTyping) { const duration = generateRandomDelay(1500, 3000) await wa.chat.markIsComposing(formattedNumber, duration) await delay(duration) } if (type === Message.TEXT) { await wa.send.text(formattedNumber, messageData) } else if (type === Message.IMAGE) { await wa.send.file( formattedNumber, messageForm.values.inputImage.file!, { type: 'image', caption: messageData.caption, }, ) } else if (type === Message.VIDEO) { await wa.send.file( formattedNumber, messageForm.values.inputVideo.file!, { type: 'video', caption: messageData.caption, }, ) } else if (type === Message.AUDIO) { await wa.send.file( formattedNumber, messageForm.values.inputAudio.file!, { type: 'audio', }, ) } else if (type === Message.FILE) { await wa.send.file( formattedNumber, messageForm.values.inputFile.file!, { type: 'document', caption: messageData, }, ) } else if (type === Message.LOCATION) { await wa.send.location(formattedNumber, messageData) } else if (type === Message.POLL) { await wa.send.poll( formattedNumber, messageData.name, messageData.choices, ) } toast.success('Message sent successfully') handleClose() } catch (error) { console.error('Direct chat error:', error) toast.error('Failed to send message') } finally { setLoading(false) } } return ( <LayoutModal opened={opened} onClose={handleClose} title="Direct Chat" description="Start a conversation instantly with any phone number without saving it to contacts." icon={<Icon icon="tabler:message-plus" fontSize={24} />} w={700} > <Stack gap="lg"> <TextInput label="Phone Number" placeholder="e.g. 628123456789" description="Enter number with Country Code" required leftSection={<Icon icon="tabler:phone" fontSize={16} />} {...mainForm.getInputProps('number')} data-autofocus /> <Stack gap={4}> <InputMessage form={messageForm} allowProTypes={true} withTemplateSelector={true} /> </Stack> <Switch label={ <Group gap={4} wrap="nowrap"> <Text fw={500}>Typing effect</Text> <Tooltip label='Show "Typing..." status to the recipient before sending.' position="top-start" withArrow > <Icon icon="tabler:info-circle" style={{ display: 'block' }} /> </Tooltip> </Group> } {...mainForm.getInputProps('isTyping', { type: 'checkbox' })} /> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={handleClose} disabled={loading}> Cancel </Button> <Button onClick={handleSubmit} loading={loading} leftSection={<Icon icon="tabler:send" fontSize={18} />} > Send Message </Button> </Group> </Stack> </LayoutModal> ) } export default ModalDirectChat \`\`\` # src/features/media/models/MediaModel.ts \`\`\`ts import { Media } from '@/constants' import db from '@/libs/db' const firstByBroadcastId = async (broadcastId: number) => { return await db.media .where({ parentId: broadcastId, type: Media.BROADCAST, }) .first() } export default { firstByBroadcastId, } \`\`\` # src/features/privacy/PagePrivacy.tsx \`\`\`tsx import LayoutPage from '@/components/Layout/LayoutPage' import { Setting } from '@/constants' import { Icon } from '@iconify/react' import { Divider, Group, Paper, Stack, Switch, Text } from '@mantine/core' import { useStorage } from '@plasmohq/storage/hook' import React, { useEffect, useState } from 'react' const PagePrivacy: React.FC = () => { const [blurProfilePictures, setBlurProfilePictures] = useStorage( Setting.BLUR_PROFILE_PICTURES, false, ) const [blurMessages, setBlurMessages] = useStorage( Setting.BLUR_MESSAGES, false, ) const [blurUserGroupNames, setBlurUserGroupNames] = useStorage( Setting.BLUR_USER_GROUP_NAMES, false, ) const [blurRecentMessages, setBlurRecentMessages] = useStorage( Setting.BLUR_RECENT_MESSAGES, false, ) const [unblurOnHover, setUnblurOnHover] = useStorage( Setting.UNBLUR_ON_HOVER, false, ) const [allSwitchesEnabled, setAllSwitchesEnabled] = useState(false) useEffect(() => { const allEnabled = blurProfilePictures && blurMessages && blurUserGroupNames && blurRecentMessages setAllSwitchesEnabled(allEnabled) }, [ blurProfilePictures, blurMessages, blurUserGroupNames, blurRecentMessages, ]) const handleToggleAll = async (checked: boolean) => { setAllSwitchesEnabled(checked) await Promise.all([ setBlurProfilePictures(checked), setBlurMessages(checked), setBlurUserGroupNames(checked), setBlurRecentMessages(checked), ]) } const handleIndividualSwitchChange = async ( setter: (value: boolean) => Promise<void>, checked: boolean, ) => { await setter(checked) if (!checked) { setAllSwitchesEnabled(false) } } const privacyOptions = [ { label: 'Profile Pictures', description: 'Blur all contact and group profile pictures.', checked: blurProfilePictures, setter: setBlurProfilePictures, }, { label: 'User/Group Names', description: 'Blur names in the chat list and chat header.', checked: blurUserGroupNames, setter: setBlurUserGroupNames, }, { label: 'Recent Messages', description: 'Blur the last message preview in the chat list.', checked: blurRecentMessages, setter: setBlurRecentMessages, }, { label: 'Messages', description: 'Blur all messages in the active chat view.', checked: blurMessages, setter: setBlurMessages, }, ] const anyBlurEnabled = blurProfilePictures || blurMessages || blurUserGroupNames || blurRecentMessages // Switch cursor style const switchStyles = { root: { cursor: 'pointer' }, track: { cursor: 'pointer' }, input: { cursor: 'pointer' }, thumb: { cursor: 'pointer' }, } return ( <LayoutPage p={'xl'} icon={<Icon icon="tabler:eye-off" fontSize={24} color="#34d399" />} title="Privacy" description="Blur sensitive information on your screen to protect privacy." > <Stack gap="lg"> {/* Global Switch */} <Paper p="md" radius="md" style={{ backgroundColor: 'rgba(255, 255, 255, 0.03)', border: '1px solid rgba(255, 255, 255, 0.05)', }} > <Group justify="space-between"> <Stack gap={0}> <Text fw={600} c="white"> Blur All </Text> <Text size="xs" c="dimmed"> Toggle all privacy filters at once. </Text> </Stack> <Switch size="md" color="emerald" aria-label="Toggle all privacy settings" checked={allSwitchesEnabled} onChange={async (event) => { await handleToggleAll(event.currentTarget.checked) }} styles={switchStyles} // Fix cursor here /> </Group> </Paper> <Divider color="rgba(255,255,255,0.1)" label="Filters" labelPosition="center" /> <Stack gap="md"> {privacyOptions.map((option, index) => ( <Group justify="space-between" key={index} wrap="nowrap"> <Stack gap={2}> <Text fw={500} c="gray.3"> {option.label} </Text> <Text size="xs" c="dimmed" style={{ maxWidth: 260 }}> {option.description} </Text> </Stack> <Switch size="md" color="emerald" aria-label={`Toggle ${option.label}`} checked={option.checked} onChange={async (event) => { await handleIndividualSwitchChange( option.setter, event.currentTarget.checked, ) }} styles={switchStyles} // Fix cursor here /> </Group> ))} </Stack> <Divider color="rgba(255,255,255,0.1)" /> <Group justify="space-between" wrap="nowrap"> <Stack gap={2}> <Text fw={500} c="gray.3"> Unblur on Hover </Text> <Text size="xs" c="dimmed" style={{ maxWidth: 260 }}> Temporarily remove blur when hovering over blurred elements. </Text> </Stack> <Switch size="md" color="emerald" aria-label="Toggle unblur on hover" checked={unblurOnHover} disabled={!anyBlurEnabled} onChange={async (event) => { await setUnblurOnHover(event.currentTarget.checked) }} styles={switchStyles} /> </Group> </Stack> </LayoutPage> ) } export default PagePrivacy \`\`\` # src/features/quick-reply/components/QuickReplyPopover.tsx \`\`\`tsx import MessageType from '@/components/Datatable/MessageType' import useLicense from '@/hooks/useLicense' // ++ ADDED import db, { type QuickReply } from '@/libs/db' import toast from '@/utils/toast' // ++ ADDED import { showModalUpgrade, truncate } from '@/utils/util' // ++ ADDED showModalUpgrade import { Icon } from '@iconify/react' import { ActionIcon, Box, Center, Divider, Group, Paper, Popover, ScrollArea, Stack, Text, TextInput, Tooltip, } from '@mantine/core' import { useDebouncedValue, useDisclosure } from '@mantine/hooks' import { useLiveQuery } from 'dexie-react-hooks' import React, { useMemo, useState } from 'react' import { useQuickReplySender } from '../hooks/useQuickReplySender' import ModalCreateUpdateQuickReply from '../ModalCreateUpdateQuickReply' interface Props { chat: any } const QuickReplyPopover: React.FC<Props> = ({ chat }) => { const [opened, { close, open }] = useDisclosure(false) const [showCreateModal, createModalHandlers] = useDisclosure(false) const [search, setSearch] = useState('') const [debouncedSearch] = useDebouncedValue(search, 300) const { sendQuickReply, isSending } = useQuickReplySender() const license = useLicense() // ++ ADDED // Fetch quick replies const quickReplies = useLiveQuery(() => db.quickReplies.toArray(), []) // Filter and Sort const filteredReplies = useMemo(() => { if (!quickReplies) return [] let result = [...quickReplies] // Sort: Pinned first, then alphabetical result.sort((a, b) => { const pinA = a.pinned || 0 const pinB = b.pinned || 0 if (pinA !== pinB) return pinB - pinA return a.name.localeCompare(b.name) }) if (debouncedSearch) { const lowerQuery = debouncedSearch.toLowerCase() result = result.filter((r) => r.name.toLowerCase().includes(lowerQuery)) } return result }, [quickReplies, debouncedSearch]) const handleSend = async (reply: QuickReply) => { if (!chat || !chat.id) return const chatId = chat.id._serialized || chat.id const contactName = chat.name || chat.formattedTitle await sendQuickReply(reply, { chatId, contactName }) close() } const handleCreate = async () => { // ++ ADDED: Check Limit for Free Plan if (license.isFree()) { const count = await db.quickReplies.count() if (count >= 1) { toast.error('Free plan limit reached (1 quick reply). Upgrade to Pro.') showModalUpgrade() return } } close() createModalHandlers.open() } const renderPreview = (reply: QuickReply) => { let content = '' const { message } = reply if (typeof message === 'string') { content = message } else if (typeof message === 'object') { content = (message as any).caption || (message as any).name || 'Media/Content' } return truncate(content, 40) } return ( <> <Popover opened={opened} onChange={close} position="right-end" withArrow shadow="xl" trapFocus width={360} offset={14} transitionProps={{ duration: 200, transition: 'pop' }} > <Popover.Target> <div onMouseEnter={open} onMouseLeave={close}> <ActionIcon variant="filled" size={32} radius="50%" color={opened ? 'emerald' : undefined} > <Icon icon="tabler:bolt" fontSize={18} /> </ActionIcon> </div> </Popover.Target> <Popover.Dropdown p={0} onMouseEnter={open} onMouseLeave={close} style={{ backgroundColor: 'rgba(0, 0, 0, 0.85)', backdropFilter: 'blur(24px) saturate(180%)', WebkitBackdropFilter: 'blur(24px) saturate(180%)', border: '1px solid rgba(255, 255, 255, 0.1)', color: '#f8fafc', }} > <Stack gap={0}> {/* Header: Search & Create */} <Box p="xs"> <Group gap="xs" wrap="nowrap"> <TextInput placeholder="Search quick replies..." size="xs" leftSection={<Icon icon="tabler:search" fontSize={14} />} value={search} onChange={(e) => setSearch(e.currentTarget.value)} autoFocus style={{ flex: 1 }} styles={{ input: { backgroundColor: 'rgba(255, 255, 255, 0.05)', border: '1px solid rgba(255, 255, 255, 0.1)', color: '#fff', '&::placeholder': { color: 'rgba(255, 255, 255, 0.5)', }, }, }} /> <Tooltip label="Create new" withArrow position="top"> <ActionIcon variant="light" color="emerald" size="md" onClick={handleCreate} style={{ border: '1px solid rgba(16, 185, 129, 0.2)', }} > <Icon icon="tabler:plus" fontSize={16} /> </ActionIcon> </Tooltip> </Group> </Box> <Divider color="rgba(255,255,255,0.1)" /> {/* List Items */} <ScrollArea h={350} type="hover"> {filteredReplies.length > 0 ? ( <Stack gap={6} p="xs"> {filteredReplies.map((reply) => ( <Paper key={reply.id} radius="md" p="xs" withBorder style={{ backgroundColor: 'rgba(255, 255, 255, 0.03)', borderColor: 'rgba(255, 255, 255, 0.08)', transition: 'background-color 0.2s', }} onMouseEnter={(e) => { e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.08)' }} onMouseLeave={(e) => { e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.03)' }} > <Group justify="space-between" align="center" wrap="nowrap" > {/* Left Side: Title & Preview */} <Stack gap={2} style={{ flex: 1, overflow: 'hidden' }}> <Group gap={6} wrap="nowrap"> {reply.pinned && ( <Icon icon="tabler:pin-filled" fontSize={12} color="#fab005" /> )} <Text fw={600} size="sm" c="white" truncate> {reply.name} </Text> </Group> <Group gap={6} align="center" wrap="nowrap"> <Box style={{ opacity: 0.6, display: 'flex', alignItems: 'center', }} > <MessageType type={reply.type} /> </Box> <Text size="xs" c="dimmed" truncate style={{ flex: 1 }} > {renderPreview(reply)} </Text> </Group> </Stack> {/* Right Side: Send Button */} <Tooltip label="Send Now" withArrow position="left"> <ActionIcon radius="xl" color="emerald" variant="transparent" size="lg" loading={isSending} onClick={(e) => { e.stopPropagation() handleSend(reply) }} > <Icon icon="tabler:send" fontSize={18} /> </ActionIcon> </Tooltip> </Group> </Paper> ))} </Stack> ) : ( <Center h={150}> <Stack align="center" gap={4}> <Icon icon="tabler:database-off" color="rgba(255,255,255,0.3)" fontSize={24} /> <Text size="xs" c="dimmed"> No replies found </Text> </Stack> </Center> )} </ScrollArea> </Stack> </Popover.Dropdown> </Popover> {/* Create Modal */} <ModalCreateUpdateQuickReply opened={showCreateModal} onClose={createModalHandlers.close} data={null} /> </> ) } export default QuickReplyPopover \`\`\` # src/features/quick-reply/hooks/useQuickReplySender.ts \`\`\`ts import { Media, Message } from '@/constants' import db, { type QuickReply } from '@/libs/db' import wa from '@/libs/wa' import parse from '@/utils/parse' import toast from '@/utils/toast' import { useState } from 'react' interface SendOptions { chatId: string contactName?: string } export const useQuickReplySender = () => { const [isSending, setIsSending] = useState(false) const sendQuickReply = async (reply: QuickReply, options: SendOptions) => { setIsSending(true) const { chatId, contactName } = options // Normalize number format for parsing const contactNumber = chatId.includes('@') ? chatId.split('@')[0] : chatId try { const contactData = { number: contactNumber, name: contactName || 'there', } // 1. Handle Text if (reply.type === Message.TEXT) { const text = parse.text(reply.message as string, contactData as any) await wa.send.text(chatId, text) } // 2. Handle Media (Image, Video, Audio, File) else if ( [Message.IMAGE, Message.VIDEO, Message.AUDIO, Message.FILE].includes( reply.type, ) ) { const fileRecord = await db.media .where({ parentId: reply.id, type: Media.QUICK_REPLY }) .first() if (!fileRecord || !fileRecord.file) { throw new Error('Media file not found for this quick reply.') } const messageData = reply.message as { caption?: string } const caption = messageData?.caption ? parse.text(messageData.caption, contactData as any) : '' let fileType: 'image' | 'video' | 'audio' | 'document' = 'document' if (reply.type === Message.IMAGE) fileType = 'image' else if (reply.type === Message.VIDEO) fileType = 'video' else if (reply.type === Message.AUDIO) fileType = 'audio' await wa.send.file(chatId, fileRecord.file, { type: fileType, caption: caption, }) } // 3. Handle Location else if (reply.type === Message.LOCATION) { const messageData = reply.message as any await wa.send.location(chatId, { ...messageData }) } // 4. Handle Poll else if (reply.type === Message.POLL) { const { name, choices } = reply.message as any await wa.send.poll(chatId, name, choices) } else { throw new Error(`Unsupported message type: ${reply.type}`) } toast.success('Quick reply sent!') } catch (error: any) { console.error('Failed to send quick reply:', error) toast.error(error.message || 'Failed to send quick reply.') } finally { setIsSending(false) } } return { sendQuickReply, isSending, } } \`\`\` # src/features/quick-reply/ModalCreateUpdateQuickReply.tsx \`\`\`tsx import InputMessage from '@/components/Input/Message/InputMessage' import useInputMessage from '@/components/Input/Message/useInputMessage' import Modal from '@/components/Modal/Modal' import { Media, Message } from '@/constants' import db, { type QuickReply } from '@/libs/db' import toast from '@/utils/toast' import { formHasErrors, isTypeMessageMedia } from '@/utils/util' import { Button, Center, Group, Stack, TextInput, Title } from '@mantine/core' import { useForm } from '@mantine/form' import _ from 'lodash' import React, { useEffect, useState } from 'react' interface Props { opened: boolean onClose: () => void data?: Partial<QuickReply> | null } const ModalCreateUpdateQuickReply: React.FC<Props> = ({ opened, onClose, data = null, }: Props) => { const { form: inputMessageForm, getMessage, insertBroadcastFile, } = useInputMessage() const [isSubmitting, setIsSubmitting] = useState(false) const form = useForm({ initialValues: { name: '', }, validate: { name: (value) => (_.isEmpty(value) ? 'Name is required' : null), }, }) useEffect(() => { const populateForm = async () => { if (opened) { if (data) { form.setValues({ name: data.name || '' }) const messageData = data.message as any const type = data.type || Message.TEXT inputMessageForm.reset() inputMessageForm.setFieldValue('type', type) const fetchMediaFile = async () => { if (data.id) { const media = await db.media .where({ parentId: data.id, type: Media.QUICK_REPLY }) .first() return media?.file || null } return null } switch (type) { case Message.TEXT: inputMessageForm.setFieldValue( 'inputText', typeof messageData === 'string' ? messageData : '', ) break case Message.IMAGE: { const file = await fetchMediaFile() inputMessageForm.setFieldValue( 'inputImage.caption', messageData?.caption || '', ) inputMessageForm.setFieldValue('inputImage.file', file) break } case Message.VIDEO: { const file = await fetchMediaFile() inputMessageForm.setFieldValue( 'inputVideo.caption', messageData?.caption || '', ) inputMessageForm.setFieldValue('inputVideo.file', file) break } case Message.AUDIO: { const file = await fetchMediaFile() inputMessageForm.setFieldValue('inputAudio.file', file) break } case Message.FILE: { const file = await fetchMediaFile() inputMessageForm.setFieldValue( 'inputFile.caption', typeof messageData === 'string' ? messageData : '', ) inputMessageForm.setFieldValue('inputFile.file', file) break } case Message.LOCATION: inputMessageForm.setFieldValue('inputLocation', messageData) break case Message.POLL: inputMessageForm.setFieldValue('inputPoll', messageData) break } } else { form.reset() inputMessageForm.reset() } } } populateForm() }, [data, opened]) const handleCreate = async () => { const { type } = inputMessageForm.values const { name } = form.values const quickReplyId = await db.quickReplies.add({ name, type, message: getMessage(), pinned: 0, }) if (isTypeMessageMedia(type)) { if (typeof quickReplyId === 'number') { await insertBroadcastFile(quickReplyId, Media.QUICK_REPLY) } } } const handleUpdate = async () => { if (!data?.id) return const { type } = inputMessageForm.values const { name } = form.values const messagePayload = getMessage() await db.quickReplies.update(data.id, { name, type, message: messagePayload, }) const newFileIsSelected = (type === Message.IMAGE && inputMessageForm.values.inputImage.file) || (type === Message.VIDEO && inputMessageForm.values.inputVideo.file) || (type === Message.AUDIO && inputMessageForm.values.inputAudio.file) || (type === Message.FILE && inputMessageForm.values.inputFile.file) if (isTypeMessageMedia(type)) { if (newFileIsSelected) { await db.media .where({ parentId: data.id, type: Media.QUICK_REPLY }) .delete() await insertBroadcastFile(data.id, Media.QUICK_REPLY) } } else if ( data.type && isTypeMessageMedia(data.type) && !isTypeMessageMedia(type) ) { await db.media .where({ parentId: data.id, type: Media.QUICK_REPLY }) .delete() } } const handleSubmit = async () => { if (formHasErrors(form, inputMessageForm)) return setIsSubmitting(true) try { if (data && data.id) { await handleUpdate() toast.success('Quick reply updated successfully!') } else { await handleCreate() toast.success('Quick reply created successfully!') } onClose() } catch (error) { console.error(error) toast.error('Failed to save quick reply.') } finally { setIsSubmitting(false) } } return ( <Modal opened={opened} onClose={onClose} w={600} withCloseButton> <Stack> <Center> <Title order={3}>{data?.id ? 'Edit' : 'Create'} Quick Reply</Title> </Center> <TextInput label="Name" placeholder="e.g. Welcome Message" required {...form.getInputProps('name')} /> <InputMessage form={inputMessageForm} allowProTypes={true} /> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={onClose} disabled={isSubmitting}> Cancel </Button> <Button onClick={handleSubmit} loading={isSubmitting}> Save </Button> </Group> </Stack> </Modal> ) } export default ModalCreateUpdateQuickReply \`\`\` # src/features/quick-reply/PageQuickReply.tsx \`\`\`tsx import AlertBanner from '@/components/AlertBanner' import MessageType from '@/components/Datatable/MessageType' import LayoutPage from '@/components/Layout/LayoutPage' import { Media, Message } from '@/constants' import useLicense from '@/hooks/useLicense' import useWa from '@/hooks/useWa' import db, { type QuickReply } from '@/libs/db' import confirm from '@/utils/confirm' import parse from '@/utils/parse' import toast from '@/utils/toast' import { closePage, showModalUpgrade, truncate } from '@/utils/util' // ++ MODIFIED: Added showModalUpgrade import { Icon } from '@iconify/react' import { ActionIcon, Button, Card, Center, Group, ScrollArea, Stack, Text, TextInput, Tooltip, } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import { useLiveQuery } from 'dexie-react-hooks' import _ from 'lodash' import React, { useMemo, useState } from 'react' import ModalCreateUpdateQuickReply from './ModalCreateUpdateQuickReply' const PageQuickReply: React.FC = () => { const wa = useWa() const license = useLicense() const quickReplies = useLiveQuery(() => db.quickReplies.toArray(), []) const [showModal, modalHandlers] = useDisclosure(false) const [editingReply, setEditingReply] = useState<Partial<QuickReply> | null>( null, ) const [search, setSearch] = useState('') const [sendingReplyId, setSendingReplyId] = useState<number | null>(null) const handleCreate = async () => { // ++ ADDED: Check Limit for Free Plan if (license.isFree()) { const count = await db.quickReplies.count() if (count >= 2) { toast.warning( 'Free plan limit reached (2 quick replies). Upgrade for unlimited quick replies.', ) return } } setEditingReply(null) modalHandlers.open() } const handleEdit = (reply: QuickReply) => { setEditingReply(reply) modalHandlers.open() } const handleClone = (reply: QuickReply) => { const { id, ...rest } = reply setEditingReply({ ...rest, name: `${reply.name} (Copy)` }) modalHandlers.open() } const handleDelete = async (reply: QuickReply) => { if ( !(await confirm.danger( 'Delete Quick Reply', 'Are you sure you want to delete this quick reply?', )) ) return if (reply.id) { await db.media .where({ type: Media.QUICK_REPLY, parentId: reply.id }) .delete() await db.quickReplies.delete(reply.id) } } const handlePin = async (reply: QuickReply) => { if (!reply.id) return const pinned = reply.pinned ? 0 : Date.now() await db.quickReplies.update(reply.id, { pinned }) } const actions = (quickReply: QuickReply, chat: any) => { const formattedNumber = `${chat.id.user}@${chat.id.server}` return { [Message.TEXT]: async () => { const contactData = { number: formattedNumber, name: wa.activeChat?.name || wa.activeChat?.formattedTitle || 'there', } const text = parse.text( quickReply.message as string, contactData as any, ) return await wa.send.text(formattedNumber, text) }, [Message.IMAGE]: async () => { const file = await db.media .where({ parentId: quickReply.id, type: Media.QUICK_REPLY }) .first() if (!file) { toast.error('Image not found for this quick reply.') return } const messageData = quickReply.message as { caption?: string } return await wa.send.file(formattedNumber, file.file, { type: 'image', caption: messageData.caption, }) }, [Message.VIDEO]: async () => { const file = await db.media .where({ parentId: quickReply.id, type: Media.QUICK_REPLY }) .first() if (!file) { toast.error('Video not found for this quick reply.') return } const messageData = quickReply.message as { caption?: string } return await wa.send.file(formattedNumber, file.file, { type: 'video', caption: messageData.caption, }) }, [Message.AUDIO]: async () => { const file = await db.media .where({ parentId: quickReply.id, type: Media.QUICK_REPLY }) .first() if (!file) { toast.error('Audio file not found for this quick reply.') return } return await wa.send.file(formattedNumber, file.file, { type: 'audio', }) }, [Message.FILE]: async () => { const file = await db.media .where({ parentId: quickReply.id, type: Media.QUICK_REPLY }) .first() if (!file) { toast.error('File not found for this quick reply.') return } const caption = quickReply.message as string return await wa.send.file(formattedNumber, file.file, { type: 'document', caption: caption, }) }, [Message.LOCATION]: async () => { const messageData = quickReply.message as any return await wa.send.location(formattedNumber, { ...messageData }) }, [Message.POLL]: async () => { const { name, choices } = quickReply.message as any return await wa.send.poll(formattedNumber, name, choices) }, } } const handleSend = async (reply: QuickReply) => { try { if (_.isEmpty(wa.activeChat)) { toast.error('Please select a chat first.') return } setSendingReplyId(reply.id!) const chat = { id: { user: wa.activeChat.number, server: wa.activeChat.isGroup ? 'g.us' : 'c.us', }, number: wa.activeChat.number, } const actionMap = actions(reply, chat) const action = actionMap[reply.type] if (action) { await action() toast.success('Sent!') closePage() } else { toast.error(`Unsupported message type: ${reply.type}`) } } catch (error) { console.error(error) toast.error('Failed to send quick reply.') } finally { setSendingReplyId(null) } } const filteredReplies = useMemo(() => { if (!quickReplies) return [] let sorted = [...quickReplies].sort((a, b) => { const pinA = a.pinned || 0 const pinB = b.pinned || 0 if (pinA !== pinB) return pinB - pinA return a.name.localeCompare(b.name) }) if (search) { sorted = sorted.filter((r) => r.name.toLowerCase().includes(search.toLowerCase()), ) } return sorted }, [quickReplies, search]) const renderPreview = (reply: QuickReply) => { let content = 'No preview' const { type, message } = reply if (type === Message.TEXT) { content = typeof message === 'string' ? message : JSON.stringify(message) } else if ( [Message.IMAGE, Message.VIDEO, Message.FILE, Message.AUDIO].includes( type, ) && typeof message === 'object' ) { content = (message as any).caption || `Media (${type})` } else if (type === Message.POLL) { content = (message as any).name || 'Poll' } else if (type === Message.LOCATION) { content = 'Location' } return ( <Text c="dimmed" size="xs" lineClamp={2}> {truncate(content, 45)} </Text> ) } return ( <> <LayoutPage icon={<Icon icon="tabler:message-bolt" fontSize={24} color="#34d399" />} title="Quick Reply" p={0} width={580} description="Save frequently used messages and send them with one click." > <AlertBanner message="Limited to 2 quick replies in the free version. Go unlimited" /> <Stack h="100%" px="md"> <Group justify="space-between"> <TextInput placeholder="Search..." leftSection={<Icon icon="tabler:search" fontSize={16} />} value={search} size="sm" onChange={(e) => setSearch(e.currentTarget.value)} style={{ flex: 1 }} /> <Button leftSection={<Icon icon="tabler:plus" />} onClick={handleCreate} variant="filled" color="emerald" > Create </Button> </Group> <ScrollArea h="calc(100vh - 140px)"> <Stack gap="md" pb="xl"> {filteredReplies.length === 0 ? ( <Center h={200}> <Stack align="center" gap="xs"> <Icon icon="tabler:message-off" fontSize={48} color="var(--mantine-color-dimmed)" /> <Text c="dimmed">No quick replies found.</Text> </Stack> </Center> ) : ( filteredReplies.map((reply) => ( <Card key={reply.id} withBorder shadow="sm" radius="md" padding="sm" > <Group justify="space-between" align="flex-start" wrap="nowrap" > <Stack gap={4} style={{ flex: 1 }}> <Group gap={6}> {reply.pinned ? ( <Icon icon="tabler:pin-filled" fontSize={14} color="var(--mantine-color-yellow-5)" style={{ transform: 'rotate(45deg)' }} /> ) : null} <Text fw={600} size="sm"> {reply.name} </Text> </Group> <MessageType type={reply.type} /> {renderPreview(reply)} </Stack> <Stack justify="space-between" align="flex-end" h="100%"> <Group gap={4}> <Tooltip label={reply.pinned ? 'Unpin' : 'Pin'}> <ActionIcon variant="subtle" color="gray" size="sm" onClick={() => handlePin(reply)} > <Icon icon={ reply.pinned ? 'tabler:pin-filled' : 'tabler:pin' } /> </ActionIcon> </Tooltip> <Tooltip label="Edit"> <ActionIcon variant="subtle" color="blue" size="sm" onClick={() => handleEdit(reply)} > <Icon icon="tabler:edit" /> </ActionIcon> </Tooltip> <Tooltip label="Clone"> <ActionIcon variant="subtle" color="teal" size="sm" onClick={() => handleClone(reply)} > <Icon icon="tabler:copy" /> </ActionIcon> </Tooltip> <Tooltip label="Delete"> <ActionIcon variant="subtle" color="red" size="sm" onClick={() => handleDelete(reply)} > <Icon icon="tabler:trash" /> </ActionIcon> </Tooltip> </Group> <Button size="xs" leftSection={<Icon icon="tabler:send" />} onClick={() => handleSend(reply)} variant="light" loading={sendingReplyId === reply.id} disabled={sendingReplyId !== null} > Send </Button> </Stack> </Group> </Card> )) )} </Stack> </ScrollArea> </Stack> </LayoutPage> <ModalCreateUpdateQuickReply opened={showModal} onClose={modalHandlers.close} data={editingReply} /> </> ) } export default PageQuickReply \`\`\` # src/features/schedule-message/components/ModalScheduleMessage.tsx \`\`\`tsx import InputMessage from '@/components/Input/Message/InputMessage' import useInputMessage from '@/components/Input/Message/useInputMessage' import Modal from '@/components/Modal/Modal' import { Media, Message, Status } from '@/constants' import ScheduledMessageModel from '@/features/schedule-message/models/ScheduledMessageModel' import db, { type ScheduledMessage } from '@/libs/db' import toast from '@/utils/toast' import { formHasErrors, isTypeMessageMedia } from '@/utils/util' import { Icon } from '@iconify/react' import { Button, Group, Stack, Text, Title } from '@mantine/core' import { DateTimePicker } from '@mantine/dates' import { useForm } from '@mantine/form' import { addMinutes, isFuture } from 'date-fns' import _ from 'lodash' import React, { useEffect, useState } from 'react' interface Props { opened: boolean onClose: () => void chat: any data?: ScheduledMessage | null } const ModalScheduleMessage: React.FC<Props> = ({ opened, onClose, chat, data = null, }) => { const [loading, setLoading] = useState(false) const { form: messageForm, getMessage, insertBroadcastFile, } = useInputMessage() const scheduleForm = useForm({ initialValues: { scheduledAt: addMinutes(new Date(), 10) as Date | null, }, validate: { scheduledAt: (value) => value && isFuture(new Date(value)) ? null : 'Scheduled time must be in the future.', }, }) useEffect(() => { const populate = async () => { if (opened && data) { scheduleForm.setFieldValue('scheduledAt', new Date(data.scheduledAt)) messageForm.setFieldValue('type', data.type) const msg = data.message if (data.type === Message.TEXT) { messageForm.setFieldValue('inputText', msg as string) } else if (isTypeMessageMedia(data.type)) { const caption = (msg as any)?.caption || '' const fieldName = data.type === Message.IMAGE ? 'inputImage' : data.type === Message.VIDEO ? 'inputVideo' : data.type === Message.AUDIO ? 'inputAudio' : 'inputFile' if (data.type !== Message.AUDIO) { messageForm.setFieldValue(`${fieldName}.caption`, caption) } const media = await db.media .where({ parentId: data.id, type: Media.SCHEDULED_MESSAGE }) .first() if (media?.file) { messageForm.setFieldValue(`${fieldName}.file`, media.file) } } else if (data.type === Message.LOCATION) { messageForm.setFieldValue('inputLocation', msg) } else if (data.type === Message.POLL) { messageForm.setFieldValue('inputPoll', msg) } } else if (opened && !data) { messageForm.reset() scheduleForm.reset() scheduleForm.setFieldValue('scheduledAt', addMinutes(new Date(), 10)) } } populate() }, [opened, data]) const handleSubmit = async () => { if (formHasErrors(scheduleForm, messageForm)) return if (!data && _.isEmpty(chat)) { toast.error('Invalid chat selected.') return } setLoading(true) try { const messageContent = getMessage() const type = messageForm.values.type const scheduledAt = scheduleForm.values.scheduledAt! const getFile = () => { if (type === Message.IMAGE) return messageForm.values.inputImage.file if (type === Message.VIDEO) return messageForm.values.inputVideo.file if (type === Message.AUDIO) return messageForm.values.inputAudio.file if (type === Message.FILE) return messageForm.values.inputFile.file return null } if (data) { await ScheduledMessageModel.update( data.id, { type, message: messageContent, scheduledAt, status: Status.PENDING, error: undefined, }, getFile(), ) toast.success('Scheduled message updated.') } else { const id = await db.scheduledMessages.add({ chatId: chat.id._serialized || chat.id, type, message: messageContent, scheduledAt, status: Status.PENDING, createdAt: new Date(), }) if (isTypeMessageMedia(type)) { await insertBroadcastFile(id as number, Media.SCHEDULED_MESSAGE) } toast.success('Message scheduled successfully!') } handleClose() } catch (error) { console.error('Error saving scheduled message:', error) toast.error('Failed to save message.') } finally { setLoading(false) } } const handleClose = () => { messageForm.reset() scheduleForm.reset() onClose() } return ( <Modal opened={opened} onClose={handleClose} w={660}> <Stack gap="lg" p="sm"> <Stack gap="xs"> <Group gap="xs" align="center"> <Icon icon="tabler:calendar-time" fontSize={24} color="#34d399" /> <Title order={4}>{data ? 'Edit Message' : 'New Schedule'}</Title> </Group> {!data && ( <Text size="sm" c="dimmed"> Schedule a message to be sent to{' '} <b>{chat?.name || 'this chat'}</b>. </Text> )} </Stack> <DateTimePicker label="Send at" placeholder="Pick date and time" minDate={new Date()} required {...scheduleForm.getInputProps('scheduledAt')} /> <InputMessage form={messageForm} allowProTypes={true} withTemplateSelector={true} /> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={handleClose} disabled={loading}> Cancel </Button> <Button onClick={handleSubmit} loading={loading} color="emerald" leftSection={ <Icon icon={data ? 'tabler:device-floppy' : 'tabler:clock'} fontSize={18} /> } > {data ? 'Save Changes' : 'Schedule'} </Button> </Group> </Stack> </Modal> ) } export default ModalScheduleMessage \`\`\` # src/features/schedule-message/components/ScheduleMessageListener.tsx \`\`\`tsx import useWa from '@/hooks/useWa' import { useEffect } from 'react' import useChatScheduler from '../hooks/useChatScheduler' const ScheduleMessageListener: React.FC = () => { const wa = useWa() const scheduler = useChatScheduler() useEffect(() => { if (!wa.isReady) return // Check immediately on load scheduler.checkScheduled().catch(console.error) // Check every 30 seconds const interval = setInterval(() => { scheduler.checkScheduled().catch(console.error) }, 30000) return () => { clearInterval(interval) } }, [wa.isReady]) return null } export default ScheduleMessageListener \`\`\` # src/features/schedule-message/hooks/useChatScheduler.ts \`\`\`ts import { Media, Message, Status } from '@/constants' import db, { type ScheduledMessage } from '@/libs/db' import wa from '@/libs/wa' import toast from '@/utils/toast' import dayjs from 'dayjs' import { useRef } from 'react' const useChatScheduler = () => { const isProcessing = useRef(false) const checkScheduled = async () => { if (isProcessing.current) return const now = new Date() const dueMessages = await db.scheduledMessages .where('status') .equals(Status.PENDING) .and((msg) => dayjs(msg.scheduledAt).isBefore(now)) .toArray() if (dueMessages.length > 0) { processQueue(dueMessages) } } const processQueue = async (messages: ScheduledMessage[]) => { if (isProcessing.current) return isProcessing.current = true for (const msg of messages) { try { await db.scheduledMessages.update(msg.id, { status: Status.RUNNING }) let success = false switch (msg.type) { case Message.TEXT: await wa.send.text(msg.chatId, msg.message) success = true break case Message.IMAGE: case Message.VIDEO: case Message.AUDIO: case Message.FILE: const media = await db.media .where({ parentId: msg.id, type: Media.SCHEDULED_MESSAGE, }) .first() if (media && media.file) { const fileType = msg.type === Message.IMAGE ? 'image' : msg.type === Message.VIDEO ? 'video' : msg.type === Message.AUDIO ? 'audio' : 'document' const caption = typeof msg.message === 'string' ? msg.message : msg.message?.caption || '' await wa.send.file(msg.chatId, media.file, { type: fileType as any, caption: caption, }) success = true } else { throw new Error('Media file not found in database') } break case Message.LOCATION: await wa.send.location(msg.chatId, msg.message) success = true break case Message.POLL: await wa.send.poll( msg.chatId, msg.message.name, msg.message.choices, ) success = true break default: throw new Error(`Unsupported message type: ${msg.type}`) } if (success) { await db.scheduledMessages.update(msg.id, { status: Status.SUCCESS }) toast.success('Scheduled message sent successfully.') } } catch (error: any) { console.error(`Failed to send scheduled message ${msg.id}:`, error) await db.scheduledMessages.update(msg.id, { status: Status.FAILED, error: error.message || 'Unknown error', }) toast.error(`Failed to send scheduled message to ${msg.chatId}`) } } isProcessing.current = false } return { checkScheduled, } } export default useChatScheduler \`\`\` # src/features/schedule-message/models/ScheduledMessageModel.ts \`\`\`ts import { Media, Status } from '@/constants' import db, { type ScheduledMessage } from '@/libs/db' const getByChatId = async (chatId: string) => { return await db.scheduledMessages .where('chatId') .equals(chatId) .reverse() .sortBy('scheduledAt') } const deleteById = async (id: number) => { await db.transaction('rw', db.scheduledMessages, db.media, async () => { // Delete associated media await db.media .where({ parentId: id, type: Media.SCHEDULED_MESSAGE }) .delete() // Delete the record await db.scheduledMessages.delete(id) }) } const update = async ( id: number, data: Partial<ScheduledMessage>, newFile?: File | null, ) => { await db.transaction('rw', db.scheduledMessages, db.media, async () => { // 1. Update the message record await db.scheduledMessages.update(id, data) // 2. Handle Media updates if a new file is provided if (newFile) { // Delete old media await db.media .where({ parentId: id, type: Media.SCHEDULED_MESSAGE }) .delete() // Add new media await db.media.add({ parentId: id, type: Media.SCHEDULED_MESSAGE, name: newFile.name, file: newFile, ext: newFile.type, }) } // If type changed to TEXT (non-media) but it was previously media, clean up else if (data.type === 'TEXT') { await db.media .where({ parentId: id, type: Media.SCHEDULED_MESSAGE }) .delete() } }) } export default { getByChatId, deleteById, update, } \`\`\` # src/features/status/components/ModalCreateUpdateStatus.tsx \`\`\`tsx import InputSendLater from '@/components/Input/InputSendLater' import Upload from '@/components/Input/Message/Upload' import Modal from '@/components/Modal/Modal' import { Action, Media, Status as StatusState, StatusType } from '@/constants' import useLicense from '@/hooks/useLicense' import db, { type UserStatus } from '@/libs/db' import toast from '@/utils/toast' import { postMessage, showModalUpgrade } from '@/utils/util' import { Icon } from '@iconify/react' import { Button, ColorInput, Group, Radio, ScrollArea, Select, Stack, Text, Textarea, TextInput, } from '@mantine/core' import { useForm } from '@mantine/form' import { addMinutes, isFuture } from 'date-fns' import _ from 'lodash' import React, { useEffect, useState } from 'react' interface Props { opened: boolean onClose: () => void data?: UserStatus | null } const ModalCreateUpdateStatus: React.FC<Props> = ({ opened, onClose, data = null, }) => { const [isSubmitting, setIsSubmitting] = useState(false) const license = useLicense() const form = useForm({ initialValues: { name: '', type: StatusType.TEXT, text: '', caption: '', file: null as File | null, backgroundColor: '#008069', // Default WhatsApp Teal font: 0, scheduler: { enabled: false, scheduledAt: addMinutes(new Date(), 5), }, }, validate: { type: (value) => (_.isEmpty(value) ? 'Status type is required' : null), text: (value, values) => values.type === StatusType.TEXT && _.isEmpty(value) ? 'Text content is required' : null, file: (value, values) => { if ( !data && (values.type === StatusType.IMAGE || values.type === StatusType.VIDEO) ) { return !value ? 'File is required' : null } return null }, scheduler: (value) => { if (license.isFree() && value.enabled) { form.setFieldValue('scheduler.enabled', false) return 'Scheduler is a Pro feature.' } if (value.enabled && !value.scheduledAt) { return 'Scheduled date and time is required.' } if ( value.enabled && value.scheduledAt && !isFuture(new Date(value.scheduledAt)) ) { return 'Scheduled time must be in the future.' } return null }, }, validateInputOnChange: ['scheduler.enabled'], }) // Handle opening and data population useEffect(() => { if (opened) { if (data) { form.setValues({ name: data.name || '', type: data.type, text: data.type === StatusType.TEXT ? (data.message as string) : '', caption: data.type !== StatusType.TEXT ? (data.message as any)?.caption || '' : '', file: null, backgroundColor: data.backgroundColor || '#008069', font: data.font || 0, scheduler: { enabled: !!data.isScheduled, scheduledAt: data.scheduledAt || addMinutes(new Date(), 5), }, }) } else { form.reset() form.setFieldValue('scheduler', { enabled: false, scheduledAt: addMinutes(new Date(), 5), }) } } // eslint-disable-next-line react-hooks/exhaustive-deps }, [data, opened]) const handleTypeChange = (value: string) => { form.setFieldValue('type', value) } const prepareStatusPayload = async () => { const { type, text, caption, file, name, backgroundColor, font, scheduler, } = form.values // Default target status is PENDING (Post Now) let targetDbStatus: string = StatusState.PENDING let isActuallyScheduled = scheduler.enabled let actualScheduledAt = null if ( scheduler.enabled && scheduler.scheduledAt && isFuture(scheduler.scheduledAt) ) { actualScheduledAt = scheduler.scheduledAt targetDbStatus = StatusState.SCHEDULER } else { isActuallyScheduled = false } const basePayload = { name: name || (type === StatusType.TEXT ? text.substring(0, 30) : caption?.substring(0, 30) || 'Media Status'), type, message: '', backgroundColor: type === StatusType.TEXT ? backgroundColor : undefined, font: type === StatusType.TEXT ? font : undefined, isScheduled: isActuallyScheduled ? 1 : 0, scheduledAt: actualScheduledAt, } let mediaFileId: number | undefined = undefined if (type === StatusType.TEXT) { basePayload.message = text } else if ( (type === StatusType.IMAGE || type === StatusType.VIDEO) && file ) { const mediaId = await db.media.add({ parentId: 0, // Temp parentId type: Media.STATUS_CONTENT, name: file.name, file: file, ext: file.type, }) mediaFileId = mediaId as number //@ts-ignore basePayload.message = { caption: caption || '', fileId: mediaId } } else if ( data && (data.type === StatusType.IMAGE || data.type === StatusType.VIDEO) && (data.message as any)?.fileId ) { // Re-use existing file mediaFileId = (data.message as any).fileId //@ts-ignore basePayload.message = { caption: caption || '', fileId: (data.message as any).fileId, } } return { payload: basePayload, status: targetDbStatus, mediaFileId } } const handleSave = async () => { if (form.validate().hasErrors) return setIsSubmitting(true) try { const { payload, status, mediaFileId } = await prepareStatusPayload() let statusId = data?.id if (statusId) { // Update existing const updateData: Partial<UserStatus> = { ...payload, status: status, message: payload.message, } // If we are reposting a previously POSTED status if (status === StatusState.POSTED) { updateData.postedAt = new Date() } await db.userStatuses.update(statusId, updateData) } else { // Create new statusId = await db.userStatuses.add({ ...(payload as UserStatus), createdAt: new Date(), status: status, postedAt: status === StatusState.POSTED ? new Date() : null, message: payload.message, }) } // Link Media to Status ID if (mediaFileId) { await db.media.update(mediaFileId, { parentId: statusId }) } toast.success( status === StatusState.SCHEDULER ? 'Status scheduled successfully.' : 'Status queued for immediate posting.', ) // If immediate post, trigger the listener if (status === StatusState.PENDING) { postMessage(Action.Window.TRIGGER_SCHEDULER) } onClose() } catch (error: any) { console.error('Failed to save status:', error) toast.error(`Error: ${error.message || 'Failed to process status.'}`) } finally { setIsSubmitting(false) } } const getSubmitButtonLabel = () => { const isFutureSchedule = form.values.scheduler.enabled && form.values.scheduler.scheduledAt && isFuture(form.values.scheduler.scheduledAt) if (isFutureSchedule) { return data && data.status === StatusState.POSTED ? 'Schedule Again' : 'Schedule' } return data && data.status === StatusState.POSTED ? 'Post Again' : 'Post Now' } const fontOptions = [ { value: '0', label: 'Default' }, { value: '1', label: 'Serif' }, { value: '2', label: 'Sans-Serif' }, { value: '3', label: 'Bryndan Write' }, { value: '4', label: 'Norican' }, { value: '5', label: 'Oswald' }, ] return ( <Modal opened={opened} onClose={() => { form.reset() onClose() }} w={600} withCloseButton > <Stack gap="md"> <TextInput label="Status Name" placeholder="e.g., Morning Update" {...form.getInputProps('name')} /> <Radio.Group label={<Text fw={500}>Status Type</Text>} value={form.values.type} onChange={handleTypeChange} > <Group mt="xs"> <Radio value={StatusType.TEXT} label={ <Group gap="xs" wrap="nowrap"> <Icon icon="tabler:file-text" fontSize={20} /> <Text>Text</Text> </Group> } /> <Radio value={StatusType.IMAGE} label={ <Group gap="xs" wrap="nowrap"> <Icon icon={'tabler:photo'} fontSize={20} /> <Text>Image</Text> </Group> } /> <Radio value={StatusType.VIDEO} label={ <Group gap="xs" wrap="nowrap"> <Icon icon={'tabler:video'} fontSize={20} /> <Text>Video</Text> </Group> } /> </Group> </Radio.Group> {form.values.type === StatusType.TEXT && ( <> <Textarea label="Text Content" placeholder="What's on your mind?" autosize minRows={4} required {...form.getInputProps('text')} /> <Group grow align="flex-start"> <ColorInput label="Background Color" placeholder="Choose color" format="hex" {...form.getInputProps('backgroundColor')} /> <Select label="Font Style" placeholder="Select font" data={fontOptions} {...form.getInputProps('font')} value={form.values.font?.toString()} onChange={(value) => form.setFieldValue('font', value ? parseInt(value) : 0) } /> </Group> </> )} {(form.values.type === StatusType.IMAGE || form.values.type === StatusType.VIDEO) && ( <> <Upload type={form.values.type === StatusType.IMAGE ? 'image' : 'video'} value={form.values.file} onDrop={(droppedFile) => form.setFieldValue('file', droppedFile)} onRemove={() => form.setFieldValue('file', null)} // ++ ADDED: onRemove handler /> {form.errors.file && ( <Text c="red" size="sm"> {form.errors.file} </Text> )} <Textarea label="Caption (Optional)" placeholder="Add a caption..." autosize minRows={2} {...form.getInputProps('caption')} /> </> )} <InputSendLater form={form} /> </Stack> <Group justify="flex-end" mt="xl"> <Button variant="default" onClick={onClose} disabled={isSubmitting}> Cancel </Button> <Button onClick={handleSave} loading={isSubmitting} disabled={isSubmitting} color="emerald" leftSection={<Icon icon="tabler:send" fontSize={18} />} > {getSubmitButtonLabel()} </Button> </Group> </Modal> ) } export default ModalCreateUpdateStatus \`\`\` # src/features/status/components/StatusListener.tsx \`\`\`tsx import { Action } from '@/constants' import useWa from '@/hooks/useWa' import useWindowMessage from '@/hooks/useWindowMessage' import { useEffect } from 'react' import useStatusScheduler from '../hooks/useStatusScheduler' const StatusListener: React.FC = () => { const wa = useWa() const statusScheduler = useStatusScheduler() // Listen for immediate trigger events from the Modal useWindowMessage(async (event: MessageEvent) => { const { data: { action }, } = event switch (action) { case Action.Window.TRIGGER_SCHEDULER: console.log('StatusListener: Triggered manually') await statusScheduler.checkScheduled() break default: break } }) useEffect(() => { if (!wa.isReady) return // Init on load to reset stuck statuses statusScheduler.initializeScheduler().catch(console.error) // Regular interval check (every 30 seconds) const interval = setInterval(() => { statusScheduler.checkScheduled().catch(console.error) }, 30000) return () => { clearInterval(interval) } }, [wa.isReady]) return null } export default StatusListener \`\`\` # src/features/status/hooks/useStatusScheduler.ts \`\`\`ts import { Status as StatusState, StatusType } from '@/constants' import db, { type Media as MediaRecord, type UserStatus } from '@/libs/db' import wa from '@/libs/wa' import toast from '@/utils/toast' import { delay, generateRandomDelay } from '@/utils/util' import dayjs from 'dayjs' import { useRef } from 'react' const useStatusScheduler = () => { const isProcessing = useRef(false) const initializeScheduler = async () => { // Reset any stuck 'RUNNING' statuses back to 'PENDING' on startup await db.userStatuses .where('status') .equals(StatusState.RUNNING) .modify({ status: StatusState.PENDING }) await checkScheduled() } const checkScheduled = async () => { if (isProcessing.current) return const now = new Date() // Move due items from SCHEDULER to PENDING const dueScheduled = await db.userStatuses .where('status') .equals(StatusState.SCHEDULER) .and( (status) => dayjs(status.scheduledAt).isBefore(now) || dayjs(status.scheduledAt).isSame(now), ) .modify({ status: StatusState.PENDING }) if (dueScheduled > 0) { console.log(`Scheduler: Found ${dueScheduled} due statuses.`) } await processQueue() } const processQueue = async () => { if (isProcessing.current) return isProcessing.current = true try { const statusToPost = await db.userStatuses .where('status') .equals(StatusState.PENDING) .first() if (!statusToPost) { isProcessing.current = false return } await postStatus(statusToPost) } catch (error) { console.error('Scheduler Error:', error) } finally { isProcessing.current = false } } const postStatus = async (status: UserStatus) => { try { await db.userStatuses.update(status.id, { status: StatusState.RUNNING }) // Simulate human behavior delay await delay(generateRandomDelay(1000, 3000)) let result: any if (status.type === StatusType.TEXT) { result = await wa.status.sendTextStatus(status.message as string, { backgroundColor: status.backgroundColor, font: status.font, }) } else if ( (status.type === StatusType.IMAGE || status.type === StatusType.VIDEO) && (status.message as any)?.fileId ) { const media: MediaRecord | undefined = await db.media.get( (status.message as any).fileId, ) if (!media || !media.file) { throw new Error('Media file not found in database') } const caption = (status.message as { caption?: string })?.caption if (status.type === StatusType.IMAGE) { result = await wa.status.sendImageStatus(media.file, { caption }) } else { result = await wa.status.sendVideoStatus(media.file, { caption }) } } else { throw new Error('Invalid status type or missing media') } // Check result success (WPPConnect usually returns object on success) if (result) { await db.userStatuses.update(status.id, { status: StatusState.POSTED, postedAt: new Date(), }) toast.success( `Status "${status.name || 'Untitled'}" posted successfully.`, ) } else { throw new Error('Failed to post status (Unknown error)') } } catch (error: any) { console.error(`Failed to post status ${status.id}:`, error) await db.userStatuses.update(status.id, { status: StatusState.FAILED }) toast.error(`Failed to post status: ${error.message}`) } finally { isProcessing.current = false // Check for next item await processQueue() } } const cancelScheduledStatus = async (statusId: number) => { await db.userStatuses.update(statusId, { status: StatusState.DRAFT, isScheduled: 0, scheduledAt: null, }) toast.info('Status scheduling cancelled. Moved to drafts.') } return { initializeScheduler, checkScheduled, cancelScheduledStatus, } } export default useStatusScheduler \`\`\` # src/features/status/PageStatus.tsx \`\`\`tsx import LayoutPage from '@/components/Layout/LayoutPage' import { Status as StatusState, StatusType } from '@/constants' import useDbQuery from '@/hooks/useDbQuery' import db, { type UserStatus } from '@/libs/db' import confirm from '@/utils/confirm' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { ActionIcon, Alert, Badge, Box, Button, Group, Stack, Text, TextInput, Tooltip, } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import dayjs from 'dayjs' import { DataTable } from 'mantine-datatable' import React, { useState } from 'react' import ModalCreateUpdateStatus from './components/ModalCreateUpdateStatus' import useStatusScheduler from './hooks/useStatusScheduler' const PageStatus: React.FC = () => { const [showModal, modalHandlers] = useDisclosure(false) const [editingStatus, setEditingStatus] = useState<UserStatus | null>(null) // Added state for bulk selection const [selectedRecords, setSelectedRecords] = useState<UserStatus[]>([]) const statusScheduler = useStatusScheduler() const dataQuery = useDbQuery<UserStatus>({ table: db.userStatuses, initialSort: { field: 'createdAt', direction: 'desc' }, searchField: 'name', }) const handleCreate = () => { setEditingStatus(null) modalHandlers.open() } const handleEdit = (status: UserStatus) => { setEditingStatus(status) modalHandlers.open() } // Refactored to support single and bulk deletion logic const performDelete = async (statusesToDelete: UserStatus[]) => { if (statusesToDelete.length === 0) return const isPlural = statusesToDelete.length > 1 const confirmed = await confirm.danger( 'Delete Status', `Are you sure you want to delete ${ isPlural ? `${statusesToDelete.length} statuses` : 'this status' }?`, ) if (!confirmed) return try { const idsToDelete = statusesToDelete.map((s) => s.id) const mediaIdsToDelete: number[] = [] // Collect media IDs associated with these statuses statusesToDelete.forEach((status) => { if ( (status.type === StatusType.IMAGE || status.type === StatusType.VIDEO) && (status.message as any)?.fileId ) { mediaIdsToDelete.push((status.message as any).fileId) } }) // Perform deletion in a transaction await db.transaction('rw', db.userStatuses, db.media, async () => { if (mediaIdsToDelete.length > 0) { await db.media.bulkDelete(mediaIdsToDelete) } await db.userStatuses.bulkDelete(idsToDelete) }) toast.success( `${statusesToDelete.length} status(es) deleted successfully.`, ) setSelectedRecords([]) // Clear selection after delete } catch (error) { console.error('Delete failed:', error) toast.error('Failed to delete status(es).') } } const handleDelete = async (status: UserStatus) => { await performDelete([status]) } const handleBulkDelete = async () => { await performDelete(selectedRecords) } const handlePostNow = async (status: UserStatus) => { const confirmed = await confirm.info( 'Post Now', 'Do you want to post this status immediately?', ) if (!confirmed) return await db.userStatuses.update(status.id, { status: StatusState.PENDING, isScheduled: 0, scheduledAt: null, }) toast.info('Status queued for posting...') } const handleCancelSchedule = async (statusId: number) => { if ( await confirm.warning('Cancel Schedule', 'Stop this status from posting?') ) { await statusScheduler.cancelScheduledStatus(statusId) } } const getStatusBadge = (status: string) => { const colors: Record<string, string> = { [StatusState.POSTED]: 'green', [StatusState.SCHEDULER]: 'blue', [StatusState.FAILED]: 'red', [StatusState.DRAFT]: 'gray', [StatusState.PENDING]: 'yellow', [StatusState.RUNNING]: 'orange', } return ( <Badge color={colors[status] || 'gray'} variant="light"> {status} </Badge> ) } return ( <> <LayoutPage title="Status Scheduler" width={750} icon={ <Icon icon="tabler:history-toggle" fontSize={24} color="#34d399" /> } description="Schedule and manage your WhatsApp Status updates." > <Stack h="100%"> {/* Refresh Hint */} <Alert variant="light" color="blue" radius="md" icon={<Icon icon="tabler:info-circle" />} > <Text size="xs"> Note: You may need to refresh WhatsApp Web to see the result of posted statuses. </Text> </Alert> <Group justify="space-between"> <Group> <TextInput placeholder="Search statuses..." leftSection={<Icon icon="tabler:search" fontSize={16} />} value={dataQuery.search} onChange={(e) => dataQuery.setSearch(e.currentTarget.value)} size="sm" /> </Group> <Group> {/* Bulk Delete Button */} {selectedRecords.length > 0 && ( <Button variant="outline" color="red" size="sm" leftSection={<Icon icon="tabler:trash" fontSize={18} />} onClick={handleBulkDelete} > Delete Selected ({selectedRecords.length}) </Button> )} <Button leftSection={<Icon icon="tabler:plus" fontSize={18} />} onClick={handleCreate} color="emerald" > New Status </Button> </Group> </Group> <Box style={{ flexGrow: 1, position: 'relative' }}> <DataTable withTableBorder borderRadius="sm" shadow="xs" striped highlightOnHover records={dataQuery.data} totalRecords={dataQuery.totalRecords} recordsPerPage={dataQuery.pageSize} page={dataQuery.page} onPageChange={dataQuery.setPage} minHeight={300} noRecordsText="No statuses found." // Selection Props selectedRecords={selectedRecords} onSelectedRecordsChange={setSelectedRecords} columns={[ { accessor: 'name', title: 'Name', width: 150, render: (r) => ( <Text size="sm" truncate fw={500}> {r.name || 'Untitled'} </Text> ), }, { accessor: 'type', width: 100, render: (r) => { const icon = r.type === StatusType.IMAGE ? 'tabler:photo' : r.type === StatusType.VIDEO ? 'tabler:video' : 'tabler:text-size' return ( <Group gap={4}> <Icon icon={icon} fontSize={16} /> <Text size="xs">{r.type.split('_')[0]}</Text> </Group> ) }, }, { accessor: 'status', width: 120, render: (r) => getStatusBadge(r.status), }, { accessor: 'schedule', title: 'Schedule / Posted', render: (r) => { if (r.status === StatusState.POSTED && r.postedAt) { return ( <Text size="xs" c="dimmed"> Posted: {dayjs(r.postedAt).format('DD MMM HH:mm')} </Text> ) } if (r.isScheduled && r.scheduledAt) { return ( <Text size="xs" c="blue"> Due: {dayjs(r.scheduledAt).format('DD MMM HH:mm')} </Text> ) } return ( <Text size="xs" c="dimmed"> - </Text> ) }, }, { accessor: 'actions', textAlign: 'right', width: 140, render: (r) => ( <Group gap={4} justify="flex-end" wrap="nowrap"> {r.status === StatusState.SCHEDULER && ( <Tooltip label="Cancel Schedule"> <ActionIcon color="orange" variant="subtle" onClick={() => handleCancelSchedule(r.id)} > <Icon icon="tabler:calendar-off" /> </ActionIcon> </Tooltip> )} {(r.status === StatusState.DRAFT || r.status === StatusState.FAILED) && ( <Tooltip label="Post Now"> <ActionIcon color="teal" variant="subtle" onClick={() => handlePostNow(r)} > <Icon icon="tabler:send" /> </ActionIcon> </Tooltip> )} <Tooltip label={ r.status === StatusState.POSTED ? 'Cannot edit posted status' : 'Edit' } > <ActionIcon color="blue" variant="subtle" onClick={() => handleEdit(r)} // Disable edit if Running or Posted disabled={ r.status === StatusState.RUNNING || r.status === StatusState.POSTED } > <Icon icon="tabler:edit" /> </ActionIcon> </Tooltip> <Tooltip label="Delete"> <ActionIcon color="red" variant="subtle" onClick={() => handleDelete(r)} disabled={r.status === StatusState.RUNNING} > <Icon icon="tabler:trash" /> </ActionIcon> </Tooltip> </Group> ), }, ]} /> </Box> </Stack> </LayoutPage> <ModalCreateUpdateStatus opened={showModal} onClose={modalHandlers.close} data={editingStatus} /> </> ) } export default PageStatus \`\`\` # src/features/tools/bulk-mute/hooks/useBulkMute.ts \`\`\`ts import useWa from '@/hooks/useWa' import toast from '@/utils/toast' import { delay, generateRandomDelay } from '@/utils/util' import { useRef, useState } from 'react' export interface ChatItem { id: string name: string isGroup: boolean isMuted: boolean } export type MuteMode = 'mute' | 'unmute' export const useBulkMute = () => { const wa = useWa() const [isProcessing, setIsProcessing] = useState(false) const [isLoading, setIsLoading] = useState(false) const [chats, setChats] = useState<ChatItem[]>([]) const [selectedChats, setSelectedChats] = useState<string[]>([]) const [progress, setProgress] = useState({ current: 0, total: 0 }) const abortRef = useRef(false) const loadChats = async (mode: MuteMode) => { setIsLoading(true) setSelectedChats([]) try { const allChats = await wa.chat.list() const mapped: ChatItem[] = allChats .map((c: any) => ({ id: c.id, name: c.name || 'Unknown', isGroup: c.isGroup || false, isMuted: c.isMuted || false, })) .filter((c) => { return mode === 'mute' ? !c.isMuted : c.isMuted }) setChats(mapped) } catch (error) { console.error('Failed to load chats:', error) toast.error('Failed to load chats.') } finally { setIsLoading(false) } } const toggleSelect = (chatId: string) => { setSelectedChats((prev) => prev.includes(chatId) ? prev.filter((id) => id !== chatId) : [...prev, chatId], ) } const selectAll = (filteredChats: ChatItem[]) => { setSelectedChats(filteredChats.map((c) => c.id)) } const deselectAll = () => { setSelectedChats([]) } const startProcessing = async ( mode: MuteMode, durationStr: string, // '8h', '1w', 'forever' delayMin: number, delayMax: number, ) => { if (selectedChats.length === 0) return setIsProcessing(true) setProgress({ current: 0, total: selectedChats.length }) abortRef.current = false toast.info( `${mode === 'mute' ? 'Muting' : 'Unmuting'} ${selectedChats.length} chats...`, ) let seconds = 0 if (mode === 'mute') { if (durationStr === '8h') seconds = 28800 if (durationStr === '1w') seconds = 604800 if (durationStr === 'forever') seconds = 31536000 // ~1 Year } for (let i = 0; i < selectedChats.length; i++) { if (abortRef.current) break const chatId = selectedChats[i] setProgress((prev) => ({ ...prev, current: i + 1 })) try { if (mode === 'mute') { await wa.chat.mute(chatId, { duration: seconds }) } else { await wa.chat.unmute(chatId) } setChats((prev) => prev.filter((c) => c.id !== chatId)) } catch (error: any) { console.error(`Failed to process chat:`, chatId, error) } if (i < selectedChats.length - 1 && !abortRef.current) { const waitTime = generateRandomDelay(delayMin * 1000, delayMax * 1000) await delay(waitTime) } } setIsProcessing(false) setSelectedChats([]) setProgress({ current: 0, total: 0 }) if (abortRef.current) { toast.info('Process stopped.') } else { toast.success(`${mode === 'mute' ? 'Mute' : 'Unmute'} completed.`) } } const stopProcessing = () => { abortRef.current = true setIsProcessing(false) } return { loadChats, startProcessing, stopProcessing, toggleSelect, selectAll, deselectAll, chats, selectedChats, isProcessing, isLoading, progress, } } \`\`\` # src/features/tools/bulk-mute/ModalBulkMute.tsx \`\`\`tsx import LayoutModal from '@/components/Layout/LayoutModal' import confirm from '@/utils/confirm' import { Icon } from '@iconify/react' import { ActionIcon, Badge, Button, Checkbox, Group, NumberInput, Progress, ScrollArea, SegmentedControl, Select, Stack, Text, ThemeIcon, Tooltip, } from '@mantine/core' import React, { useEffect, useMemo, useState } from 'react' import { When } from 'react-if' import { useBulkMute, type MuteMode } from './hooks/useBulkMute' interface Props { opened: boolean onClose: () => void } const ModalBulkMute: React.FC<Props> = ({ opened, onClose }) => { const { loadChats, startProcessing, stopProcessing, toggleSelect, selectAll, deselectAll, chats, selectedChats, isProcessing, isLoading, progress, } = useBulkMute() const [mode, setMode] = useState<MuteMode>('mute') const [filterType, setFilterType] = useState<string>('all') const [duration, setDuration] = useState<string>('8h') const [delayMin, setDelayMin] = useState(1) const [delayMax, setDelayMax] = useState(3) useEffect(() => { if (opened) { loadChats(mode) } }, [opened, mode]) const filteredChats = useMemo(() => { return chats.filter((chat) => { if (filterType === 'personal') return !chat.isGroup if (filterType === 'group') return chat.isGroup return true }) }, [chats, filterType]) const handleClose = () => { if (!isProcessing) { deselectAll() onClose() } } const handleStart = async () => { if (selectedChats.length === 0) return const actionText = mode === 'mute' ? 'Mute' : 'Unmute' const isConfirmed = await confirm.warning( `Start ${actionText}?`, `Are you sure you want to ${actionText.toLowerCase()} ${ selectedChats.length } selected chat(s)?`, ) if (isConfirmed) { startProcessing(mode, duration, delayMin, delayMax) } } return ( <LayoutModal opened={opened} onClose={handleClose} title="Bulk Mute Manager" description="Mute or unmute notifications for multiple chats." icon={<Icon icon="tabler:volume-off" fontSize={24} />} w={600} withCloseButton={!isProcessing} > <Stack h={550} gap="md"> <Stack gap="xs" p="xs" bg="rgba(255,255,255,0.03)" style={{ borderRadius: 8 }} > <Group justify="space-between"> <Text size="sm" fw={500}> Operation Mode </Text> <SegmentedControl size="xs" value={mode} onChange={(val) => setMode(val as MuteMode)} disabled={isProcessing} data={[ { label: 'Mute Chats', value: 'mute' }, { label: 'Unmute Chats', value: 'unmute' }, ]} color={mode === 'mute' ? 'red' : 'green'} /> </Group> <When condition={mode === 'mute'}> <Select label="Mute Duration" size="xs" data={[ { value: '8h', label: '8 Hours' }, { value: '1w', label: '1 Week' }, { value: 'forever', label: 'Always' }, ]} value={duration} onChange={(val) => setDuration(val || '8h')} disabled={isProcessing} /> </When> <Group justify="space-between"> <Text size="sm" fw={500}> Filter Type </Text> <SegmentedControl size="xs" value={filterType} onChange={setFilterType} disabled={isProcessing} data={[ { label: 'All', value: 'all' }, { label: 'Personal', value: 'personal' }, { label: 'Group', value: 'group' }, ]} /> </Group> </Stack> <Group justify="space-between" mt="xs"> <Group gap="xs"> <Text fw={600} size="sm"> Chats ({filteredChats.length}) </Text> <Badge size="sm" variant="light" color="orange"> {mode === 'mute' ? 'Active' : 'Muted'} </Badge> </Group> <Group gap="xs"> <Button size="xs" variant="subtle" onClick={() => selectAll(filteredChats)} disabled={isProcessing || filteredChats.length === 0} > Select All </Button> <Button size="xs" variant="subtle" color="gray" onClick={deselectAll} disabled={isProcessing || selectedChats.length === 0} > Deselect </Button> <Tooltip label="Refresh List"> <ActionIcon variant="subtle" color="gray" onClick={() => loadChats(mode)} disabled={isProcessing} loading={isLoading} > <Icon icon="tabler:refresh" /> </ActionIcon> </Tooltip> </Group> </Group> <ScrollArea style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.2)', borderRadius: 8, border: '1px solid rgba(255,255,255,0.05)', }} p="xs" > {isLoading ? ( <Stack align="center" justify="center" h={250} c="dimmed"> <Icon icon="tabler:loader-2" fontSize={32} className="spin" /> <Text size="sm">Loading chats...</Text> </Stack> ) : filteredChats.length === 0 ? ( <Stack align="center" justify="center" h={250} c="dimmed"> <Icon icon="tabler:inbox-off" fontSize={32} /> <Text size="sm">No chats found.</Text> </Stack> ) : ( <Stack gap={4}> {filteredChats.map((chat) => ( <Group key={chat.id} justify="space-between" p={6} style={{ borderRadius: 6, backgroundColor: selectedChats.includes(chat.id) ? 'rgba(255, 150, 150, 0.1)' : 'transparent', cursor: isProcessing ? 'not-allowed' : 'pointer', transition: 'background-color 0.2s', }} onClick={() => !isProcessing && toggleSelect(chat.id)} > <Group gap="sm" wrap="nowrap" style={{ overflow: 'hidden' }}> <Checkbox checked={selectedChats.includes(chat.id)} onChange={() => toggleSelect(chat.id)} disabled={isProcessing} size="xs" color="red" style={{ pointerEvents: 'none' }} /> <ThemeIcon size="sm" radius="xl" color={chat.isGroup ? 'indigo' : 'blue'} variant="light" > <Icon icon={chat.isGroup ? 'tabler:users' : 'tabler:user'} fontSize={12} /> </ThemeIcon> <Text size="sm" truncate> {chat.name} </Text> </Group> </Group> ))} </Stack> )} </ScrollArea> <When condition={isProcessing}> <Stack gap={4}> <Group justify="space-between"> <Text size="xs" fw={500} c="dimmed"> Processing... </Text> <Text size="xs" fw={700}> {progress.current} / {progress.total} </Text> </Group> <Progress value={ progress.total > 0 ? (progress.current / progress.total) * 100 : 0 } animated size="sm" color="red" /> </Stack> </When> <Group justify="space-between" align="flex-end"> <Group grow gap="xs"> <NumberInput label="Min Delay (s)" min={0.5} step={0.5} value={delayMin} onChange={(val) => setDelayMin(Number(val) || 1)} disabled={isProcessing} size="xs" w={100} /> <NumberInput label="Max Delay (s)" min={1} step={0.5} value={delayMax} onChange={(val) => setDelayMax(Number(val) || 3)} disabled={isProcessing} size="xs" w={100} /> </Group> {isProcessing ? ( <Button color="red" onClick={stopProcessing} leftSection={<Icon icon="tabler:player-stop" />} > Stop </Button> ) : ( <Button color="red" onClick={handleStart} disabled={selectedChats.length === 0} leftSection={ <Icon icon={mode === 'mute' ? 'tabler:volume-off' : 'tabler:volume'} /> } > {mode === 'mute' ? 'Mute' : 'Unmute'} ({selectedChats.length}) </Button> )} </Group> </Stack> </LayoutModal> ) } export default ModalBulkMute \`\`\` # src/features/tools/bulk-pin/hooks/useBulkPin.ts \`\`\`ts import useWa from '@/hooks/useWa' import toast from '@/utils/toast' import { delay, generateRandomDelay } from '@/utils/util' import { useRef, useState } from 'react' export interface ChatItem { id: string name: string avatar?: string isGroup: boolean isPinned: boolean } export type PinMode = 'pin' | 'unpin' export const useBulkPin = () => { const wa = useWa() const [isProcessing, setIsProcessing] = useState(false) const [isLoading, setIsLoading] = useState(false) const [chats, setChats] = useState<ChatItem[]>([]) const [selectedChats, setSelectedChats] = useState<string[]>([]) const [progress, setProgress] = useState({ current: 0, total: 0 }) const abortRef = useRef(false) const loadChats = async (mode: PinMode) => { setIsLoading(true) setSelectedChats([]) try { const allChats = await wa.chat.list() const mapped: ChatItem[] = allChats .filter((c: any) => { // Jika mode 'pin', ambil yang BELUM dipin // Jika mode 'unpin', ambil yang SUDAH dipin return mode === 'pin' ? !c.isPinned : c.isPinned }) .map((c: any) => ({ id: c.id, avatar: c.avatar, name: c.name || 'Unknown', isGroup: c.isGroup || false, isPinned: c.isPinned, })) setChats(mapped) } catch (error) { console.error('Failed to load chats:', error) toast.error('Failed to load chats.') } finally { setIsLoading(false) } } const toggleSelect = (chatId: string) => { setSelectedChats((prev) => prev.includes(chatId) ? prev.filter((id) => id !== chatId) : [...prev, chatId], ) } const selectAll = (filteredChats: ChatItem[]) => { setSelectedChats(filteredChats.map((c) => c.id)) } const deselectAll = () => { setSelectedChats([]) } const startProcessing = async ( mode: PinMode, delayMin: number, delayMax: number, ) => { if (selectedChats.length === 0) { toast.error('No chats selected.') return } setIsProcessing(true) setProgress({ current: 0, total: selectedChats.length }) abortRef.current = false const actionText = mode === 'pin' ? 'Pinning' : 'Unpinning' toast.info(`${actionText} ${selectedChats.length} chats...`) const pinAction = mode === 'pin' for (let i = 0; i < selectedChats.length; i++) { if (abortRef.current) break const chatId = selectedChats[i] setProgress((prev) => ({ ...prev, current: i + 1 })) try { await wa.chat.pin(chatId, pinAction) // Hapus dari list lokal setChats((prev) => prev.filter((c) => c.id !== chatId)) } catch (error: any) { console.error(`Failed to process chat:`, chatId, error) } if (i < selectedChats.length - 1 && !abortRef.current) { const waitTime = generateRandomDelay(delayMin * 1000, delayMax * 1000) await delay(waitTime) } } setIsProcessing(false) setSelectedChats([]) setProgress({ current: 0, total: 0 }) if (abortRef.current) { toast.info('Process stopped.') } else { toast.success(`${mode === 'pin' ? 'Pin' : 'Unpin'} completed.`) } } const stopProcessing = () => { abortRef.current = true setIsProcessing(false) } return { loadChats, startProcessing, stopProcessing, toggleSelect, selectAll, deselectAll, chats, selectedChats, isProcessing, isLoading, progress, } } \`\`\` # src/features/tools/bulk-pin/ModalBulkPin.tsx \`\`\`tsx import LayoutModal from '@/components/Layout/LayoutModal' import confirm from '@/utils/confirm' import { Icon } from '@iconify/react' import { ActionIcon, Badge, Button, Checkbox, Group, NumberInput, Progress, ScrollArea, SegmentedControl, Stack, Text, ThemeIcon, Tooltip, } from '@mantine/core' import React, { useEffect, useMemo, useState } from 'react' import { When } from 'react-if' import { useBulkPin, type PinMode } from './hooks/useBulkPin' interface Props { opened: boolean onClose: () => void } const ModalBulkPin: React.FC<Props> = ({ opened, onClose }) => { const { loadChats, startProcessing, stopProcessing, toggleSelect, selectAll, deselectAll, chats, selectedChats, isProcessing, isLoading, progress, } = useBulkPin() const [mode, setMode] = useState<PinMode>('pin') const [filterType, setFilterType] = useState<string>('all') const [delayMin, setDelayMin] = useState(1) const [delayMax, setDelayMax] = useState(3) useEffect(() => { if (opened) { loadChats(mode) } }, [opened, mode]) const filteredChats = useMemo(() => { return chats.filter((chat) => { if (filterType === 'personal') return !chat.isGroup if (filterType === 'group') return chat.isGroup return true }) }, [chats, filterType]) const handleClose = () => { if (!isProcessing) { deselectAll() onClose() } } const handleStart = async () => { if (selectedChats.length === 0) return const actionText = mode === 'pin' ? 'Pin' : 'Unpin' const isConfirmed = await confirm.warning( `Start ${actionText}?`, `Are you sure you want to ${actionText.toLowerCase()} ${ selectedChats.length } selected chat(s)?`, ) if (isConfirmed) { startProcessing(mode, delayMin, delayMax) } } return ( <LayoutModal opened={opened} onClose={handleClose} title="Bulk Pin Manager" description="Pin or unpin multiple chats at once." icon={<Icon icon="tabler:pin" fontSize={24} />} w={600} withCloseButton={!isProcessing} > <Stack h={550} gap="md"> <Stack gap="xs" p="xs" bg="rgba(255,255,255,0.03)" style={{ borderRadius: 8 }} > <Group justify="space-between"> <Text size="sm" fw={500}> Operation Mode </Text> <SegmentedControl size="xs" value={mode} onChange={(val) => setMode(val as PinMode)} disabled={isProcessing} data={[ { label: 'Pin Chats', value: 'pin' }, { label: 'Unpin Chats', value: 'unpin' }, ]} color={mode === 'pin' ? 'grape' : 'gray'} /> </Group> <Group justify="space-between"> <Text size="sm" fw={500}> Filter Type </Text> <SegmentedControl size="xs" value={filterType} onChange={setFilterType} disabled={isProcessing} data={[ { label: 'All', value: 'all' }, { label: 'Personal', value: 'personal' }, { label: 'Group', value: 'group' }, ]} /> </Group> </Stack> <Group justify="space-between" mt="xs"> <Group gap="xs"> <Text fw={600} size="sm"> Chats ({filteredChats.length}) </Text> <Badge size="sm" variant="light" color="grape"> {mode === 'pin' ? 'Unpinned' : 'Pinned'} </Badge> </Group> <Group gap="xs"> <Button size="xs" variant="subtle" onClick={() => selectAll(filteredChats)} disabled={isProcessing || filteredChats.length === 0} > Select All </Button> <Button size="xs" variant="subtle" color="gray" onClick={deselectAll} disabled={isProcessing || selectedChats.length === 0} > Deselect </Button> <Tooltip label="Refresh List"> <ActionIcon variant="subtle" color="gray" onClick={() => loadChats(mode)} disabled={isProcessing} loading={isLoading} > <Icon icon="tabler:refresh" /> </ActionIcon> </Tooltip> </Group> </Group> <ScrollArea style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.2)', borderRadius: 8, border: '1px solid rgba(255,255,255,0.05)', }} p="xs" > {isLoading ? ( <Stack align="center" justify="center" h={250} c="dimmed"> <Icon icon="tabler:loader-2" fontSize={32} className="spin" /> <Text size="sm">Loading chats...</Text> </Stack> ) : filteredChats.length === 0 ? ( <Stack align="center" justify="center" h={250} c="dimmed"> <Icon icon="tabler:inbox-off" fontSize={32} /> <Text size="sm">No chats found.</Text> </Stack> ) : ( <Stack gap={4}> {filteredChats.map((chat) => ( <Group key={chat.id} justify="space-between" p={6} style={{ borderRadius: 6, backgroundColor: selectedChats.includes(chat.id) ? 'rgba(192, 132, 252, 0.1)' : 'transparent', cursor: isProcessing ? 'not-allowed' : 'pointer', transition: 'background-color 0.2s', }} onClick={() => !isProcessing && toggleSelect(chat.id)} > <Group gap="sm" wrap="nowrap" style={{ overflow: 'hidden' }}> <Checkbox checked={selectedChats.includes(chat.id)} onChange={() => toggleSelect(chat.id)} disabled={isProcessing} size="xs" color="grape" style={{ pointerEvents: 'none' }} /> <ThemeIcon size="sm" radius="xl" color={chat.isGroup ? 'indigo' : 'blue'} variant="light" > <Icon icon={chat.isGroup ? 'tabler:users' : 'tabler:user'} fontSize={12} /> </ThemeIcon> <Text size="sm" truncate> {chat.name} </Text> </Group> </Group> ))} </Stack> )} </ScrollArea> <When condition={isProcessing}> <Stack gap={4}> <Group justify="space-between"> <Text size="xs" fw={500} c="dimmed"> Processing... </Text> <Text size="xs" fw={700}> {progress.current} / {progress.total} </Text> </Group> <Progress value={ progress.total > 0 ? (progress.current / progress.total) * 100 : 0 } animated size="sm" color="grape" /> </Stack> </When> <Group justify="space-between" align="flex-end"> <Group grow gap="xs"> <NumberInput label="Min Delay (s)" min={0.5} step={0.5} value={delayMin} onChange={(val) => setDelayMin(Number(val) || 1)} disabled={isProcessing} size="xs" w={100} /> <NumberInput label="Max Delay (s)" min={1} step={0.5} value={delayMax} onChange={(val) => setDelayMax(Number(val) || 3)} disabled={isProcessing} size="xs" w={100} /> </Group> {isProcessing ? ( <Button color="red" onClick={stopProcessing} leftSection={<Icon icon="tabler:player-stop" />} > Stop </Button> ) : ( <Button color="grape" onClick={handleStart} disabled={selectedChats.length === 0} leftSection={ <Icon icon={mode === 'pin' ? 'tabler:pin' : 'tabler:pin-off'} /> } > {mode === 'pin' ? 'Pin' : 'Unpin'} ({selectedChats.length}) </Button> )} </Group> </Stack> </LayoutModal> ) } export default ModalBulkPin \`\`\` # src/features/tools/chat-archiver/hooks/useChatArchiver.ts \`\`\`ts import useWa from '@/hooks/useWa' import toast from '@/utils/toast' import { delay, generateRandomDelay } from '@/utils/util' import { useRef, useState } from 'react' export interface ChatItem { id: string name: string avatar?: string isGroup: boolean isArchived: boolean } export type ArchiverMode = 'archive' | 'unarchive' export const useChatArchiver = () => { const wa = useWa() const [isProcessing, setIsProcessing] = useState(false) const [isLoading, setIsLoading] = useState(false) const [chats, setChats] = useState<ChatItem[]>([]) const [selectedChats, setSelectedChats] = useState<string[]>([]) // Progress State untuk melacak kemajuan const [progress, setProgress] = useState({ current: 0, total: 0 }) const abortRef = useRef(false) // Load chats berdasarkan mode (Archive vs Unarchive) const loadChats = async (mode: ArchiverMode) => { setIsLoading(true) setSelectedChats([]) // Reset seleksi saat reload try { const allChats = await wa.chat.list({}) const mapped: ChatItem[] = allChats .filter((c: any) => { // Jika mode 'archive', ambil chat yang BELUM di-archive (!isArchived) // Jika mode 'unarchive', ambil chat yang SUDAH di-archive (isArchived) return mode === 'archive' ? !c.isArchived : c.isArchived }) .map((c: any) => ({ id: c.id, avatar: c.contact?.avatar, name: c.name || 'Unknown', isGroup: c.contact?.isGroup || false, isArchived: c.isArchived, })) setChats(mapped) } catch (error) { console.error('Failed to load chats:', error) toast.error('Failed to load chats.') } finally { setIsLoading(false) } } const toggleSelect = (chatId: string) => { setSelectedChats((prev) => prev.includes(chatId) ? prev.filter((id) => id !== chatId) : [...prev, chatId], ) } const selectAll = (filteredChats: ChatItem[]) => { setSelectedChats(filteredChats.map((c) => c.id)) } const deselectAll = () => { setSelectedChats([]) } const startProcessing = async ( mode: ArchiverMode, delayMin: number, delayMax: number, ) => { if (selectedChats.length === 0) { toast.error('No chats selected.') return } setIsProcessing(true) setProgress({ current: 0, total: selectedChats.length }) abortRef.current = false const actionText = mode === 'archive' ? 'Archiving' : 'Unarchiving' toast.info(`${actionText} ${selectedChats.length} chats...`) // API archive: true = archive, false = unarchive const archiveAction = mode === 'archive' for (let i = 0; i < selectedChats.length; i++) { if (abortRef.current) break const chatId = selectedChats[i] // Update Progress setProgress((prev) => ({ ...prev, current: i + 1 })) try { await wa.chat.archive(chatId, archiveAction) // Hapus dari list lokal agar UI terupdate real-time setChats((prev) => prev.filter((c) => c.id !== chatId)) } catch (error: any) { console.error(`Failed to process chat:`, chatId, error) } // Delay antar aksi if (i < selectedChats.length - 1 && !abortRef.current) { const waitTime = generateRandomDelay(delayMin * 1000, delayMax * 1000) await delay(waitTime) } } setIsProcessing(false) setSelectedChats([]) // Reset seleksi setelah selesai setProgress({ current: 0, total: 0 }) if (abortRef.current) { toast.info('Process stopped.') } else { toast.success( `${mode === 'archive' ? 'Archive' : 'Unarchive'} completed.`, ) } } const stopProcessing = () => { abortRef.current = true setIsProcessing(false) } return { loadChats, startProcessing, stopProcessing, toggleSelect, selectAll, deselectAll, chats, selectedChats, isProcessing, isLoading, progress, } } \`\`\` # src/features/tools/chat-archiver/ModalBulkChatArchiver.tsx \`\`\`tsx import LayoutModal from '@/components/Layout/LayoutModal' import confirm from '@/utils/confirm' // ++ ADDED: Import confirm utility import { Icon } from '@iconify/react' import { ActionIcon, Badge, Button, Checkbox, Group, NumberInput, Progress, ScrollArea, SegmentedControl, Stack, Text, ThemeIcon, Tooltip, } from '@mantine/core' import React, { useEffect, useMemo, useState } from 'react' import { When } from 'react-if' import { useChatArchiver, type ArchiverMode } from './hooks/useChatArchiver' interface Props { opened: boolean onClose: () => void } const ModalBulkChatArchiver: React.FC<Props> = ({ opened, onClose }) => { const { loadChats, startProcessing, stopProcessing, toggleSelect, selectAll, deselectAll, chats, selectedChats, isProcessing, isLoading, progress, } = useChatArchiver() const [mode, setMode] = useState<ArchiverMode>('archive') const [filterType, setFilterType] = useState<string>('all') const [delayMin, setDelayMin] = useState(1) const [delayMax, setDelayMax] = useState(3) useEffect(() => { if (opened) { loadChats(mode) } // eslint-disable-next-line react-hooks/exhaustive-deps }, [opened, mode]) const filteredChats = useMemo(() => { return chats.filter((chat) => { if (filterType === 'personal') return !chat.isGroup if (filterType === 'group') return chat.isGroup return true }) }, [chats, filterType]) const handleClose = () => { if (!isProcessing) { deselectAll() onClose() } } const handleSelectAll = () => { selectAll(filteredChats) } // ++ ADDED: Handler untuk konfirmasi sebelum proses const handleStart = async () => { if (selectedChats.length === 0) return const actionText = mode === 'archive' ? 'Archive' : 'Unarchive' // Tampilkan modal konfirmasi const isConfirmed = await confirm.warning( `Start ${actionText}?`, `Are you sure you want to ${actionText.toLowerCase()} ${selectedChats.length} selected chat(s)? This process will run automatically.`, ) // Jika user menekan Confirm, jalankan proses if (isConfirmed) { startProcessing(mode, delayMin, delayMax) } } return ( <LayoutModal opened={opened} onClose={handleClose} title="Bulk Chat Archiver" description="Manage your chat archive status in bulk." icon={<Icon icon="tabler:archive" fontSize={24} />} w={600} withCloseButton={!isProcessing} > <Stack h={550} gap="md"> {/* Controls Section */} <Stack gap="xs" p="xs" bg="rgba(255,255,255,0.03)" style={{ borderRadius: 8 }} > <Group justify="space-between"> <Text size="sm" fw={500}> Operation Mode </Text> <SegmentedControl size="xs" value={mode} onChange={(val) => setMode(val as ArchiverMode)} disabled={isProcessing} data={[ { label: 'Archive', value: 'archive' }, { label: 'Unarchive', value: 'unarchive' }, ]} color={mode === 'archive' ? 'pink' : 'blue'} /> </Group> <Group justify="space-between"> <Text size="sm" fw={500}> Filter Type </Text> <SegmentedControl size="xs" value={filterType} onChange={setFilterType} disabled={isProcessing} data={[ { label: ( <Group gap={6} wrap="nowrap"> <Icon icon="tabler:list" fontSize={14} /> All </Group> ), value: 'all', }, { label: ( <Group gap={6} wrap="nowrap"> <Icon icon="tabler:user" fontSize={14} /> Personal </Group> ), value: 'personal', }, { label: ( <Group gap={6} wrap="nowrap"> <Icon icon="tabler:users" fontSize={14} /> Group </Group> ), value: 'group', }, ]} /> </Group> </Stack> {/* List Header */} <Group justify="space-between" mt="xs"> <Group gap="xs"> <Text fw={600} size="sm"> Chats ({filteredChats.length}) </Text> <Badge size="sm" variant="light" color={mode === 'archive' ? 'pink' : 'blue'} > {mode === 'archive' ? 'Active' : 'Archived'} </Badge> </Group> <Group gap="xs"> <Button size="xs" variant="subtle" onClick={handleSelectAll} disabled={isProcessing || filteredChats.length === 0} > Select All </Button> <Button size="xs" variant="subtle" color="gray" onClick={deselectAll} disabled={isProcessing || selectedChats.length === 0} > Deselect </Button> <Tooltip label="Refresh List"> <ActionIcon variant="subtle" color="gray" onClick={() => loadChats(mode)} disabled={isProcessing} loading={isLoading} > <Icon icon="tabler:refresh" /> </ActionIcon> </Tooltip> </Group> </Group> {/* Chat List Area */} <ScrollArea style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.2)', borderRadius: 8, border: '1px solid rgba(255,255,255,0.05)', }} p="xs" > {isLoading ? ( <Stack align="center" justify="center" h={250} c="dimmed"> <Icon icon="tabler:loader-2" fontSize={32} className="spin" /> <Text size="sm">Loading chats...</Text> </Stack> ) : filteredChats.length === 0 ? ( <Stack align="center" justify="center" h={250} c="dimmed"> <Icon icon="tabler:inbox-off" fontSize={32} /> <Text size="sm">No chats found for this filter.</Text> </Stack> ) : ( <Stack gap={4}> {filteredChats.map((chat) => ( <Group key={chat.id} justify="space-between" p={6} style={{ borderRadius: 6, backgroundColor: selectedChats.includes(chat.id) ? 'rgba(52, 211, 153, 0.1)' : 'transparent', cursor: isProcessing ? 'not-allowed' : 'pointer', transition: 'background-color 0.2s', }} onClick={() => !isProcessing && toggleSelect(chat.id)} > <Group gap="sm" wrap="nowrap" style={{ overflow: 'hidden' }}> <Checkbox checked={selectedChats.includes(chat.id)} onChange={() => toggleSelect(chat.id)} disabled={isProcessing} size="xs" style={{ pointerEvents: 'none' }} /> <ThemeIcon size="sm" radius="xl" color={chat.isGroup ? 'indigo' : 'blue'} variant="light" > <Icon icon={chat.isGroup ? 'tabler:users' : 'tabler:user'} fontSize={12} /> </ThemeIcon> <Text size="sm" truncate> {chat.name} </Text> </Group> </Group> ))} </Stack> )} </ScrollArea> {/* Progress Bar */} <When condition={isProcessing}> <Stack gap={4}> <Group justify="space-between"> <Text size="xs" fw={500} c="dimmed"> Processing... </Text> <Text size="xs" fw={700}> {progress.current} / {progress.total} </Text> </Group> <Progress value={ progress.total > 0 ? (progress.current / progress.total) * 100 : 0 } animated size="sm" color={mode === 'archive' ? 'pink' : 'blue'} /> </Stack> </When> {/* Footer Settings & Actions */} <Group justify="space-between" align="flex-end"> <Group grow gap="xs"> <NumberInput label="Min Delay (s)" min={0.5} step={0.5} decimalScale={1} value={delayMin} onChange={(val) => setDelayMin(Number(val) || 1)} disabled={isProcessing} size="xs" w={100} /> <NumberInput label="Max Delay (s)" min={1} step={0.5} decimalScale={1} value={delayMax} onChange={(val) => setDelayMax(Number(val) || 3)} disabled={isProcessing} size="xs" w={100} /> </Group> {isProcessing ? ( <Button color="red" onClick={stopProcessing} leftSection={<Icon icon="tabler:player-stop" />} > Stop </Button> ) : ( <Button color={mode === 'archive' ? 'pink' : 'blue'} onClick={handleStart} // ++ UPDATED: Call handleStart instead of startProcessing directly disabled={selectedChats.length === 0} leftSection={ <Icon icon={ mode === 'archive' ? 'tabler:archive' : 'tabler:archive-off' } /> } > {mode === 'archive' ? 'Archive' : 'Unarchive'} ( {selectedChats.length}) </Button> )} </Group> </Stack> </LayoutModal> ) } export default ModalBulkChatArchiver \`\`\` # src/features/tools/contact-scraper/hooks/useContactScraper.ts \`\`\`ts import { AccountType, ContactType, MessageType, SaveAs } from '@/constants' import useFile from '@/hooks/useFile' import useLicense from '@/hooks/useLicense' import useWa from '@/hooks/useWa' import filterBy from '@/utils/filterBy' import toast from '@/utils/toast' import { useForm } from '@mantine/form' import _ from 'lodash' import { useState } from 'react' export const useContactScraper = () => { const wa = useWa() const license = useLicense() const fileExporter = useFile() const [isExporting, setIsExporting] = useState(false) const form = useForm({ initialValues: { contactType: ContactType.ALL, messageType: MessageType.ALL, accountType: AccountType.ALL, saveAs: SaveAs.CSV, }, }) const getContacts = async () => { const me = await wa.conn.getMyUserId() const { contactType, messageType, accountType } = form.values // @ts-ignore const contacts = (await wa.contact.list()) ?? [] return contacts .filter((contact: any) => contact.id?.user !== me?.user) // Exclude self .filter((contact: any) => !contact.id?.user?.includes(':')) // Exclude LID .filter((contact: any) => filterBy.contactType(contact, contactType)) .filter((contact: any) => filterBy.messageType(contact, messageType)) .filter((contact: any) => filterBy.accountType(contact, accountType)) .map((contact: any) => ({ Name: contact.name || contact.pushname || 'Unknown', Number: contact.id?.user || '', 'Is Business': contact.isBusiness ? 'Yes' : 'No', 'Is Saved': contact.isMyContact ? 'Yes' : 'No', })) } const handleExport = async () => { if (form.validate().hasErrors) return setIsExporting(true) try { const data = await getContacts() if (data.length === 0) { toast.info('No contacts found.') return } // Apply masking for free users (limit 10 records) let finalData = data if (license.isFree()) { finalData = data.map((item: any, index: number) => { if (index >= 10) { return _.mapValues(item, () => '********') } return item }) } const filename = `contacts_${new Date().toISOString().slice(0, 10).replace(/-/g, '')}` await fileExporter.saveAs(form.values.saveAs, finalData, filename) } catch (error) { console.error('Export failed:', error) toast.error('An error occurred during export.') } finally { setIsExporting(false) } } const reset = () => { form.reset() } return { form, isExporting, handleExport, reset, } } \`\`\` # src/features/tools/contact-scraper/ModalContactScraper.tsx \`\`\`tsx import AlertBanner from '@/components/AlertBanner' import LayoutModal from '@/components/Layout/LayoutModal' import { AccountType, ContactType, MessageType, SaveAs } from '@/constants' import { Icon } from '@iconify/react' import { Button, Group, Radio, Select, Stack } from '@mantine/core' import React from 'react' import { useContactScraper } from './hooks/useContactScraper' interface Props { opened: boolean onClose: () => void } const ModalContactScraper: React.FC<Props> = ({ opened, onClose }) => { const { form, isExporting, handleExport, reset } = useContactScraper() const handleClose = () => { if (!isExporting) { reset() onClose() } } const handleSubmit = async () => { await handleExport() } return ( <LayoutModal opened={opened} onClose={handleClose} title="Contact Scraper" description="Export all your WhatsApp contacts." icon={<Icon icon="tabler:address-book" fontSize={24} />} w={650} withCloseButton={!isExporting} > <Stack gap="md"> <Select label="Contact Type" size="sm" {...form.getInputProps('contactType')} data={[ { label: 'All', value: ContactType.ALL }, { label: 'Saved Contacts', value: ContactType.SAVED_CONTACTS }, { label: 'Unsaved Contacts', value: ContactType.UNSAVED_CONTACTS }, ]} disabled={isExporting} /> <Select label="Message Type" size="sm" {...form.getInputProps('messageType')} data={[ { label: 'All', value: MessageType.ALL }, { label: 'Have Unread Messages', value: MessageType.HAVE_UNREAD_MESSAGES, }, { label: 'No Unread Messages', value: MessageType.NO_UNREAD_MESSAGES, }, ]} disabled={isExporting} /> <Select label="Account Type" size="sm" {...form.getInputProps('accountType')} data={[ { label: 'All', value: AccountType.ALL }, { label: 'Personal', value: AccountType.PERSONAL }, { label: 'Business', value: AccountType.BUSINESS }, ]} disabled={isExporting} /> <Radio.Group label="Export Format" value={form.values.saveAs} onChange={(val) => form.setFieldValue('saveAs', val)} > <Group mt="xs"> <Radio value={SaveAs.CSV} label="CSV" disabled={isExporting} /> <Radio value={SaveAs.EXCEL} label="Excel" disabled={isExporting} /> </Group> </Radio.Group> <AlertBanner message="Limited to 10 contacts in the free version. Go unlimited " /> <Group justify="flex-end" mt="md"> <Button variant="subtle" onClick={handleClose} disabled={isExporting}> Cancel </Button> <Button color="emerald" leftSection={<Icon icon="tabler:download" />} onClick={handleSubmit} loading={isExporting} > Export </Button> </Group> </Stack> </LayoutModal> ) } export default ModalContactScraper \`\`\` # src/features/tools/group-scraper/hooks/useGroupMemberScraper.ts \`\`\`ts import { AccountType, ContactType, SaveAs } from '@/constants' import useFile from '@/hooks/useFile' import useLicense from '@/hooks/useLicense' import { useAppStore } from '@/stores/app' import filterBy from '@/utils/filterBy' import toast from '@/utils/toast' import { useForm } from '@mantine/form' import _ from 'lodash' import { useCallback, useState } from 'react' export const useGroupMemberScraper = () => { const license = useLicense() const { groups } = useAppStore() const fileExporter = useFile() const [isExporting, setIsExporting] = useState(false) const form = useForm({ initialValues: { selectedGroups: [] as string[], contactType: ContactType.ALL, accountType: AccountType.ALL, includeAdmin: true, saveAs: SaveAs.CSV, }, validate: { selectedGroups: (value) => { if (_.isEmpty(value)) { return 'Please select at least one group' } return null }, }, }) const getGroupMembers = useCallback(async () => { const { selectedGroups, accountType, includeAdmin, contactType } = form.values // Mock "me" for filtering (we don't include ourselves) const me = { user: '' } // Will filter out admin if needed return _.chain(groups) .filter((group: any) => selectedGroups.includes(group.id)) .flatMap((group: any) => { return group.participants.map((participant: any) => ({ ...participant, groupName: group.name, groupId: group.id, })) }) .filter((participant: any) => filterBy.accountType(participant, accountType), ) .filter((participant: any) => filterBy.includeAdmin(participant, includeAdmin), ) .filter((participant: any) => filterBy.contactType(participant, contactType), ) .map((item) => { const { contact, ...rest } = item return { Name: contact?.name || 'Unknown', Number: contact?.number?.split('@')[0] || rest.id?.split('@')[0] || '', 'Is Admin': rest.isAdmin ? 'Yes' : 'No', 'Is Super Admin': rest.isSuperAdmin ? 'Yes' : 'No', Group: rest.groupName, } }) .value() }, [groups, form.values]) const handleExport = async () => { if (form.validate().hasErrors) return setIsExporting(true) try { const data = await getGroupMembers() if (data.length === 0) { toast.info('No members found matching criteria.') return } // Apply masking for free users (limit 10 records) let finalData = data if (license.isFree()) { finalData = data.map((item, index) => { if (index >= 10) { return _.mapValues(item, () => '********') } return item }) } const filename = `group_members_${new Date().toISOString().slice(0, 10).replace(/-/g, '')}` await fileExporter.saveAs(form.values.saveAs, finalData, filename) } catch (error) { console.error('Export failed:', error) toast.error('An error occurred during export.') } finally { setIsExporting(false) } } const reset = () => { form.reset() } return { form, groups, isExporting, handleExport, reset, } } \`\`\` # src/features/tools/group-scraper/ModalGroupMemberScraper.tsx \`\`\`tsx import AlertBanner from '@/components/AlertBanner' import LayoutModal from '@/components/Layout/LayoutModal' import { SaveAs } from '@/constants' import { Icon } from '@iconify/react' import { Button, Group, MultiSelect, Radio, Stack, Switch } from '@mantine/core' import React, { useMemo } from 'react' import { useGroupMemberScraper } from './hooks/useGroupMemberScraper' interface Props { opened: boolean onClose: () => void } const ModalGroupMemberScraper: React.FC<Props> = ({ opened, onClose }) => { const { form, groups, isExporting, handleExport, reset } = useGroupMemberScraper() const groupOptions = useMemo(() => { return groups.map((group: any) => ({ label: `${group.name || 'Unknown'} (${group.participants?.length || 0})`, value: group.id, })) }, [groups]) const handleClose = () => { if (!isExporting) { reset() onClose() } } const handleSubmit = async () => { await handleExport() } return ( <LayoutModal opened={opened} onClose={handleClose} title="Group Member Scraper" description="Export members from your groups." icon={<Icon icon="tabler:users-group" fontSize={24} />} w={650} withCloseButton={!isExporting} > <Stack gap="md"> <MultiSelect label="Select Groups" size="sm" placeholder="Choose groups to scrape" data={groupOptions} {...form.getInputProps('selectedGroups')} searchable clearable maxDropdownHeight={200} nothingFoundMessage="No groups found" disabled={isExporting} /> <Switch label="Include Admins" {...form.getInputProps('includeAdmin', { type: 'checkbox' })} disabled={isExporting} /> <Radio.Group label="Export Format" value={form.values.saveAs} onChange={(val) => form.setFieldValue('saveAs', val)} > <Group mt="xs"> <Radio value={SaveAs.CSV} label="CSV" disabled={isExporting} /> <Radio value={SaveAs.EXCEL} label="Excel" disabled={isExporting} /> </Group> </Radio.Group> <AlertBanner message="Limited to 10 members in the free version. Go unlimited" /> <Group justify="flex-end" mt="md"> <Button variant="subtle" onClick={handleClose} disabled={isExporting}> Cancel </Button> <Button color="emerald" leftSection={<Icon icon="tabler:download" />} onClick={handleSubmit} loading={isExporting} > Export </Button> </Group> </Stack> </LayoutModal> ) } export default ModalGroupMemberScraper \`\`\` # src/features/tools/link-generator/ModalLinkGenerator.tsx \`\`\`tsx import InputTextarea from '@/components/Input/InputTextarea' import LayoutModal from '@/components/Layout/LayoutModal' import { Setting } from '@/constants' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { ActionIcon, Button, Code, CopyButton, Group, Stack, Text, TextInput, Tooltip, } from '@mantine/core' import { useForm } from '@mantine/form' import { useStorage } from '@plasmohq/storage/hook' import React, { useEffect, useMemo } from 'react' interface Props { opened: boolean onClose: () => void } const ModalLinkGenerator: React.FC<Props> = ({ opened, onClose }) => { // Persist the last phone number used for convenience const [lastPhone, setLastPhone] = useStorage<string>( 'tool_link_generator_phone', '', ) const form = useForm({ initialValues: { phone: '', message: '', }, validate: { phone: (value) => value.replace(/[^0-9]/g, '').length < 5 ? 'Enter a valid phone number (e.g. 62812...)' : null, }, }) // Load last phone from storage when modal opens useEffect(() => { if (opened && lastPhone) { form.setFieldValue('phone', lastPhone) } }, [opened]) const generatedLink = useMemo(() => { const cleanPhone = form.values.phone.replace(/[^0-9]/g, '') const encodedMessage = encodeURIComponent(form.values.message) if (!cleanPhone) return '' return `https://wa.me/${cleanPhone}${ encodedMessage ? `?text=${encodedMessage}` : '' }` }, [form.values.phone, form.values.message]) const handleClose = () => { // Save phone to storage before closing if (form.values.phone) { setLastPhone(form.values.phone) } form.reset() onClose() } const handleOpenLink = () => { if (!generatedLink) return window.open(generatedLink, '_blank', 'noopener,noreferrer') } return ( <LayoutModal opened={opened} onClose={handleClose} title="Link Generator" description="Create a direct WhatsApp link with a pre-filled message." icon={<Icon icon="tabler:link" fontSize={24} />} w={600} > <Stack gap="lg"> {/* Input Section */} <Stack gap="sm"> <TextInput label="Phone Number" placeholder="e.g. 628123456789" description="Include country code, without '+' or '-'" required leftSection={<Icon icon="tabler:phone" fontSize={16} />} {...form.getInputProps('phone')} /> <Stack gap={2}> <Text size="sm" fw={500}> Message (Optional) </Text> <InputTextarea value={form.values.message} onChange={(val) => form.setFieldValue('message', val)} placeholder="Hello, I would like to inquire about..." // Pass empty array to remove variable buttons as they aren't relevant for static links variables={[]} /> </Stack> </Stack> {/* Result Section */} {generatedLink && ( <Stack gap="xs" p="md" style={{ backgroundColor: 'rgba(255, 255, 255, 0.03)', border: '1px solid rgba(255, 255, 255, 0.05)', borderRadius: 'var(--mantine-radius-md)', }} > <Group justify="space-between"> <Text size="sm" fw={500} c="dimmed"> Generated Link </Text> <Group gap={4}> <CopyButton value={generatedLink}> {({ copied, copy }) => ( <Tooltip label={copied ? 'Copied' : 'Copy'} withArrow position="left" > <ActionIcon color={copied ? 'teal' : 'gray'} variant="subtle" onClick={() => { copy() toast.success('Link copied to clipboard') }} > <Icon icon={copied ? 'tabler:check' : 'tabler:copy'} fontSize={18} /> </ActionIcon> </Tooltip> )} </CopyButton> <Tooltip label="Open" withArrow position="right"> <ActionIcon color="blue" variant="subtle" onClick={handleOpenLink} > <Icon icon="tabler:external-link" fontSize={18} /> </ActionIcon> </Tooltip> </Group> </Group> <Code block style={{ wordBreak: 'break-all', whiteSpace: 'pre-wrap', maxHeight: '100px', overflowY: 'auto', }} > {generatedLink} </Code> </Stack> )} {/* Footer Actions */} <Group justify="flex-end" mt="md"> <Button variant="default" onClick={handleClose}> Close </Button> <Button onClick={handleOpenLink} disabled={!generatedLink} color="emerald" leftSection={<Icon icon="tabler:external-link" fontSize={18} />} > Open Chat </Button> </Group> </Stack> </LayoutModal> ) } export default ModalLinkGenerator \`\`\` # src/features/tools/PageTools.tsx \`\`\`tsx import LayoutPage from '@/components/Layout/LayoutPage' import { Icon } from '@iconify/react' import { Paper, SimpleGrid, Stack, Text, ThemeIcon, UnstyledButton, } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import React from 'react' import ModalBulkMute from './bulk-mute/ModalBulkMute' // Import Modals import ModalBulkPin from './bulk-pin/ModalBulkPin' import ModalBulkChatArchiver from './chat-archiver/ModalBulkChatArchiver' import ModalContactScraper from './contact-scraper/ModalContactScraper' import ModalGroupMemberScraper from './group-scraper/ModalGroupMemberScraper' import ModalLinkGenerator from './link-generator/ModalLinkGenerator' import ModalNumberValidator from './validator/ModalNumberValidator' interface ToolItem { icon: string title: string description: string color: string action: () => void } interface ToolCategory { category: string categoryIcon: string tools: ToolItem[] } const PageTools: React.FC = () => { const [showValidator, validatorHandlers] = useDisclosure(false) const [showLinkGenerator, linkGeneratorHandlers] = useDisclosure(false) const [showArchiver, archiverHandlers] = useDisclosure(false) const [showPinManager, pinManagerHandlers] = useDisclosure(false) const [showMuteManager, muteManagerHandlers] = useDisclosure(false) const [showGroupScraper, groupScraperHandlers] = useDisclosure(false) const [showContactScraper, contactScraperHandlers] = useDisclosure(false) const toolCategories: ToolCategory[] = [ { category: 'Chat', categoryIcon: 'tabler:message-circle', tools: [ { icon: 'tabler:archive', title: 'Bulk Chat Archiver', description: 'Bulk archive unsaved or inactive chats.', color: 'pink', action: () => archiverHandlers.open(), }, { icon: 'tabler:pin', title: 'Bulk Pin Manager', description: 'Bulk pin or unpin your chats.', color: 'grape', action: () => pinManagerHandlers.open(), }, { icon: 'tabler:volume-off', title: 'Bulk Mute Manager', description: 'Bulk mute or unmute chats.', color: 'red', action: () => muteManagerHandlers.open(), }, ], }, { category: 'Group', categoryIcon: 'tabler:users-group', tools: [ { icon: 'tabler:users-group', title: 'Group Member Scraper', description: 'Export members from your groups.', color: 'indigo', action: () => groupScraperHandlers.open(), }, ], }, { category: 'Contact', categoryIcon: 'tabler:users', tools: [ { icon: 'tabler:link', title: 'Link Generator', description: 'Create direct chat links quickly.', color: 'blue', action: () => linkGeneratorHandlers.open(), }, { icon: 'tabler:checks', title: 'Number Validator', description: 'Check if numbers are valid on WA.', color: 'orange', action: () => validatorHandlers.open(), }, { icon: 'tabler:address-book', title: 'Contact Scraper', description: 'Export all your contacts.', color: 'teal', action: () => contactScraperHandlers.open(), }, ], }, ] return ( <> <LayoutPage width={700} icon={<Icon icon="tabler:tools" fontSize={24} color="#34d399" />} title="Tools" description="Quick utilities to help you work faster." > <Stack gap="xl"> {toolCategories.map((category, catIndex) => ( <Stack key={catIndex} gap="sm"> <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}> <Icon icon={category.categoryIcon} fontSize={18} color="var(--mantine-color-dimmed)" /> <Text size="sm" fw={600} c="dimmed" tt="uppercase" lts={0.5}> {category.category} </Text> </div> <SimpleGrid cols={{ base: 1, sm: 2 }} spacing="sm"> {category.tools.map((tool, index) => ( <UnstyledButton key={index} onClick={tool.action} className="tool-card-button" style={{ height: '100%' }} > <Paper p="sm" radius="md" withBorder className="tool-card" style={ { height: '100%', backgroundColor: 'rgba(255,255,255,0.02)', '--hover-border-color': `var(--mantine-color-${tool.color}-5)`, } as React.CSSProperties } > <Stack gap="xs"> <div style={{ display: 'flex', alignItems: 'flex-start', gap: 12, }} > <ThemeIcon size="lg" radius="md" color={tool.color} variant="light" > <Icon icon={tool.icon} fontSize={20} /> </ThemeIcon> <Stack gap={2}> <Text size="sm" fw={600} c="white"> {tool.title} </Text> <Text size="xs" c="dimmed" lh={1.3}> {tool.description} </Text> </Stack> </div> </Stack> </Paper> </UnstyledButton> ))} </SimpleGrid> </Stack> ))} </Stack> </LayoutPage> <ModalNumberValidator opened={showValidator} onClose={validatorHandlers.close} /> <ModalLinkGenerator opened={showLinkGenerator} onClose={linkGeneratorHandlers.close} /> {/* ModalGroupLinkGenerator and ModalBulkGroupJoiner components removed */} <ModalBulkChatArchiver opened={showArchiver} onClose={archiverHandlers.close} /> <ModalBulkPin opened={showPinManager} onClose={pinManagerHandlers.close} /> <ModalBulkMute opened={showMuteManager} onClose={muteManagerHandlers.close} /> <ModalGroupMemberScraper opened={showGroupScraper} onClose={groupScraperHandlers.close} /> <ModalContactScraper opened={showContactScraper} onClose={contactScraperHandlers.close} /> </> ) } export default PageTools \`\`\` # src/features/tools/validator/components/ResultsSection.tsx \`\`\`tsx import useLicense from '@/hooks/useLicense' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { Badge, Button, Group, Menu, Progress, ScrollArea, SegmentedControl, Stack, Text, } from '@mantine/core' import { DataTable } from 'mantine-datatable' import React, { useMemo, useState } from 'react' import type { ValidationResult } from '../hooks/useNumberValidator' interface Props { results: ValidationResult[] isValidating: boolean progress: { current: number; total: number } onExport: (data: ValidationResult[], format: 'csv' | 'xlsx') => void } const ResultsSection: React.FC<Props> = ({ results, isValidating, progress, onExport, }) => { const [filter, setFilter] = useState('All') const license = useLicense() const stats = useMemo( () => ({ valid: results.filter((r) => r.status === 'Valid').length, invalid: results.filter((r) => r.status === 'Invalid').length, total: results.length, }), [results], ) const filteredResults = useMemo(() => { if (filter === 'All') return results return results.filter((r) => r.status === filter) }, [results, filter]) const handleExportClick = (format: 'csv' | 'xlsx') => { if (license.isFree()) { toast.warning( 'Export is a Pro feature. Upgrade for unlimited exports.', 'Pro Feature', ) return } onExport(filteredResults, format) } return ( <Stack gap="md" mt="md" style={{ flexGrow: 1 }}> {isValidating && ( <Stack gap={4}> <Group justify="space-between"> <Text size="sm">Validating...</Text> <Text size="sm"> {Math.round((progress.current / progress.total) * 100)}% </Text> </Group> <Progress value={(progress.current / progress.total) * 100} animated color="emerald" /> </Stack> )} <Group justify="space-between" align="center"> <SegmentedControl size="sm" value={filter} onChange={setFilter} data={[ { label: `All (${stats.total})`, value: 'All' }, { label: `Valid (${stats.valid})`, value: 'Valid' }, { label: `Invalid (${stats.invalid})`, value: 'Invalid' }, ]} /> <Menu shadow="md" width={200}> <Menu.Target> <Button size="xs" variant="outline" leftSection={<Icon icon="tabler:download" />} disabled={results.length === 0} > Export </Button> </Menu.Target> <Menu.Dropdown> <Menu.Item onClick={() => handleExportClick('csv')}>CSV</Menu.Item> <Menu.Item onClick={() => handleExportClick('xlsx')}> Excel </Menu.Item> </Menu.Dropdown> </Menu> </Group> <ScrollArea h={200} type="always" offsetScrollbars> <DataTable withTableBorder records={filteredResults} columns={[ { accessor: 'number', title: 'Phone Number' }, { accessor: 'status', title: 'Status', render: (record) => ( <Badge c={ record.status === 'Valid' ? 'green' : record.status === 'Invalid' ? 'red' : 'gray' } variant="light" > {record.status} </Badge> ), }, ]} noRecordsText="No results found" minHeight={150} /> </ScrollArea> </Stack> ) } export default ResultsSection \`\`\` # src/features/tools/validator/hooks/useNumberValidator.ts \`\`\`ts import useFile from '@/hooks/useFile' import wa from '@/libs/wa' import toast from '@/utils/toast' import { delay as sleep } from '@/utils/util' import _ from 'lodash' import { useCallback, useMemo, useRef, useState } from 'react' export interface ValidationResult { number: string status: 'Valid' | 'Invalid' | 'Checking' } export const useNumberValidator = () => { const [numbers, setNumbers] = useState<string[]>([]) const [results, setResults] = useState<ValidationResult[]>([]) const [progress, setProgress] = useState({ current: 0, total: 0 }) const [isValidating, setIsValidating] = useState(false) const validationRef = useRef(false) const fileExporter = useFile() const addNumbers = (newNumbers: string[]) => { // Clean and deduplicate numbers const cleanInput = newNumbers .map((n) => n.replace(/[^0-9]/g, '').trim()) .filter((n) => n.length > 5) const combined = [...numbers, ...cleanInput] const unique = _.uniq(combined) setNumbers(unique) if (cleanInput.length > 0) { toast.success(`${cleanInput.length} numbers added.`) } } const handleClear = () => { setNumbers([]) setResults([]) setProgress({ current: 0, total: 0 }) } const handleStopValidation = useCallback(() => { validationRef.current = false setIsValidating(false) toast.info('Validation stopped by user.') }, []) const handleStartValidation = useCallback(async () => { if (numbers.length === 0) { toast.error('Please add numbers to validate.') return } validationRef.current = true setIsValidating(true) setResults(numbers.map((number) => ({ number, status: 'Checking' }))) setProgress({ current: 0, total: numbers.length }) for (let i = 0; i < numbers.length; i++) { if (!validationRef.current) break const number = numbers[i] try { const checkId = number.includes('@c.us') ? number : `${number}@c.us` const isExist = await wa.contact.isExist(checkId) setResults((prev) => prev.map((res) => res.number === number ? { ...res, status: isExist ? 'Valid' : 'Invalid' } : res, ), ) } catch (error) { console.error(`Error validating ${number}:`, error) setResults((prev) => prev.map((res) => res.number === number ? { ...res, status: 'Invalid' } : res, ), ) } setProgress({ current: i + 1, total: numbers.length }) // FIXED DELAY: 3 to 5 seconds to prevent rate limiting const randomDelay = Math.floor(Math.random() * (5000 - 3000 + 1) + 3000) await sleep(randomDelay) } setIsValidating(false) if (validationRef.current) { toast.success('Validation complete!') } }, [numbers]) const handleExport = ( filteredResults: ValidationResult[], format: 'csv' | 'xlsx', ) => { if (filteredResults.length === 0) { toast.info('No results to export.') return } const dataToExport = filteredResults.map(({ number, status }) => ({ Number: number, Status: status, })) const filename = `validation_results_${new Date() .toISOString() .slice(0, 10)}` fileExporter.saveAs(format, dataToExport, filename) } const estimatedTime = useMemo(() => { if (numbers.length === 0) return '' // Average delay is ~4 seconds const avgDelay = 4 const totalSeconds = numbers.length * avgDelay const minutes = Math.floor(totalSeconds / 60) const seconds = Math.round(totalSeconds % 60) if (minutes > 0) { return `~${minutes} min ${seconds} sec` } return `~${seconds} sec` }, [numbers.length]) return { numbers, setNumbers, results, progress, isValidating, estimatedTime, addNumbers, handleStartValidation, handleStopValidation, handleClear, handleExport, } } \`\`\` # src/features/tools/validator/ModalNumberValidator.tsx \`\`\`tsx import LayoutModal from '@/components/Layout/LayoutModal' import ExcelUploader from '@/features/broadcast/components/Excel/ExcelUploader' import useLicense from '@/hooks/useLicense' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { Button, Group, Popover, Stack, Text, Textarea } from '@mantine/core' import React, { useState } from 'react' import { When } from 'react-if' import ResultsSection from './components/ResultsSection' import { useNumberValidator } from './hooks/useNumberValidator' interface Props { opened: boolean onClose: () => void } const ModalNumberValidator: React.FC<Props> = ({ opened, onClose }) => { const validator = useNumberValidator() const license = useLicense() const [popoverOpened, setPopoverOpened] = useState(false) // Free user limit const FREE_NUMBER_LIMIT = 5 const handleImportExcel = (data: any[]) => { const extractedNumbers = data.flatMap((row) => { // 1. Check for specific 'number' column const numberKey = Object.keys(row).find( (key) => key.toLowerCase() === 'number', ) if (numberKey) return String(row[numberKey]) // 2. Check for phone keywords const phoneKey = Object.keys(row).find((key) => ['phone', 'mobile', 'tel', 'wa', 'whatsapp'].some((term) => key.toLowerCase().includes(term), ), ) if (phoneKey) return String(row[phoneKey]) // 3. Fallback: Scan values const values = Object.values(row) const potentialNumber = values.find((val) => { if (!val) return false const clean = String(val).replace(/[^0-9]/g, '') return clean.length > 6 }) return potentialNumber ? String(potentialNumber) : [] }) validator.addNumbers(extractedNumbers) setPopoverOpened(false) } const handleManualInput = (e: React.ChangeEvent<HTMLTextAreaElement>) => { const raw = e.currentTarget.value const lines = raw.split('\n') validator.setNumbers(lines) } return ( <LayoutModal opened={opened} onClose={onClose} title="Number Validator" description="Verify a list of phone numbers to ensure they are registered on WhatsApp." icon={<Icon icon="tabler:checks" fontSize={22} />} w={600} > <Stack gap="lg"> {/* Input Section */} <Stack gap="xs"> <Group justify="space-between"> <Text size="sm" fw={500}> Input Numbers </Text> <Popover opened={popoverOpened} onChange={setPopoverOpened} width={350} trapFocus position="bottom-end" withArrow shadow="md" withinPortal={false} > <Popover.Target> <Button size="xs" variant="light" leftSection={<Icon icon="tabler:file-spreadsheet" />} onClick={() => setPopoverOpened((o) => !o)} > Import Excel </Button> </Popover.Target> <Popover.Dropdown> <Stack gap="xs"> <Text size="sm" fw={500}> Import from Excel </Text> <ExcelUploader onConfirm={handleImportExcel} onClose={() => setPopoverOpened(false)} /> </Stack> </Popover.Dropdown> </Popover> </Group> <Textarea placeholder="Enter numbers here (one per line)..." minRows={4} maxRows={6} autosize value={validator.numbers.join('\n')} onChange={handleManualInput} disabled={validator.isValidating} /> <Group justify="space-between"> <Text size="xs" c="dimmed"> Total:{' '} {validator.numbers.filter((n) => n.trim().length > 0).length} </Text> <When condition={ !validator.isValidating && validator.numbers.length > 0 } > <Text size="xs" c="dimmed"> Est. Time: {validator.estimatedTime} </Text> </When> </Group> </Stack> {/* Results Section */} <Stack gap="xs"> <ResultsSection results={validator.results} isValidating={validator.isValidating} progress={validator.progress} onExport={validator.handleExport} /> </Stack> {/* Action Buttons (Footer Area) */} <Group justify="flex-end" mt="md"> <Button variant="default" color="red" onClick={validator.handleClear} disabled={validator.isValidating || validator.numbers.length === 0} leftSection={<Icon icon="tabler:trash" />} > Clear </Button> {validator.isValidating ? ( <Button color="red" onClick={validator.handleStopValidation} leftSection={<Icon icon="tabler:player-stop" />} > Stop </Button> ) : ( <Button color="emerald" onClick={() => { const count = validator.numbers.filter( (n) => n.trim().length > 0, ).length if (license.isFree() && count > FREE_NUMBER_LIMIT) { toast.warning( `Free users can only validate ${FREE_NUMBER_LIMIT} numbers at once. Upgrade for unlimited validation.`, 'Limit Reached', ) return } validator.handleStartValidation() }} disabled={validator.numbers.length === 0} leftSection={<Icon icon="tabler:player-play" />} > Start </Button> )} </Group> </Stack> </LayoutModal> ) } export default ModalNumberValidator \`\`\` # src/features/workflow/components/Editor/ModalAddStep.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import { Icon } from '@iconify/react' import { Group, ScrollArea, SimpleGrid, Stack, Text, ThemeIcon, Tooltip, } from '@mantine/core' import React from 'react' import { STEP_CATEGORIES } from '../../constants/stepCategories' import type { StepType } from '../../types' import StepCategoryCard from './StepCategoryCard' interface Props { opened: boolean onClose: () => void onSelect: (type: StepType) => void hasTrigger?: boolean disabledSteps?: StepType[] triggerScope?: string } // Categories that are coming soon const COMING_SOON_CATEGORIES = ['Logic & Flow', 'Group Management'] // Individual steps that are coming soon const COMING_SOON_STEPS = ['trigger-manual'] // Steps that only work with personal scope const PERSONAL_ONLY_STEPS: StepType[] = ['tag', 'update-field'] const ModalAddStep: React.FC<Props> = ({ opened, onClose, onSelect, hasTrigger = false, disabledSteps = [], triggerScope = 'all', }) => { const handleSelect = (type: StepType) => { onSelect(type) onClose() } // Check if a category is disabled const isCategoryDisabled = (categoryTitle: string) => { if (!hasTrigger && categoryTitle !== 'Triggers') { return true } return false } // Check if a category is coming soon const isComingSoon = (categoryTitle: string) => { return COMING_SOON_CATEGORIES.includes(categoryTitle) } // Check if a step is coming soon const isStepComingSoon = (stepType: string) => { return COMING_SOON_STEPS.includes(stepType) } // Check if step is disabled due to scope const isStepDisabledByScope = (stepType: string) => { if (PERSONAL_ONLY_STEPS.includes(stepType as StepType)) { return triggerScope !== 'Personal' } return false } return ( <Modal opened={opened} onClose={onClose} withCloseButton w={800} p={0}> <Stack gap={0} h={600}> <Group p="md" style={{ borderBottom: '1px solid var(--mantine-color-default-border)', }} > <ThemeIcon variant="light" size="lg" color="blue"> <Icon icon="tabler:plus" fontSize={20} /> </ThemeIcon> <Text fw={600} size="lg"> Add Workflow Step </Text> </Group> <ScrollArea style={{ flex: 1 }} bg="var(--mantine-color-body)" p={0}> <Stack p="md" gap="xl"> {STEP_CATEGORIES.map((category) => { const categoryIsComingSoon = isComingSoon(category.title) const isDisabled = isCategoryDisabled(category.title) || categoryIsComingSoon return ( <Stack key={category.title} gap="xs" style={{ opacity: isDisabled ? 0.4 : 1 }} > <Group gap="xs"> <Text size="xs" fw={700} c="dimmed" tt="uppercase"> {category.title} </Text> {categoryIsComingSoon ? ( <Tooltip label="Coming Soon" withArrow> <Text size="xs" c="blue" style={{ cursor: 'help' }}> (Coming Soon) </Text> </Tooltip> ) : ( isDisabled && ( <Text size="xs" c="orange"> (Add Trigger First) </Text> ) )} </Group> <SimpleGrid cols={{ base: 1, sm: 2 }} spacing="sm"> {category.items.map((item) => { const stepComingSoon = isStepComingSoon(item.type) const disabledByScope = isStepDisabledByScope(item.type) const isStepDisabled = isDisabled || disabledSteps.includes(item.type as StepType) || disabledByScope return ( <StepCategoryCard key={item.type} item={item} onSelect={handleSelect} disabled={isStepDisabled} comingSoon={stepComingSoon} disabledReason={ disabledByScope ? 'Only available for Personal scope' : undefined } /> ) })} </SimpleGrid> </Stack> ) })} </Stack> </ScrollArea> </Stack> </Modal> ) } export default ModalAddStep \`\`\` # src/features/workflow/components/Editor/QuickInsertLine.tsx \`\`\`tsx import { Box, Center } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React, { useState } from 'react' import WorkflowAddMenu from './WorkflowAddMenu' interface Props { form: UseFormReturnType<any> path: string insertIndex: number onAdd: (id: string) => void isInsideBranch?: boolean } const QuickInsertLine: React.FC<Props> = ({ form, path, insertIndex, onAdd, isInsideBranch = false, }) => { const [isHovered, setIsHovered] = useState(false) return ( <Box onMouseEnter={() => setIsHovered(true)} onMouseLeave={() => setIsHovered(false)} style={{ position: 'relative', height: 24, // Matches the padding/gap between nodes width: '100%', // marginLeft: 24, // REMOVED: Agar bisa full width dan center display: 'flex', alignItems: 'center', justifyContent: 'center', cursor: 'pointer', marginTop: -10, // Pull up to overlap the gap marginBottom: -10, // Pull down zIndex: 2, // Ensure it sits above the standard line }} > {/* Invisible Hit Area */} <div style={{ position: 'absolute', left: 0, top: 0, bottom: 0, right: 0, // Changed to full width hit area zIndex: 2, }} /> {/* The Visual Line / Button Container */} <div style={{ position: 'absolute', left: '50%', // CENTERED HORIZONTALLY transform: 'translateX(-50%)', zIndex: 3, }} > {isHovered ? ( <div style={{ transform: 'scale(1)', transition: 'transform 0.2s' }}> <WorkflowAddMenu form={form} path={path} variant="icon" insertIndex={insertIndex} onAdd={onAdd} isInsideBranch={isInsideBranch} /> </div> ) : ( // Hidden placeholder <div style={{ width: 2, height: 24, backgroundColor: 'transparent', }} /> )} </div> {/* Helper Line (Visible on Hover) */} {isHovered && ( <Center style={{ position: 'absolute', left: 0, // Full width line right: 0, height: 1, borderTop: '1px dashed var(--mantine-color-emerald-5)', opacity: 0.5, pointerEvents: 'none', }} /> )} </Box> ) } export default QuickInsertLine \`\`\` # src/features/workflow/components/Editor/StepCategoryCard.tsx \`\`\`tsx import { Icon } from '@iconify/react' import { Card, Group, Stack, Text, ThemeIcon, Tooltip, UnstyledButton, } from '@mantine/core' import React, { memo } from 'react' import type { StepItem } from '../../constants/stepCategories' import type { StepType } from '../../types' interface Props { item: StepItem onSelect: (type: StepType) => void disabled?: boolean comingSoon?: boolean disabledReason?: string } const StepCategoryCard: React.FC<Props> = memo( ({ item, onSelect, disabled = false, comingSoon = false, disabledReason, }) => { const isDisabled = disabled || comingSoon const cardContent = ( <UnstyledButton onClick={() => !isDisabled && onSelect(item.type as StepType)} className="step-card-button" style={{ height: '100%', cursor: isDisabled ? 'not-allowed' : 'pointer', }} disabled={isDisabled} > <Card withBorder padding="sm" radius="md" className="step-category-card" data-color={item.color} style={ { height: '100%', backgroundColor: 'rgba(255,255,255,0.02)', opacity: isDisabled ? 0.5 : 1, '--hover-border-color': isDisabled ? 'transparent' : `var(--mantine-color-${item.color}-5)`, } as React.CSSProperties } > <Group align="flex-start" wrap="nowrap"> <ThemeIcon size="lg" radius="md" color={item.color} variant="light"> <Icon icon={item.icon} fontSize={20} /> </ThemeIcon> <Stack gap={2}> <Group gap="xs"> <Text size="sm" fw={600} c="white"> {item.label} </Text> {comingSoon && ( <Text size="xs" c="blue"> (Coming Soon) </Text> )} </Group> <Text size="xs" c="dimmed" lh={1.3}> {item.description} </Text> </Stack> </Group> </Card> <style>{` .step-category-card { transition: border-color 0.15s ease, background-color 0.15s ease; } .step-card-button:not(:disabled):hover .step-category-card { border-color: var(--hover-border-color); background-color: rgba(255,255,255,0.05); } `}</style> </UnstyledButton> ) // Show tooltip for disabled reason or coming soon if (disabledReason) { return ( <Tooltip label={disabledReason} withArrow> {cardContent} </Tooltip> ) } if (comingSoon) { return ( <Tooltip label="Coming Soon" withArrow> {cardContent} </Tooltip> ) } return cardContent }, ) StepCategoryCard.displayName = 'StepCategoryCard' export default StepCategoryCard \`\`\` # src/features/workflow/components/Editor/VariablesModal.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import CustomFieldModel from '@/features/contacts/models/CustomFieldModel' import { getWorkflowVariables } from '@/features/workflow/utils/variableUtils' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { Accordion, ActionIcon, Badge, Code, Group, Paper, ScrollArea, Stack, Text, ThemeIcon, Title, Tooltip, UnstyledButton, } from '@mantine/core' import { useLiveQuery } from 'dexie-react-hooks' import React, { useMemo } from 'react' import type { WorkflowStep } from '../../types' interface Props { opened: boolean onClose: () => void steps: WorkflowStep[] onHoverVariable: (varName: string | null) => void } interface VariableDisplay { name: string source: string type: string description?: string } const VariablesModal: React.FC<Props> = ({ opened, onClose, steps, onHoverVariable, }) => { const customFields = useLiveQuery(() => CustomFieldModel.getAll(), []) || [] const workflowVars = useMemo(() => getWorkflowVariables(steps), [steps]) // Group variables into categories const categories = useMemo(() => { const system: VariableDisplay[] = [] const contact: VariableDisplay[] = [] const workflow: VariableDisplay[] = [] // 1. Distribute Workflow Variables (from steps & system) workflowVars.forEach((v) => { if (v.source === 'System') { system.push(v) } else if (v.type === 'Context') { // e.g. sender_name, sender_number contact.push(v) } else { // e.g. Manual Trigger inputs, API responses, etc. workflow.push(v) } }) // 2. Add Custom Fields to Contact category customFields.forEach((field) => { contact.push({ name: field.name, source: 'Custom Field', type: field.type, }) }) return { system, contact, workflow } }, [workflowVars, customFields]) const handleCopy = (name: string) => { navigator.clipboard.writeText(`{${name}}`) toast.success(`Copied {${name}} to clipboard`) } const getTypeConfig = (type: string) => { const t = type.toLowerCase() if ( ['number', 'int', 'integer', 'float', 'rating'].some((k) => t.includes(k)) ) { return { icon: 'tabler:numbers', color: 'blue', label: 'Number' } } if (['date', 'time', 'datetime'].some((k) => t.includes(k))) { return { icon: 'tabler:calendar', color: 'yellow', label: 'Date' } } if (['list', 'array', 'multiselect'].some((k) => t.includes(k))) { return { icon: 'tabler:list', color: 'grape', label: 'List' } } // Default Text return { icon: 'tabler:abc', color: 'emerald', label: 'Text' } } const renderVariableItem = (variable: VariableDisplay) => { const { icon, color } = getTypeConfig(variable.type) return ( <UnstyledButton key={variable.name} onClick={() => handleCopy(variable.name)} onMouseEnter={() => onHoverVariable(variable.name)} onMouseLeave={() => onHoverVariable(null)} style={{ width: '100%', display: 'block' }} > <Paper withBorder p="xs" radius="md" style={{ backgroundColor: 'rgba(255,255,255,0.02)', transition: 'all 0.2s ease', cursor: 'pointer', }} // Add hover style logic via css or simple inline style override on hover onMouseOver={(e) => (e.currentTarget.style.backgroundColor = 'rgba(255,255,255,0.05)') } onMouseOut={(e) => (e.currentTarget.style.backgroundColor = 'rgba(255,255,255,0.02)') } > <Group justify="space-between" wrap="nowrap"> <Group gap="sm" wrap="nowrap"> <ThemeIcon variant="light" color={color} size="md" radius="md"> <Icon icon={icon} fontSize={18} /> </ThemeIcon> <Stack gap={0}> <Group gap={6}> <Text fw={600} size="sm" c="white"> {variable.name} </Text> <Code c={color} bg="transparent" style={{ fontSize: 10 }}> {`{${variable.name}}`} </Code> </Group> <Text size="xs" c="dimmed"> {variable.source} â€¢ {variable.type} </Text> </Stack> </Group> <Tooltip label="Click to copy" position="left"> <ActionIcon variant="transparent" color="gray" size="sm"> <Icon icon="tabler:copy" /> </ActionIcon> </Tooltip> </Group> </Paper> </UnstyledButton> ) } return ( <Modal opened={opened} onClose={onClose} withCloseButton w={600} style={{ zIndex: 3000 }} > <Stack gap="md" p="xs" h={500}> <Group> <ThemeIcon variant="light" size="lg" color="indigo" radius="md"> <Icon icon="tabler:variable" fontSize={20} /> </ThemeIcon> <Stack gap={0}> <Title order={4}>Variables</Title> <Text size="xs" c="dimmed"> Click any variable to copy to clipboard. </Text> </Stack> </Group> <ScrollArea type="auto" offsetScrollbars style={{ flex: 1, margin: -8, padding: 8 }} > <Accordion defaultValue={['contact', 'workflow']} multiple variant="separated" radius="md" styles={{ item: { backgroundColor: 'transparent', border: 'none', }, control: { paddingLeft: 0, paddingRight: 0, }, content: { paddingLeft: 0, paddingRight: 0, }, }} > {/* 1. SYSTEM */} <Accordion.Item value="system"> <Accordion.Control icon={ <Icon icon="tabler:settings" fontSize={20} color="var(--mantine-color-gray-5)" /> } > <Text fw={600} size="sm"> System </Text> </Accordion.Control> <Accordion.Panel> <Stack gap="xs"> {categories.system.map(renderVariableItem)} </Stack> </Accordion.Panel> </Accordion.Item> {/* 2. CONTACT */} <Accordion.Item value="contact"> <Accordion.Control icon={ <Icon icon="tabler:user-circle" fontSize={20} color="var(--mantine-color-blue-4)" /> } > <Group justify="space-between" pr="xs"> <Text fw={600} size="sm"> Contact & Custom Fields </Text> <Badge size="xs" variant="light" color="blue"> {categories.contact.length} </Badge> </Group> </Accordion.Control> <Accordion.Panel> <Stack gap="xs"> {categories.contact.length > 0 ? ( categories.contact.map(renderVariableItem) ) : ( <Text size="xs" c="dimmed" fs="italic" pl="sm"> No custom fields found. </Text> )} </Stack> </Accordion.Panel> </Accordion.Item> {/* 3. WORKFLOW */} <Accordion.Item value="workflow"> <Accordion.Control icon={ <Icon icon="tabler:robot" fontSize={20} color="var(--mantine-color-orange-4)" /> } > <Group justify="space-between" pr="xs"> <Text fw={600} size="sm"> Workflow Variables </Text> <Badge size="xs" variant="light" color="orange"> {categories.workflow.length} </Badge> </Group> </Accordion.Control> <Accordion.Panel> <Stack gap="xs"> {categories.workflow.length > 0 ? ( categories.workflow.map(renderVariableItem) ) : ( <Text size="xs" c="dimmed" fs="italic" pl="sm"> No local variables defined in this workflow. </Text> )} </Stack> </Accordion.Panel> </Accordion.Item> </Accordion> </ScrollArea> </Stack> </Modal> ) } export default VariablesModal \`\`\` # src/features/workflow/components/Editor/WorkflowAddMenu.tsx \`\`\`tsx import { Icon } from '@iconify/react' import { ActionIcon, Button, Tooltip } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import { randomId, useDisclosure } from '@mantine/hooks' import React from 'react' import type { StepType, WorkflowStep } from '../../types' import ModalAddStep from './ModalAddStep' interface Props { form: UseFormReturnType<any> path: string variant?: 'toolbar' | 'inline' | 'icon' insertIndex?: number onAdd?: (id: string) => void isInsideBranch?: boolean } const WorkflowAddMenu: React.FC<Props> = ({ form, path, variant = 'inline', insertIndex, onAdd, isInsideBranch = false, }) => { const [opened, { open, close }] = useDisclosure(false) const hasTrigger = (form.values.steps || []).some( (step: WorkflowStep) => step.type === 'trigger', ) // Get trigger scope from the first step (trigger) const triggerStep = (form.values.steps || []).find( (step: WorkflowStep) => step.type === 'trigger', ) const triggerScope = triggerStep?.config?.scope || 'all' const disabledSteps: StepType[] = [] const handleAddStep = ( selectedType: StepType | 'trigger-message' | 'trigger-manual', ) => { const id = randomId() let type: StepType = selectedType as StepType let label = 'Unknown' let config: any = {} if (selectedType === 'trigger-message') { type = 'trigger' label = 'Incoming Message' config = { triggerType: 'keyword', keyword: '', scope: 'all' } } else if (selectedType === 'trigger-manual') { type = 'trigger' label = 'Manual Trigger' config = { triggerType: 'manual', scope: 'all' } } else { switch (selectedType) { case 'send-message': label = 'Send Message' break case 'tag': label = 'Tag' config = { action: 'add' } break case 'update-field': label = 'Update Field' break case 'archive-chat': label = 'Archive Chat' config = { action: true } break case 'pin-chat': label = 'Pin Chat' config = { action: true } break case 'mute-chat': label = 'Mute Chat' config = { action: true } break // Legacy mapping... case 'send-text': label = 'Send Text' config = { messageType: 'TEXT', messageContent: '' } break case 'send-image': label = 'Send Image' config = { messageType: 'IMAGE', messageContent: { caption: '' } } break case 'send-video': label = 'Send Video' config = { messageType: 'VIDEO', messageContent: { caption: '' } } break case 'send-audio': label = 'Send Audio' config = { messageType: 'AUDIO', messageContent: {} } break case 'send-document': label = 'Send File' config = { messageType: 'FILE', messageContent: { caption: '' } } break case 'send-poll': label = 'Send Poll' config = { messageType: 'POLL', messageContent: { name: '', choices: ['', ''] }, } break case 'send-location': label = 'Send Location' config = { messageType: 'LOCATION', messageContent: { lat: '', lng: '', name: '', address: '' }, } break } } const newStep: WorkflowStep = { id, type, label, config, } if (type === 'trigger' && hasTrigger) { const existingTrigger = form.values.steps[0] newStep.id = existingTrigger?.id || id form.setFieldValue('steps.0', newStep) if (onAdd) onAdd(newStep.id) return } if (type === 'trigger' && !hasTrigger) { form.insertListItem('steps', newStep, 0) if (onAdd) onAdd(id) return } if (typeof insertIndex === 'number') { form.insertListItem(path, newStep, insertIndex) } else { form.insertListItem(path, newStep) } if (onAdd) onAdd(id) } if (variant === 'icon') { return ( <> <Tooltip label="Insert Step Here" withArrow position="right"> <ActionIcon size="xs" variant="light" color="emerald" radius="xl" onClick={open} > <Icon icon="tabler:plus" fontSize={12} /> </ActionIcon> </Tooltip> <ModalAddStep opened={opened} onClose={close} onSelect={handleAddStep} hasTrigger={hasTrigger} disabledSteps={disabledSteps} triggerScope={triggerScope} /> </> ) } if (variant === 'toolbar') { return ( <> <Button size="xs" variant="light" color="emerald" leftSection={<Icon icon="tabler:plus" />} onClick={open} > Add Step </Button> <ModalAddStep opened={opened} onClose={close} onSelect={handleAddStep} hasTrigger={hasTrigger} disabledSteps={disabledSteps} triggerScope={triggerScope} /> </> ) } return ( <> <Button variant="subtle" color="emerald" size="xs" leftSection={<Icon icon="tabler:plus" fontSize={14} />} onClick={open} style={{ alignSelf: 'stretch' }} > Add step </Button> <ModalAddStep opened={opened} onClose={close} onSelect={handleAddStep} hasTrigger={hasTrigger} disabledSteps={disabledSteps} triggerScope={triggerScope} /> </> ) } export default WorkflowAddMenu \`\`\` # src/features/workflow/components/Editor/WorkflowCanvas.tsx \`\`\`tsx import { Box, ScrollArea, Stack, Text } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import _ from 'lodash' import React from 'react' import QuickInsertLine from './QuickInsertLine' import WorkflowAddMenu from './WorkflowAddMenu' import WorkflowStepItem from './WorkflowStepItem' interface Props { form: UseFormReturnType<any> path?: string selectedStepId: string | null onSelect: (id: string | null) => void isInsideBranch?: boolean highlightedVariable?: string | null } const WorkflowCanvas: React.FC<Props> = ({ form, path = 'steps', selectedStepId, onSelect, isInsideBranch = false, highlightedVariable, }) => { const steps = _.get(form.values, path) || [] const isRoot = path === 'steps' const handleMoveUp = (index: number) => { if (isRoot && index === 1) return if (index === 0) return form.reorderListItem(path, { from: index, to: index - 1 }) } const handleMoveDown = (index: number) => { if (isRoot && index === 0) return if (index === steps.length - 1) return form.reorderListItem(path, { from: index, to: index + 1 }) } const content = ( <Stack gap={0} pb={isRoot ? 100 : 'xs'}> {steps.map((step: any, index: number) => { const canMoveUp = isRoot ? index > 1 : index > 0 const isLastItem = index === steps.length - 1 return ( <React.Fragment key={step.id}> <Box mb={isLastItem ? 0 : 8}> <WorkflowStepItem step={step} path={path} index={index} form={form} isActive={selectedStepId === step.id} selectedStepId={selectedStepId} onSelect={onSelect} isFirst={index === 0} isLast={isLastItem} canMoveUp={canMoveUp} onMoveUp={() => handleMoveUp(index)} onMoveDown={() => handleMoveDown(index)} highlightedVariable={highlightedVariable} /> </Box> {!isLastItem && ( <QuickInsertLine form={form} path={path} insertIndex={index + 1} onAdd={onSelect} isInsideBranch={isInsideBranch} /> )} </React.Fragment> ) })} {!isRoot && ( <Box mt={4}> <WorkflowAddMenu form={form} path={path} variant="inline" onAdd={onSelect} isInsideBranch={isInsideBranch} /> </Box> )} {isRoot && steps.length === 0 && ( <Stack align="center" py="xl"> <Text c="dimmed">Start by adding a trigger.</Text> <WorkflowAddMenu form={form} path="steps" variant="inline" onAdd={onSelect} /> </Stack> )} </Stack> ) if (isRoot) { return ( <Box style={{ flex: 1, height: '100%', display: 'flex', flexDirection: 'column', }} > <ScrollArea style={{ flex: 1 }} bg="transparent"> <Box p="md">{content}</Box> </ScrollArea> <Box p="sm" style={{ borderTop: '1px solid var(--mantine-color-default-border)', backgroundColor: 'rgba(0, 0, 0, 0.2)', }} > <WorkflowAddMenu form={form} path="steps" variant="toolbar" onAdd={onSelect} /> </Box> </Box> ) } return content } export default WorkflowCanvas \`\`\` # src/features/workflow/components/Editor/WorkflowConfigPanel.tsx \`\`\`tsx // src/features/workflow/components/Editor/WorkflowConfigPanel.tsx import StepConfiguration from '@/features/workflow/components/StepConfiguration' import { findStepPath } from '@/features/workflow/utils/search' import { Icon } from '@iconify/react' import { Box, Paper, ScrollArea, Stack, Text } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import _ from 'lodash' import React, { useMemo } from 'react' interface Props { form: UseFormReturnType<any> selectedStepId: string | null onClose: () => void } const WorkflowConfigPanel: React.FC<Props> = ({ form, selectedStepId, onClose, }) => { // 1. Cari Path step yang dipilih (Recursive) const selectedStepPath = useMemo(() => { return findStepPath(form.values.steps, selectedStepId) }, [form.values.steps, selectedStepId]) // 2. Ambil objek step menggunakan path tersebut const selectedStep = selectedStepPath ? _.get(form.values, selectedStepPath) : null return ( <Paper w={'45%'} h="100%" radius={0} style={{ borderLeft: '1px solid var(--mantine-color-default-border)', display: 'flex', flexDirection: 'column', backgroundColor: 'var(--mantine-color-body)', }} > <ScrollArea style={{ flex: 1 }}> <Box p="md"> {selectedStep && selectedStepPath ? ( // 3. Teruskan Path ke komponen konfigurasi <StepConfiguration step={selectedStep} path={selectedStepPath} form={form} /> ) : ( <Stack align="center" justify="center" h={200} c="dimmed"> <Icon icon="tabler:click" fontSize={32} /> <Text size="sm">Select a step to configure</Text> </Stack> )} </Box> </ScrollArea> </Paper> ) } export default WorkflowConfigPanel \`\`\` # src/features/workflow/components/Editor/WorkflowStepItem.tsx \`\`\`tsx import { getStepColor, getStepIcon } from '@/features/workflow/utils/stepUtils' import { validateStepConfig } from '@/features/workflow/utils/validation' import { truncate } from '@/utils/util' import { Icon } from '@iconify/react' import { ActionIcon, Badge, Box, Card, Collapse, Group, Stack, Text, ThemeIcon, Tooltip, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import { randomId } from '@mantine/hooks' import _ from 'lodash' import React, { useMemo, useState } from 'react' import { When } from 'react-if' import type { WorkflowStep } from '../../types' interface Props { step: WorkflowStep path: string index: number isActive: boolean selectedStepId: string | null form: UseFormReturnType<any> onSelect: (id: string | null) => void isFirst: boolean isLast: boolean canMoveUp: boolean onMoveUp: () => void onMoveDown: () => void highlightedVariable?: string | null } const WorkflowStepItem: React.FC<Props> = ({ step, path, index, isActive, selectedStepId, form, onSelect, isFirst, isLast, canMoveUp, onMoveUp, onMoveDown, highlightedVariable, }) => { const [isHovered, setIsHovered] = useState(false) const [isCollapsed, setIsCollapsed] = useState(false) const isValid = validateStepConfig(step) const isTrigger = step.type === 'trigger' // Check if this step uses the highlighted variable const isVariableUsed = useMemo(() => { if (!highlightedVariable || !step.config) return false const configStr = JSON.stringify(step.config) return configStr.includes(`{${highlightedVariable}}`) }, [step.config, highlightedVariable]) const handleDelete = (e: React.MouseEvent) => { e.stopPropagation() if (isTrigger) return if (index > 0) { const siblings = _.get(form.values, path) || [] const prevStep = siblings[index - 1] if (prevStep) { onSelect(prevStep.id) } else { onSelect(null) } } else { onSelect(null) } form.removeListItem(path, index) } const handleDuplicate = (e: React.MouseEvent) => { e.stopPropagation() if (isTrigger) return const newStep = _.cloneDeep(step) newStep.id = randomId() newStep.label = `${newStep.label} (Copy)` form.insertListItem(path, newStep, index + 1) onSelect(newStep.id) } const toggleCollapse = (e: React.MouseEvent) => { e.stopPropagation() setIsCollapsed((prev) => !prev) } const outputVariables = useMemo(() => { const vars: string[] = [] if (step.type === 'trigger' && step.config?.triggerType === 'manual') { const inputs = step.config.inputs || [] inputs.forEach((i: any) => { if (i.key) vars.push(i.key) }) } return vars }, [step]) const summaryText = useMemo(() => { const { type, config } = step if (!config) return '' switch (type) { case 'trigger': return config.triggerType === 'manual' ? 'Manual Run' : config.keyword ? `"${config.keyword}"` : 'Any Message' case 'send-text': return truncate(config.messageContent, 40) case 'tag': return `${config.action === 'remove' ? 'Remove' : 'Add'}: ${config.tagName}` case 'update-field': return `Field ID: ${config.customFieldId}` default: return '' } }, [step]) // Dynamic Styling const borderColor = isVariableUsed ? 'var(--mantine-color-yellow-5)' : isActive ? 'var(--mantine-color-blue-5)' : 'var(--mantine-color-default-border)' const backgroundColor = isVariableUsed ? 'rgba(250, 176, 5, 0.15)' : isActive ? 'rgba(59, 130, 246, 0.1)' : 'var(--mantine-color-body)' const boxShadow = isVariableUsed ? '0 0 15px rgba(250, 176, 5, 0.3)' : undefined const currentItemPath = `${path}.${index}` return ( <Box id={`step-node-${step.id}`} style={{ position: 'relative', paddingLeft: 24 }} > {/* Visual Flow Line */} {!isLast && ( <div style={{ position: 'absolute', left: 11, top: 24, bottom: -10, width: 2, backgroundColor: 'var(--mantine-color-dark-4)', zIndex: 0, }} /> )} {/* Circle Node */} <div style={{ position: 'absolute', left: 4, top: 18, zIndex: 1, width: 16, height: 16, borderRadius: '50%', backgroundColor: 'var(--mantine-color-body)', border: `2px solid var(--mantine-color-${getStepColor(step.type)}-6)`, display: 'flex', alignItems: 'center', justifyContent: 'center', }} > <div style={{ width: 6, height: 6, borderRadius: '50%', backgroundColor: `var(--mantine-color-${getStepColor( step.type, )}-6)`, }} /> </div> <Card component="div" withBorder padding="sm" radius="md" onClick={(e) => { e.stopPropagation() onSelect(step.id) }} onMouseEnter={() => setIsHovered(true)} onMouseLeave={() => setIsHovered(false)} style={{ cursor: 'pointer', borderColor, backgroundColor, boxShadow, transition: 'all 0.2s ease', borderLeftWidth: 4, borderLeftColor: getStepColor(step.type) === 'gray' ? undefined : `var(--mantine-color-${getStepColor(step.type)}-5)`, overflow: 'visible', marginLeft: 4, }} > <Stack gap="xs"> <Group justify="space-between" align="center" wrap="nowrap"> <Group gap="sm" wrap="nowrap" style={{ flex: 1, overflow: 'hidden' }} > <ActionIcon size="sm" variant="transparent" color="gray" onClick={toggleCollapse} style={{ transform: isCollapsed ? 'rotate(-90deg)' : 'rotate(0deg)', transition: 'transform 0.2s ease', }} > <Icon icon="tabler:chevron-down" /> </ActionIcon> <ThemeIcon color={getStepColor(step.type)} variant="light" size="md" radius="sm" > <Icon icon={getStepIcon(step.type)} fontSize={18} /> </ThemeIcon> <Stack gap={0} style={{ flex: 1, overflow: 'hidden' }}> <Group gap={6} wrap="nowrap"> <Text size="sm" fw={600} style={{ whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', }} > {step.label} </Text> {!isValid && ( <Tooltip label="Configuration is incomplete"> <Icon icon="tabler:alert-circle" style={{ color: 'var(--mantine-color-red-5)' }} /> </Tooltip> )} </Group> {summaryText && ( <Text size="xs" c="dimmed" truncate> {summaryText} </Text> )} </Stack> </Group> {isHovered && !isTrigger && ( <Group gap={4} wrap="nowrap"> <Tooltip label="Move Up" withArrow> <ActionIcon size="xs" variant="subtle" color="gray" onClick={(e) => { e.stopPropagation() onMoveUp() }} disabled={!canMoveUp} > <Icon icon="tabler:arrow-up" /> </ActionIcon> </Tooltip> <Tooltip label="Move Down" withArrow> <ActionIcon size="xs" variant="subtle" color="gray" onClick={(e) => { e.stopPropagation() onMoveDown() }} disabled={isLast} > <Icon icon="tabler:arrow-down" /> </ActionIcon> </Tooltip> <Tooltip label="Duplicate" withArrow> <ActionIcon size="xs" variant="subtle" color="gray" onClick={handleDuplicate} > <Icon icon="tabler:copy" /> </ActionIcon> </Tooltip> <Tooltip label="Delete" withArrow> <ActionIcon size="xs" variant="subtle" color="red" onClick={handleDelete} > <Icon icon="tabler:trash" /> </ActionIcon> </Tooltip> </Group> )} </Group> {/* Variables Output */} <When condition={outputVariables.length > 0}> <Group gap={4}> <Icon icon="tabler:variable" fontSize={12} style={{ opacity: 0.5 }} /> {outputVariables.map((v) => ( <Badge key={v} size="xs" variant="light" color="grape" style={{ textTransform: 'none', cursor: 'default' }} > {`{${v}}`} </Badge> ))} </Group> </When> </Stack> </Card> </Box> ) } export default WorkflowStepItem \`\`\` # src/features/workflow/components/Editor/WorkflowToolbar.tsx \`\`\`tsx import { Icon } from '@iconify/react' import { Button, Group, Paper, Text } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import { randomId } from '@mantine/hooks' import React from 'react' import type { StepType, WorkflowStep } from '../../types' interface Props { form: UseFormReturnType<any> onAdd: (id: string) => void } const WorkflowToolbar: React.FC<Props> = ({ form, onAdd }) => { const handleAddStep = (type: StepType) => { const id = randomId() let label = 'Unknown' let config: any = {} switch (type) { case 'send-message': label = 'Send Message' break case 'tag': label = 'Tag' config = { action: 'add' } break case 'update-field': label = 'Update Field' break case 'archive-chat': label = 'Archive Chat' config = { action: true } break case 'pin-chat': label = 'Pin Chat' config = { action: true } break case 'mute-chat': label = 'Mute Chat' config = { action: true } break } const newStep: WorkflowStep = { id, type, label, config, } form.insertListItem('steps', newStep) onAdd(id) } return ( <Paper p="sm" withBorder style={{ zIndex: 5 }}> <Text size="xs" fw={700} c="dimmed" mb="xs" tt="uppercase"> Add Step </Text> <Group gap={8}> <Button size="xs" variant="light" color="emerald" leftSection={<Icon icon="tabler:message-plus" />} onClick={() => handleAddStep('send-message')} > Message </Button> <Button size="xs" variant="light" color="indigo" leftSection={<Icon icon="tabler:tag" />} onClick={() => handleAddStep('tag')} > Tag </Button> <Button size="xs" variant="light" color="blue" leftSection={<Icon icon="tabler:database-edit" />} onClick={() => handleAddStep('update-field')} > Field </Button> <Button size="xs" variant="light" color="pink" leftSection={<Icon icon="tabler:archive" />} onClick={() => handleAddStep('archive-chat')} > Archive </Button> </Group> </Paper> ) } export default WorkflowToolbar \`\`\` # src/features/workflow/components/ModalRuntimeInput.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import { Icon } from '@iconify/react' import { Button, Group, NumberInput, Stack, Text, TextInput, } from '@mantine/core' import { DatePickerInput } from '@mantine/dates' import { useForm } from '@mantine/form' import React, { useEffect } from 'react' export interface WorkflowInputDef { key: string label: string type: 'text' | 'number' | 'date' } interface Props { opened: boolean onClose: () => void onRun: (variables: Record<string, any>) => void inputs: WorkflowInputDef[] workflowName: string } const ModalRuntimeInput: React.FC<Props> = ({ opened, onClose, onRun, inputs, workflowName, }) => { // Dynamic initial values based on inputs const initialValues = inputs.reduce( (acc, input) => { acc[input.key] = input.type === 'date' ? null : '' return acc }, {} as Record<string, any>, ) const form = useForm({ initialValues, validate: (values) => { const errors: Record<string, string> = {} inputs.forEach((input) => { if (!values[input.key]) { errors[input.key] = 'This field is required' } }) return errors }, }) // Reset form when inputs change or modal opens useEffect(() => { if (opened) { form.setValues(initialValues) form.resetDirty() } }, [opened, inputs]) const handleSubmit = (values: typeof form.values) => { onRun(values) onClose() } return ( <Modal opened={opened} onClose={onClose} withCloseButton w={500}> <form onSubmit={form.onSubmit(handleSubmit)}> <Stack gap="lg" p="sm"> <Stack gap={2}> <Group gap="xs"> <Icon icon="tabler:terminal-2" color="#34d399" fontSize={24} /> <Text fw={600} size="lg"> Run Workflow </Text> </Group> <Text c="dimmed" size="sm"> Input required variables for <b>"{workflowName}"</b> </Text> </Stack> <Stack gap="md"> {inputs.map((input) => { if (input.type === 'number') { return ( <NumberInput key={input.key} label={input.label} placeholder="Enter number" required {...form.getInputProps(input.key)} /> ) } if (input.type === 'date') { return ( <DatePickerInput key={input.key} label={input.label} placeholder="Pick date" required clearable {...form.getInputProps(input.key)} /> ) } return ( <TextInput key={input.key} label={input.label} placeholder="Enter text" required {...form.getInputProps(input.key)} data-autofocus={inputs.indexOf(input) === 0} /> ) })} </Stack> <Group justify="flex-end" mt="md"> <Button variant="default" onClick={onClose}> Cancel </Button> <Button type="submit" color="emerald" leftSection={<Icon icon="tabler:player-play" fontSize={18} />} > Run Now </Button> </Group> </Stack> </form> </Modal> ) } export default ModalRuntimeInput \`\`\` # src/features/workflow/components/ModalWorkflowEditor.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import { flattenSteps } from '@/features/workflow/utils/flatten' import { validateStepConfig } from '@/features/workflow/utils/validation' import useLicense from '@/hooks/useLicense' // ++ ADDED import type { Workflow } from '@/libs/db' import toast from '@/utils/toast' import { showModalUpgrade } from '@/utils/util' // ++ ADDED import { Icon } from '@iconify/react' import { Button, Group, Stack, TextInput, ThemeIcon } from '@mantine/core' import { useForm } from '@mantine/form' import { randomId, useDisclosure } from '@mantine/hooks' import React, { useEffect, useState } from 'react' import type { WorkflowStep } from '../types' import VariablesModal from './Editor/VariablesModal' import WorkflowCanvas from './Editor/WorkflowCanvas' import WorkflowConfigPanel from './Editor/WorkflowConfigPanel' interface Props { opened: boolean onClose: () => void onSave: (data: Omit<Workflow, 'id' | 'createdAt' | 'updatedAt'>) => void initialData?: Workflow | null } const ModalWorkflowEditor: React.FC<Props> = ({ opened, onClose, onSave, initialData, }) => { const [selectedStepId, setSelectedStepId] = useState<string | null>(null) // -- Variables & Highlight State -- const [showVariablesModal, variablesModalHandlers] = useDisclosure(false) const [highlightedVariable, setHighlightedVariable] = useState<string | null>( null, ) const license = useLicense() // ++ ADDED const form = useForm({ initialValues: { name: '', steps: [] as WorkflowStep[], }, validate: { name: (val) => (val.trim().length === 0 ? 'Name is required' : null), steps: (val) => (val.length === 0 ? 'Add at least one step' : null), }, }) // Sync initial data useEffect(() => { if (opened) { if (initialData) { form.setValues({ name: initialData.name, steps: initialData.steps || [], }) setSelectedStepId(null) } else { form.reset() // --- MODIFIKASI: Default Incoming Message Trigger --- const defaultTriggerId = randomId() const defaultTrigger: WorkflowStep = { id: defaultTriggerId, type: 'trigger', label: 'Incoming Message', config: { triggerType: 'keyword', // Default trigger type keyword: '', scope: 'all', }, } // Set steps dengan default trigger form.setFieldValue('steps', [defaultTrigger]) // Langsung select trigger agar panel config terbuka setSelectedStepId(defaultTriggerId) // ---------------------------------------------------- } } // eslint-disable-next-line react-hooks/exhaustive-deps }, [opened, initialData]) const handleSave = () => { if (form.validate().hasErrors) return // ++ ADDED: License Check on SAVE // Allow Free users to edit complex flows, but block saving if > 1 action (Total steps > 2 including trigger) if (license.isFree() && form.values.steps.length > 2) { toast.error( 'Free plan allows max 1 steps. Upgrade to activate this full automation.', 'Upgrade Required', ) showModalUpgrade() return } const allSteps = flattenSteps(form.values.steps) const invalidSteps = allSteps.filter((step) => !validateStepConfig(step)) if (invalidSteps.length > 0) { const firstInvalid = invalidSteps[0] const count = invalidSteps.length toast.error( `Found ${count} incomplete step${ count > 1 ? 's' : '' }. Please fix them before saving.`, 'Validation Error', ) setSelectedStepId(firstInvalid.id) setTimeout(() => { const element = document.getElementById(`step-node-${firstInvalid.id}`) if (element) { element.scrollIntoView({ behavior: 'smooth', block: 'center' }) } }, 100) return } onSave({ name: form.values.name, //@ts-ignore steps: form.values.steps, }) onClose() } return ( <> <Modal opened={opened} onClose={onClose} w={1100} p={0}> <Stack h={700} gap={0} style={{ position: 'relative' }}> {/* --- STICKY HEADER --- */} <Group justify="space-between" p="md" style={{ borderBottom: '1px solid var(--mantine-color-default-border)', backgroundColor: 'var(--mantine-color-body)', zIndex: 10, }} > <Group> <ThemeIcon size="lg" radius="md" variant="light" color="emerald"> <Icon icon="tabler:robot" fontSize={22} /> </ThemeIcon> <TextInput placeholder="Workflow Name" size="md" fw={700} {...form.getInputProps('name')} /> </Group> <Group> <Button variant="subtle" color="gray" onClick={variablesModalHandlers.open} leftSection={<Icon icon="tabler:variable" />} > Variables </Button> <Button variant="default" onClick={onClose}> Cancel </Button> <Button onClick={handleSave} color="emerald" leftSection={<Icon icon="tabler:device-floppy" />} > Save Workflow </Button> </Group> </Group> {/* --- MAIN BODY --- */} <Group align="flex-start" gap={0} style={{ flex: 1, overflow: 'hidden', position: 'relative' }} > {/* LEFT: CANVAS */} <WorkflowCanvas form={form} selectedStepId={selectedStepId} onSelect={setSelectedStepId} highlightedVariable={highlightedVariable} /> {/* RIGHT: CONFIG PANEL */} <WorkflowConfigPanel form={form} selectedStepId={selectedStepId} onClose={() => setSelectedStepId(null)} /> </Group> </Stack> </Modal> <VariablesModal opened={showVariablesModal} onClose={variablesModalHandlers.close} steps={form.values.steps} onHoverVariable={setHighlightedVariable} /> </> ) } export default ModalWorkflowEditor \`\`\` # src/features/workflow/components/ModalWorkflowLogs.tsx \`\`\`tsx import Modal from '@/components/Modal/Modal' import { Icon } from '@iconify/react' import { ActionIcon, Button, Code, CopyButton, Group, ScrollArea, Stack, Text, ThemeIcon, Tooltip, } from '@mantine/core' import React from 'react' import { When } from 'react-if' interface Props { opened: boolean onClose: () => void workflowName: string logs: string[] } const ModalWorkflowLogs: React.FC<Props> = ({ opened, onClose, workflowName, logs, }) => { const logsText = logs.join('\n') return ( <Modal opened={opened} onClose={onClose} w={800} withCloseButton> <Stack gap="md" h={500}> <Group justify="space-between" align="center"> <Group gap="sm"> <ThemeIcon variant="light" size="lg" color="blue" radius="md"> <Icon icon="tabler:file-description" fontSize={20} /> </ThemeIcon> <Stack gap={0}> <Text fw={600}>Execution Logs</Text> <Text size="xs" c="dimmed"> Workflow: {workflowName} </Text> </Stack> </Group> <CopyButton value={logsText}> {({ copied, copy }) => ( <Button size="xs" variant="subtle" color={copied ? 'teal' : 'gray'} onClick={copy} leftSection={ <Icon icon={copied ? 'tabler:check' : 'tabler:copy'} fontSize={16} /> } > {copied ? 'Copied' : 'Copy Logs'} </Button> )} </CopyButton> </Group> <ScrollArea style={{ flex: 1, borderRadius: 'var(--mantine-radius-md)' }} bg="var(--mantine-color-dark-8)" p="sm" type="always" > <When condition={logs.length > 0}> <Code block bg="transparent" c="gray.3" style={{ fontSize: 12 }}> {logsText} </Code> </When> <When condition={logs.length === 0}> <Stack align="center" justify="center" h="100%" c="dimmed"> <Icon icon="tabler:terminal-2" fontSize={32} style={{ opacity: 0.3 }} /> <Text size="sm">No logs available for this session.</Text> </Stack> </When> </ScrollArea> <Group justify="flex-end"> <Button variant="default" onClick={onClose}> Close </Button> </Group> </Stack> </Modal> ) } export default ModalWorkflowLogs \`\`\` # src/features/workflow/components/PropertiesPanel.tsx \`\`\`tsx import InputMessage from '@/components/Input/Message/InputMessage' import useInputMessage from '@/components/Input/Message/useInputMessage' import { Message } from '@/constants' import { Icon } from '@iconify/react' import { ActionIcon, Box, Button, Divider, Group, NumberInput, Paper, ScrollArea, Select, Stack, Text, TextInput, } from '@mantine/core' import { useForm } from '@mantine/form' import { useEffect } from 'react' import { When } from 'react-if' interface NodeData { label: string type?: string config?: any } interface Props { selectedNode: any | null onClose: () => void onSave: (nodeId: string, data: NodeData) => void } const PropertiesPanel: React.FC<Props> = ({ selectedNode, onClose, onSave, }) => { // Use existing hook for complex message inputs (Text, Image, etc.) const { form: messageForm, getMessage } = useInputMessage() const form = useForm({ initialValues: { label: '', // Specific configs triggerType: 'keyword', keywords: '', delaySeconds: 5, loopCount: 0, }, validate: { label: (val) => (val.trim().length === 0 ? 'Label is required' : null), }, }) // Sync form with selected node data when it changes useEffect(() => { if (selectedNode) { const { data } = selectedNode form.setValues({ label: data.label || '', triggerType: data.config?.triggerType || 'keyword', keywords: data.config?.keywords || '', delaySeconds: data.config?.delaySeconds || 5, loopCount: data.config?.loopCount || 0, }) // Populate Message Form if applicable if (data.type === 'send-message' && data.config?.message) { // Map saved message config back to input form const msgType = data.config.messageType || Message.TEXT messageForm.setFieldValue('type', msgType) if (msgType === Message.TEXT) { messageForm.setFieldValue('inputText', data.config.message) } // Note: For full media re-population, you'd need to fetch from DB like in ModalCreateUpdateTemplate // For simplicity in this step, we focus on Text first. } else { messageForm.reset() } } }, [selectedNode]) const handleSave = () => { if (form.validate().hasErrors) return const { type } = selectedNode.data let specificConfig = {} // Extract config based on Node Type switch (type) { case 'trigger': specificConfig = { triggerType: form.values.triggerType, keywords: form.values.keywords, } break case 'delay': specificConfig = { delaySeconds: form.values.delaySeconds, } break case 'loop': specificConfig = { loopCount: form.values.loopCount, } break case 'send-message': specificConfig = { messageType: messageForm.values.type, message: getMessage(), // Helper from useInputMessage } break } onSave(selectedNode.id, { label: form.values.label, type: type, // Persist internal type config: specificConfig, }) } if (!selectedNode) return null const nodeType = selectedNode.data.type || 'default' return ( <Paper w={350} h="100%" radius={0} style={{ backgroundColor: '#0f172a', borderLeft: '1px solid #1e293b', zIndex: 10, display: 'flex', flexDirection: 'column', }} > {/* Header */} <Group justify="space-between" p="md" style={{ borderBottom: '1px solid #1e293b' }} > <Group gap="xs"> <Icon icon="tabler:settings" fontSize={20} color="#34d399" /> <Text fw={600} size="sm" c="white"> Properties </Text> </Group> <ActionIcon variant="subtle" color="gray" onClick={onClose}> <Icon icon="tabler:x" fontSize={18} /> </ActionIcon> </Group> {/* Content */} <ScrollArea style={{ flex: 1 }} p="md"> <Stack gap="md"> <TextInput label="Node Label" placeholder="Name this step" {...form.getInputProps('label')} styles={{ input: { backgroundColor: 'rgba(255,255,255,0.05)', color: 'white', }, }} /> <Divider color="rgba(255,255,255,0.1)" /> {/* Dynamic Configuration Fields */} <When condition={nodeType === 'trigger'}> <Select label="Trigger Type" data={[ // MODIFIED: Added Manual option { value: 'manual', label: 'Manual (Play Button)' }, { value: 'keyword', label: 'Message Contains Keyword' }, { value: 'exact', label: 'Exact Match' }, { value: 'any', label: 'Any Incoming Message' }, ]} {...form.getInputProps('triggerType')} comboboxProps={{ withinPortal: false }} /> {/* Conditional Render for Keywords */} <When condition={ form.values.triggerType !== 'any' && form.values.triggerType !== 'manual' } > <TextInput label="Keywords" placeholder="promo, discount, help" description="Comma separated" {...form.getInputProps('keywords')} /> </When> </When> <When condition={nodeType === 'delay'}> <NumberInput label="Delay Duration (Seconds)" min={1} {...form.getInputProps('delaySeconds')} /> </When> <When condition={nodeType === 'loop'}> <NumberInput label="Max Loops" description="0 for infinite" min={0} {...form.getInputProps('loopCount')} /> </When> <When condition={nodeType === 'send-message'}> <Box> <Text size="sm" fw={500} mb={4}> Message Configuration </Text> <InputMessage form={messageForm} allowProTypes={true} /> </Box> </When> </Stack> </ScrollArea> {/* Footer */} <Box p="md" style={{ borderTop: '1px solid #1e293b' }}> <Button fullWidth color="emerald" onClick={handleSave} leftSection={<Icon icon="tabler:device-floppy" />} > Save Properties </Button> </Box> </Paper> ) } export default PropertiesPanel \`\`\` # src/features/workflow/components/StepConfig/ConfigChatAction.tsx \`\`\`tsx import { Icon } from '@iconify/react' import { Center, SegmentedControl, Stack, Text } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import _ from 'lodash' import React from 'react' interface Props { configPath: string form: UseFormReturnType<any> type: 'archive' | 'pin' | 'mute' } const ConfigChatAction: React.FC<Props> = ({ configPath, form, type }) => { // Default to true (Active/Enable) if undefined const currentValue = _.get(form.values, `${configPath}.action`) !== false const config = { archive: { trueLabel: 'Archive', trueIcon: 'tabler:archive', falseLabel: 'Unarchive', falseIcon: 'tabler:archive-off', color: 'pink', }, pin: { trueLabel: 'Pin Chat', trueIcon: 'tabler:pin', falseLabel: 'Unpin', falseIcon: 'tabler:pin-off', color: 'grape', }, mute: { trueLabel: 'Mute', trueIcon: 'tabler:volume-off', falseLabel: 'Unmute', falseIcon: 'tabler:volume', color: 'indigo', }, }[type] return ( <Stack gap="xs"> <Text size="sm" fw={500}> Action </Text> <SegmentedControl fullWidth value={currentValue ? 'enable' : 'disable'} onChange={(val) => form.setFieldValue(`${configPath}.action`, val === 'enable') } color={config.color} data={[ { value: 'enable', label: ( <Center> <Icon icon={config.trueIcon} style={{ marginRight: 6 }} fontSize={16} /> <Text size="xs" fw={600}> {config.trueLabel} </Text> </Center> ), }, { value: 'disable', label: ( <Center> <Icon icon={config.falseIcon} style={{ marginRight: 6 }} fontSize={16} /> <Text size="xs" fw={500}> {config.falseLabel} </Text> </Center> ), }, ]} /> </Stack> ) } export default ConfigChatAction \`\`\` # src/features/workflow/components/StepConfig/ConfigSendLocation.tsx \`\`\`tsx import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { ActionIcon, Button, Divider, Group, Stack, Text, TextInput, Tooltip, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React, { useState } from 'react' interface Props { configPath: string form: UseFormReturnType<any> } const ConfigSendLocation: React.FC<Props> = ({ configPath, form }) => { const [mapUrl, setMapUrl] = useState('') const handleOpenMaps = () => { window.open('https://www.google.com/maps', '_blank') } const handleParseUrl = () => { if (!mapUrl) return // Regex to find coordinates in Google Maps URL // Supports formats: @-6.200,106.816 or q=-6.2,106.8 or ?ll=-6.2,106.8 const latLngRegex = /[@?&](?:ll=|q=)?(-?\d+\.\d+),(-?\d+\.\d+)/ const match = mapUrl.match(latLngRegex) if (match && match.length >= 3) { const lat = match[1] const lng = match[2] form.setFieldValue(`${configPath}.messageContent.lat`, lat) form.setFieldValue(`${configPath}.messageContent.lng`, lng) toast.success('Coordinates extracted successfully!') setMapUrl('') // Clear input after success } else { toast.error('Could not find coordinates in this URL.') } } return ( <Stack gap="sm"> {/* Helper Section */} <Stack gap="xs" p="xs" style={{ border: '1px dashed var(--mantine-color-default-border)', borderRadius: 8, backgroundColor: 'rgba(255,255,255,0.02)', }} > <Group justify="space-between"> <Text size="xs" fw={600} c="dimmed" tt="uppercase"> Google Maps Helper </Text> <Tooltip label="Open Google Maps in new tab"> <ActionIcon variant="subtle" size="xs" onClick={handleOpenMaps}> <Icon icon="tabler:external-link" /> </ActionIcon> </Tooltip> </Group> <Group gap="xs" align="flex-end"> <TextInput label="Paste Maps Link" placeholder="e.g. https://goo.gl/maps/..." size="xs" style={{ flex: 1 }} value={mapUrl} onChange={(e) => setMapUrl(e.currentTarget.value)} /> <Button size="xs" variant="light" onClick={handleParseUrl} disabled={!mapUrl} > Auto-fill </Button> </Group> </Stack> <Divider label="Manual Coordinates" labelPosition="center" /> {/* Inputs */} <Group grow> <TextInput label="Latitude" placeholder="-6.200000" required {...form.getInputProps(`${configPath}.messageContent.lat`)} /> <TextInput label="Longitude" placeholder="106.816666" required {...form.getInputProps(`${configPath}.messageContent.lng`)} /> </Group> <TextInput label="Location Name" {...form.getInputProps(`${configPath}.messageContent.name`)} /> <TextInput label="Address" {...form.getInputProps(`${configPath}.messageContent.address`)} /> </Stack> ) } export default ConfigSendLocation \`\`\` # src/features/workflow/components/StepConfig/ConfigSendMedia.tsx \`\`\`tsx import InputTextarea from '@/components/Input/InputTextarea' import Upload from '@/components/Input/Message/Upload' import { Media } from '@/constants' import db from '@/libs/db' import { Icon } from '@iconify/react' import { ActionIcon, Alert, Box, Group, Stack, Text } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import _ from 'lodash' import React, { useEffect, useState } from 'react' import type { StepType } from '../../types' interface Props { stepType: StepType stepId: string configPath: string form: UseFormReturnType<any> } // Batas aman WhatsApp ~16MB const MAX_VIDEO_SAFE_SIZE = 16 * 1024 * 1024 const formatBytes = (bytes: number, decimals = 2) => { if (!+bytes) return '0 Bytes' const k = 1024 const dm = decimals < 0 ? 0 : decimals const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'] const i = Math.floor(Math.log(bytes) / Math.log(k)) return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}` } const ConfigSendMedia: React.FC<Props> = ({ stepType, stepId, configPath, form, }) => { const [mediaData, setMediaData] = useState<{ name: string size: number } | null>(null) // Variables available for Caption const variables = [ { label: 'Name', variable: '{name}' }, { label: 'Number', variable: '{number}' }, { label: 'Date', variable: '{date}' }, { label: 'Time', variable: '{time}' }, ] useEffect(() => { // Ambil mediaId dari form state const mediaId = _.get(form.values, `${configPath}.mediaId`) if (mediaId) { db.media.get(mediaId).then((media) => { if (media && media.file) { setMediaData({ name: media.name, size: media.file.size }) } }) } else { setMediaData(null) } }, [stepId, form.values]) const handleFileUpload = async (file: File) => { const mediaId = await db.media.add({ parentId: 0, type: Media.WORKFLOW, name: file.name, file: file, ext: file.type, }) form.setFieldValue(`${configPath}.mediaId`, mediaId) setMediaData({ name: file.name, size: file.size }) } const handleFileRemove = () => { form.setFieldValue(`${configPath}.mediaId`, null) setMediaData(null) } const getUploadType = () => { switch (stepType) { case 'send-image': return 'image' case 'send-video': return 'video' case 'send-audio': return 'audio' default: return 'file' } } const getIconForType = () => { switch (stepType) { case 'send-image': return 'tabler:photo' case 'send-video': return 'tabler:video' case 'send-audio': return 'tabler:volume' default: return 'tabler:file' } } const showSizeWarning = stepType === 'send-video' && mediaData && mediaData.size > MAX_VIDEO_SAFE_SIZE return ( <Stack gap="md"> {/* --- MEDIA UPLOAD SECTION --- */} <Box> <Text size="sm" fw={500} mb={4}> Media File </Text> {mediaData ? ( <Stack gap="xs"> <Group justify="space-between" p="sm" style={{ border: '1px solid var(--mantine-color-default-border)', borderRadius: 8, backgroundColor: 'rgba(255,255,255,0.03)', }} > <Group gap="sm" wrap="nowrap" style={{ overflow: 'hidden' }}> <ActionIcon variant="light" color="blue" size="lg" radius="md"> <Icon icon={getIconForType()} fontSize={20} /> </ActionIcon> <Stack gap={0} style={{ overflow: 'hidden' }}> <Text size="sm" fw={500} truncate> {mediaData.name} </Text> <Text size="xs" c="dimmed"> {formatBytes(mediaData.size)} </Text> </Stack> </Group> <ActionIcon color="red" variant="subtle" onClick={handleFileRemove} > <Icon icon="tabler:trash" fontSize={18} /> </ActionIcon> </Group> {/* Warning Alert */} {showSizeWarning && ( <Alert variant="light" color="orange" title="Large Video Detected" icon={<Icon icon="tabler:alert-triangle" />} > File size ({formatBytes(mediaData.size)}) exceeds the 16MB safe limit for WhatsApp auto-sending. </Alert> )} </Stack> ) : ( <Upload type={getUploadType()} value={null} onDrop={handleFileUpload} onRemove={() => {}} /> )} </Box> {/* --- CAPTION INPUT SECTION --- */} {/* Audio does not support caption in standard WA behavior */} {stepType !== 'send-audio' && ( <Box> <Group justify="space-between" mb={4}> <Text size="sm" fw={500}> Caption </Text> </Group> <InputTextarea // Menggunakan _.get untuk akses aman ke nested object // Jika undefined, fallback ke string kosong agar input terkontrol value={_.get( form.values, `${configPath}.messageContent.caption`, '', )} onChange={(val) => form.setFieldValue(`${configPath}.messageContent.caption`, val) } placeholder="Add a caption... (supports {name})" variables={variables} /> </Box> )} </Stack> ) } export default ConfigSendMedia \`\`\` # src/features/workflow/components/StepConfig/ConfigSendPoll.tsx \`\`\`tsx import { Icon } from '@iconify/react' import { ActionIcon, Badge, Button, Fieldset, Group, Stack, Text, TextInput, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import _ from 'lodash' import React from 'react' import { When } from 'react-if' interface Props { path: string configPath: string form: UseFormReturnType<any> } const MAX_OPTIONS = 12 const MAX_CHAR_LIMIT = 100 const ConfigSendPoll: React.FC<Props> = ({ path, configPath, form }) => { const choices = _.get(form.values, `${path}.config.messageContent.choices`) || [] return ( <Stack gap="sm"> <TextInput label="Poll Name" placeholder="Ask a question..." description="The title of your poll." required {...form.getInputProps(`${configPath}.messageContent.name`)} /> <Fieldset legend={ <Group justify="space-between" w="100%"> <Text size="xs" fw={500}> Choices </Text> <Badge size="sm" variant="light" color="gray"> {choices.length} / {MAX_OPTIONS} </Badge> </Group> } style={{ backgroundColor: 'rgba(255,255,255,0.02)' }} > <Stack gap="xs"> {choices.map((choice: string, index: number) => { const charCount = choice?.length || 0 const isNearLimit = charCount > MAX_CHAR_LIMIT return ( <Stack gap={0} key={index}> <Group gap="xs" wrap="nowrap" align="flex-start"> <TextInput style={{ flex: 1 }} placeholder={`Option ${index + 1}`} rightSection={ <Text size="xs" c={isNearLimit ? 'red' : 'dimmed'}> {charCount} </Text> } {...form.getInputProps( `${configPath}.messageContent.choices.${index}`, )} /> <When condition={choices.length > 2}> <ActionIcon color="red" variant="subtle" size="lg" onClick={() => form.removeListItem( `${configPath}.messageContent.choices`, index, ) } > <Icon icon="tabler:trash" fontSize={18} /> </ActionIcon> </When> </Group> {/* Warning for character limit */} <When condition={isNearLimit}> <Text size="xs" c="red" mt={2}> Option might be too long for WhatsApp. </Text> </When> </Stack> ) })} <When condition={choices.length < MAX_OPTIONS}> <Button variant="light" color="emerald" size="xs" fullWidth mt="xs" onClick={() => form.insertListItem(`${configPath}.messageContent.choices`, '') } leftSection={<Icon icon="tabler:plus" />} > Add Option </Button> </When> <When condition={choices.length >= MAX_OPTIONS}> <Text size="xs" c="dimmed" ta="center" mt="xs"> Maximum of {MAX_OPTIONS} options reached. </Text> </When> </Stack> </Fieldset> </Stack> ) } export default ConfigSendPoll \`\`\` # src/features/workflow/components/StepConfig/ConfigSendText.tsx \`\`\`tsx import InputTextarea from '@/components/Input/InputTextarea' import { Box, Text } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import _ from 'lodash' import React from 'react' interface Props { configPath: string form: UseFormReturnType<any> } const ConfigSendText: React.FC<Props> = ({ configPath, form }) => { // Define available variables for the workflow context const variables = [ { label: 'Name', variable: '{name}' }, { label: 'Number', variable: '{number}' }, { label: 'Date', variable: '{date}' }, { label: 'Time', variable: '{time}' }, ] const value = _.get(form.values, `${configPath}.messageContent`) || '' return ( <Box> <Text size="sm" fw={500} mb={4}> Message Text </Text> <InputTextarea value={value} onChange={(val) => form.setFieldValue(`${configPath}.messageContent`, val) } placeholder="Hello {name}, how can we help you today?" variables={variables} error={form.errors[`${configPath}.messageContent`]} /> </Box> ) } export default ConfigSendText \`\`\` # src/features/workflow/components/StepConfig/ConfigTags.tsx \`\`\`tsx import db from '@/libs/db' import { Icon } from '@iconify/react' import { Alert, Center, SegmentedControl, Select, Stack, Text, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import { useLiveQuery } from 'dexie-react-hooks' import _ from 'lodash' import React, { useMemo } from 'react' import { When } from 'react-if' interface Props { configPath: string form: UseFormReturnType<any> } const ConfigTags: React.FC<Props> = ({ configPath, form }) => { const tags = useLiveQuery(() => db.tags.toArray()) || [] const tagOptions = useMemo( () => tags.map((t) => ({ value: t.name, label: t.name })), [tags], ) // Default to 'add' if undefined const currentAction = _.get(form.values, `${configPath}.action`) || 'add' const isRemove = currentAction === 'remove' return ( <Stack gap="md"> <Stack gap="xs"> <Text size="sm" fw={500}> Action </Text> <SegmentedControl fullWidth value={currentAction} onChange={(val) => form.setFieldValue(`${configPath}.action`, val)} color="indigo" data={[ { value: 'add', label: ( <Center> <Icon icon="tabler:tag" style={{ marginRight: 6 }} fontSize={16} /> <Text size="xs" fw={600}> Add Tag </Text> </Center> ), }, { value: 'remove', label: ( <Center> <Icon icon="tabler:tag-off" style={{ marginRight: 6 }} fontSize={16} /> <Text size="xs" fw={500}> Remove Tag </Text> </Center> ), }, ]} /> </Stack> <Select label="Select Tag" description={ isRemove ? 'Select the tag to remove from the contact.' : 'Select the tag to apply to the contact.' } data={tagOptions} placeholder="Choose a tag" searchable {...form.getInputProps(`${configPath}.tagName`)} comboboxProps={{ withinPortal: false }} leftSection={ <Icon icon={isRemove ? 'tabler:tag-off' : 'tabler:tag'} fontSize={16} color={ isRemove ? 'var(--mantine-color-red-5)' : 'var(--mantine-color-indigo-5)' } /> } /> <When condition={!!form.values[configPath]?.tagName}> <Alert variant="light" color={isRemove ? 'red' : 'indigo'} title={isRemove ? 'Remove Action' : 'Add Action'} icon={<Icon icon={isRemove ? 'tabler:tag-off' : 'tabler:tag'} />} > {isRemove ? `The tag "${form.values[configPath]?.tagName}" will be detached from the contact.` : `The tag "${form.values[configPath]?.tagName}" will be attached to the contact.`} </Alert> </When> </Stack> ) } export default ConfigTags \`\`\` # src/features/workflow/components/StepConfig/ConfigTrigger.tsx \`\`\`tsx import type { UseFormReturnType } from '@mantine/form' import _ from 'lodash' import React from 'react' import ConfigTriggerManual from './ConfigTriggerManual' import ConfigTriggerMessage from './ConfigTriggerMessage' interface Props { configPath: string form: UseFormReturnType<any> } const ConfigTrigger: React.FC<Props> = ({ configPath, form }) => { // Watch form values const triggerType = _.get(form.values, `${configPath}.triggerType`) const isManual = triggerType === 'manual' if (isManual) { return <ConfigTriggerManual configPath={configPath} form={form} /> } return <ConfigTriggerMessage configPath={configPath} form={form} /> } export default ConfigTrigger \`\`\` # src/features/workflow/components/StepConfig/ConfigTriggerManual.tsx \`\`\`tsx import { Icon } from '@iconify/react' import { ActionIcon, Button, Divider, Group, Select, Stack, Switch, Table, Text, TextInput, Tooltip, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import _ from 'lodash' import React from 'react' interface Props { configPath: string form: UseFormReturnType<any> } const ConfigTriggerManual: React.FC<Props> = ({ configPath, form }) => { const inputs = _.get(form.values, `${configPath}.inputs`) || [] const handleAddInput = () => { const inputPath = `${configPath}.inputs` const newItem = { key: '', label: '', type: 'text' } const currentList = _.get(form.values, inputPath) if (!Array.isArray(currentList)) { form.setFieldValue(inputPath, [newItem]) } else { form.insertListItem(inputPath, newItem) } } return ( <Stack gap="md"> <Switch label={ <Group gap={4}> <Text fw={500} size="sm"> Require Confirmation </Text> <Tooltip position="top" label="Shows a confirmation dialog before running." withArrow > <Icon icon="tabler:help-circle" style={{ opacity: 0.7 }} /> </Tooltip> </Group> } {...form.getInputProps(`${configPath}.requireConfirmation`, { type: 'checkbox', })} /> <Stack gap="xs"> <Text size="xs" c="dimmed"> Define variables to ask for when running this workflow. </Text> <Table withTableBorder withColumnBorders> <Table.Thead> <Table.Tr> <Table.Th>Key (Variable)</Table.Th> <Table.Th>Label (Prompt)</Table.Th> <Table.Th w={100}>Type</Table.Th> <Table.Th w={50} /> </Table.Tr> </Table.Thead> <Table.Tbody> {inputs.map((_, index) => ( <Table.Tr key={index}> <Table.Td p={4}> <TextInput size="xs" placeholder="e.g. amount" px="xs" {...form.getInputProps(`${configPath}.inputs.${index}.key`)} /> </Table.Td> <Table.Td p={4}> <TextInput size="xs" placeholder="e.g. Enter Total" px="xs" {...form.getInputProps( `${configPath}.inputs.${index}.label`, )} /> </Table.Td> <Table.Td p={4}> <Select size="xs" px="xs" data={['text', 'number', 'date']} {...form.getInputProps( `${configPath}.inputs.${index}.type`, )} comboboxProps={{ withinPortal: false }} /> </Table.Td> <Table.Td p={4} align="center"> <ActionIcon color="red" variant="subtle" size="sm" onClick={() => form.removeListItem(`${configPath}.inputs`, index) } > <Icon icon="tabler:trash" fontSize={14} /> </ActionIcon> </Table.Td> </Table.Tr> ))} {inputs.length === 0 && ( <Table.Tr> <Table.Td colSpan={4}> <Text size="xs" c="dimmed" ta="center" py="xs"> No inputs defined. </Text> </Table.Td> </Table.Tr> )} </Table.Tbody> </Table> <Button variant="light" size="xs" leftSection={<Icon icon="tabler:plus" fontSize={14} />} onClick={handleAddInput} > Add Input </Button> </Stack> </Stack> ) } export default ConfigTriggerManual \`\`\` # src/features/workflow/components/StepConfig/ConfigTriggerMessage.tsx \`\`\`tsx import { useAppStore } from '@/stores/app' import { Icon } from '@iconify/react' import { Box, Center, Divider, Group, MultiSelect, SegmentedControl, Stack, TagsInput, Text, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import _ from 'lodash' import React, { useMemo } from 'react' import { When } from 'react-if' interface Props { configPath: string form: UseFormReturnType<any> } const ConfigTriggerMessage: React.FC<Props> = ({ configPath, form }) => { const { groups } = useAppStore() const groupOptions = useMemo(() => { return groups.map((g: any) => ({ value: g.id._serialized || g.id, label: g.name || 'Unknown Group', })) }, [groups]) // Watch form values const triggerType = _.get(form.values, `${configPath}.triggerType`) const scope = _.get(form.values, `${configPath}.scope`) const keywords = _.get(form.values, `${configPath}.keyword`) return ( <Stack gap="md"> <Box> <Text size="sm" fw={500} mb={4}> Message Matching </Text> <SegmentedControl fullWidth size="xs" value={triggerType} onChange={(val) => form.setFieldValue(`${configPath}.triggerType`, val) } data={[ { value: 'keyword', label: 'Contains Keyword' }, { value: 'exact', label: 'Exact Match' }, { value: 'any', label: 'Any Message' }, ]} /> <When condition={triggerType !== 'any'}> <Box mt="sm"> <TagsInput label="Keywords" placeholder="Type and press Enter" description="Trigger if message matches any of these." {...form.getInputProps(`${configPath}.keyword`)} value={ Array.isArray(keywords) ? keywords : keywords ? [keywords] : [] } onChange={(val) => form.setFieldValue(`${configPath}.keyword`, val) } /> </Box> </When> </Box> <Divider color="rgba(255,255,255,0.1)" /> <Box> <Text size="sm" fw={500} mb={4}> Scope </Text> <SegmentedControl fullWidth value={scope} onChange={(val) => form.setFieldValue(`${configPath}.scope`, val)} data={[ { value: 'all', label: ( <Center> <Icon icon="tabler:world" style={{ marginRight: 6 }} /> <Text size="xs" fw={500}> All </Text> </Center> ), }, { value: 'Personal', label: ( <Center> <Icon icon="tabler:user" style={{ marginRight: 6 }} /> <Text size="xs" fw={500}> Personal </Text> </Center> ), }, { value: 'group_any', label: ( <Center> <Icon icon="tabler:users" style={{ marginRight: 6 }} /> <Text size="xs" fw={500}> Any Group </Text> </Center> ), }, { value: 'group_specific', label: ( <Center> <Icon icon="tabler:users-plus" style={{ marginRight: 6 }} /> <Text size="xs" fw={500}> Specific </Text> </Center> ), }, ]} /> <When condition={scope === 'group_specific'}> <MultiSelect mt="xs" label="Select Target Groups" placeholder="Pick groups..." data={groupOptions} {...form.getInputProps(`${configPath}.targetGroupIds`)} searchable clearable hidePickedOptions comboboxProps={{ withinPortal: false }} /> </When> </Box> </Stack> ) } export default ConfigTriggerMessage \`\`\` # src/features/workflow/components/StepConfig/ConfigUpdateField.tsx \`\`\`tsx import db from '@/libs/db' import { Icon } from '@iconify/react' import { Center, SegmentedControl, Select, Stack, Text, TextInput, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import { useLiveQuery } from 'dexie-react-hooks' import _ from 'lodash' import React, { useMemo } from 'react' interface Props { configPath: string form: UseFormReturnType<any> } const ConfigUpdateField: React.FC<Props> = ({ configPath, form }) => { const customFields = useLiveQuery(() => db.customFields.toArray()) || [] const fieldOptions = useMemo( () => customFields.map((f) => ({ value: String(f.id), label: f.name })), [customFields], ) // Watch the checkbox value to determine UI state const useTriggerMessage = _.get( form.values, `${configPath}.useTriggerMessage`, ) return ( <Stack gap="md"> <Select label="Target Field" description="Select the custom field to update." data={fieldOptions} placeholder="Select field" {...form.getInputProps(`${configPath}.customFieldId`)} comboboxProps={{ withinPortal: false }} leftSection={<Icon icon="tabler:database" fontSize={16} />} /> <Stack gap="xs"> <Text size="sm" fw={500}> Data Source </Text> <SegmentedControl fullWidth value={useTriggerMessage ? 'dynamic' : 'static'} onChange={(val) => { // Map segmented control back to boolean form value form.setFieldValue( `${configPath}.useTriggerMessage`, val === 'dynamic', ) // Optional: Clear value if switching to dynamic to avoid confusion if (val === 'dynamic') { form.setFieldValue(`${configPath}.value`, '') } }} data={[ { value: 'static', label: ( <Center> <Icon icon="tabler:keyboard" style={{ marginRight: 6 }} /> <Text size="xs" fw={500}> Static Value </Text> </Center> ), }, { value: 'dynamic', label: ( <Center> <Icon icon="tabler:message-circle-2" style={{ marginRight: 6 }} /> <Text size="xs" fw={500}> From Message </Text> </Center> ), }, ]} /> </Stack> <TextInput label="Value to Save" placeholder={useTriggerMessage ? '{message_body}' : 'Enter value here'} description={ useTriggerMessage ? 'The content of the incoming message will be saved.' : 'This specific text will be saved to the field.' } disabled={useTriggerMessage} {...form.getInputProps(`${configPath}.value`)} styles={{ input: { // Visual cue when disabled/dynamic color: useTriggerMessage ? 'var(--mantine-color-emerald-4)' : undefined, fontWeight: useTriggerMessage ? 600 : undefined, }, }} /> </Stack> ) } export default ConfigUpdateField \`\`\` # src/features/workflow/components/StepConfig/index.tsx \`\`\`tsx export { default as ConfigChatAction } from './ConfigChatAction' export { default as ConfigSendLocation } from './ConfigSendLocation' export { default as ConfigSendMedia } from './ConfigSendMedia' export { default as ConfigSendPoll } from './ConfigSendPoll' export { default as ConfigSendText } from './ConfigSendText' export { default as ConfigTags } from './ConfigTags' export { default as ConfigTrigger } from './ConfigTrigger' export { default as ConfigUpdateField } from './ConfigUpdateField' \`\`\` # src/features/workflow/components/StepConfig/Shared/GroupSelector.tsx \`\`\`tsx import { useAppStore } from '@/stores/app' import { Icon } from '@iconify/react' import { Avatar, Group, Select, Text } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React, { useMemo } from 'react' interface Props { form: UseFormReturnType<any> fieldPath: string // e.g., 'steps.0.config.groupId' label?: string description?: string placeholder?: string required?: boolean disabled?: boolean } const GroupSelector: React.FC<Props> = ({ form, fieldPath, label = 'Target Group', description, placeholder = 'Select a group...', required = false, disabled = false, }) => { const { groups } = useAppStore() const groupOptions = useMemo(() => { return groups.map((g: any) => ({ value: g.id._serialized || g.id, label: g.name || 'Unknown Group', avatar: g.avatar, })) }, [groups]) return ( <Select label={label} description={description} placeholder={placeholder} data={groupOptions} searchable clearable required={required} disabled={disabled} leftSection={<Icon icon="tabler:users-group" fontSize={16} />} {...form.getInputProps(fieldPath)} renderOption={({ option }) => { // @ts-ignore custom props const { label, avatar } = option return ( <Group gap="sm" wrap="nowrap"> <Avatar src={avatar} size="sm" radius="xl"> {label?.[0]} </Avatar> <Text size="sm">{label}</Text> </Group> ) }} comboboxProps={{ withinPortal: false }} /> ) } export default GroupSelector \`\`\` # src/features/workflow/components/StepConfig/Shared/ParticipantSelector.tsx \`\`\`tsx import ModalSourcePhoneContacts from '@/features/broadcast/components/Modal/ModalSourcePhoneContacts' import { Icon } from '@iconify/react' import { ActionIcon, Group, Input, TagsInput, Tooltip } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import { useDisclosure } from '@mantine/hooks' import _ from 'lodash' import React from 'react' import VariableChips from './VariableChips' interface Props { form: UseFormReturnType<any> fieldPath: string // e.g. 'steps.0.config.participants' label?: string description?: string } const ParticipantSelector: React.FC<Props> = ({ form, fieldPath, label = 'Participants', description, }) => { const [opened, { open, close }] = useDisclosure(false) // Convert comma-separated string to array for TagsInput const rawValue = _.get(form.values, fieldPath) || '' const value = rawValue ? String(rawValue) .split(',') .map((s) => s.trim()) .filter(Boolean) : [] const handleChange = (tags: string[]) => { form.setFieldValue(fieldPath, tags.join(',')) } const handleAddFromModal = (recipients: any[]) => { const newNumbers = recipients.map((r) => r.number) const combined = [...new Set([...value, ...newNumbers])] handleChange(combined) } const handleInsertVariable = (variable: string) => { const combined = [...value, variable] handleChange(combined) } return ( <Input.Wrapper label={label} description={description}> <Group align="flex-start" gap={6}> <TagsInput placeholder="Type number and press Enter" data={[]} value={value} onChange={handleChange} style={{ flex: 1 }} leftSection={<Icon icon="tabler:user" fontSize={16} />} splitChars={[',', ' ', '\n']} /> <Tooltip label="Pick from Contacts"> <ActionIcon variant="light" size="lg" color="emerald" onClick={open} style={{ marginTop: 2 }} > <Icon icon="tabler:address-book" fontSize={20} /> </ActionIcon> </Tooltip> </Group> <VariableChips onInsert={handleInsertVariable} /> <ModalSourcePhoneContacts opened={opened} onClose={close} onSubmit={handleAddFromModal} /> </Input.Wrapper> ) } export default ParticipantSelector \`\`\` # src/features/workflow/components/StepConfig/Shared/VariableChips.tsx \`\`\`tsx import { Badge, Group, Text } from '@mantine/core' import React from 'react' interface Props { onInsert: (variable: string) => void } const VARIABLES = [ { label: 'Date', value: '{date}' }, { label: 'Time', value: '{time}' }, { label: 'Sender Number', value: '{sender_number}' }, { label: 'Sender Name', value: '{sender_name}' }, ] const VariableChips: React.FC<Props> = ({ onInsert }) => { return ( <Group gap={6} mt={6}> <Text size="xs" c="dimmed"> Quick Vars: </Text> {VARIABLES.map((v) => ( <Badge key={v.value} size="xs" variant="outline" color="gray" style={{ cursor: 'pointer', textTransform: 'none' }} onClick={() => onInsert(v.value)} > {v.label} </Badge> ))} </Group> ) } export default VariableChips \`\`\` # src/features/workflow/components/StepConfiguration.tsx \`\`\`tsx import { Icon } from '@iconify/react' import { Divider, Group, Stack, Switch, Text, TextInput, Tooltip, } from '@mantine/core' import type { UseFormReturnType } from '@mantine/form' import React from 'react' import type { WorkflowStep } from '../types' import { ConfigChatAction, ConfigSendLocation, ConfigSendMedia, ConfigSendPoll, ConfigSendText, ConfigTags, ConfigTrigger, ConfigUpdateField, } from './StepConfig' interface Props { step: WorkflowStep path: string form: UseFormReturnType<any> } const StepConfiguration: React.FC<Props> = ({ step, path, form }) => { const configPath = `${path}.config` const renderStepConfig = () => { switch (step.type) { case 'send-text': return <ConfigSendText configPath={configPath} form={form} /> case 'send-image': case 'send-video': case 'send-audio': case 'send-document': return ( <ConfigSendMedia stepType={step.type} stepId={step.id} configPath={configPath} form={form} /> ) case 'send-poll': return ( <ConfigSendPoll path={path} configPath={configPath} form={form} /> ) case 'send-location': return <ConfigSendLocation configPath={configPath} form={form} /> case 'trigger': return <ConfigTrigger configPath={configPath} form={form} /> case 'tag': return <ConfigTags configPath={configPath} form={form} /> case 'update-field': return <ConfigUpdateField configPath={configPath} form={form} /> case 'archive-chat': return ( <ConfigChatAction configPath={configPath} form={form} type="archive" /> ) case 'pin-chat': return ( <ConfigChatAction configPath={configPath} form={form} type="pin" /> ) case 'mute-chat': return ( <ConfigChatAction configPath={configPath} form={form} type="mute" /> ) default: return null } } return ( <Stack gap="md" p="xs"> <TextInput label="Step Label" description="A name to identify this step" {...form.getInputProps(`${path}.label`)} /> {renderStepConfig()} </Stack> ) } export default StepConfiguration \`\`\` # src/features/workflow/components/WorkflowListener.tsx \`\`\`tsx // src/features/workflow/components/WorkflowListener.tsx import { Action } from '@/constants' import { WorkflowRunner } from '@/features/workflow/engine/WorkflowRunner' import useWa from '@/hooks/useWa' import useWindowMessage from '@/hooks/useWindowMessage' // Import ini penting import db from '@/libs/db' import React from 'react' const WorkflowListener: React.FC = () => { const wa = useWa() useWindowMessage(async (event: MessageEvent) => { const { data: { action, body }, } = event if (action === Action.Window.NEW_MESSAGE) { const msg = body await handleIncomingMessage(msg) } }) const handleIncomingMessage = async (msg: any) => { if (msg.fromMe || msg.isStatus || msg.type === 'e2e_notification') return const messageBody = (msg.body || msg.caption || '').trim() if (!messageBody) return try { console.log(msg) const allWorkflows = await db.workflows.toArray() const matchedWorkflows = allWorkflows.filter((workflow) => { // Skip disabled workflows if (workflow.enabled === false) return false const triggerStep = workflow.steps.find((s) => s.type === 'trigger') if (!triggerStep || triggerStep.config?.triggerType === 'manual') return false console.log(triggerStep) const config = triggerStep.config || {} const isGroup = msg.isGroup || msg.to.server.includes('@g.us') || msg.from.server.includes('@g.us') if (config.scope === 'Personal' && isGroup) return false if (config.scope === 'group_any' && !isGroup) return false if (config.scope === 'group_specific') { const targetIds = config.targetGroupIds || [] // Gunakan msg.from (pengirim) atau msg.to (tujuan) tergantung konteks const chatContext = msg.from.user if (!targetIds.includes(chatContext)) return false } // B. Cek Keyword const triggerType = config.triggerType const keywords = Array.isArray(config.keyword) ? config.keyword : (config.keyword || '') .split(',') .map((k: string) => k.trim()) .filter(Boolean) if (triggerType === 'any') return true const msgLower = messageBody.toLowerCase() return keywords.some((k: string) => { const keywordLower = k.toLowerCase() return triggerType === 'exact' ? msgLower === keywordLower : msgLower.includes(keywordLower) }) }) // 4. Eksekusi for (const workflow of matchedWorkflows) { console.log(`[Workflow] Running "${workflow.name}"`) // Siapkan variabel const senderNumber = msg.contact?.number || msg.from?.user.split('@')[0] const senderName = msg.contact?.name || msg.contact?.pushname || 'Unknown' const runner = new WorkflowRunner(workflow.steps, { triggerMessage: messageBody, // overrideChatId penting agar bot membalas ke chat yang benar overrideChatId: msg.from.user, isDryRun: false, mockVariables: { sender_number: senderNumber, sender_name: senderName, }, }) runner .run() .catch((err) => console.error(`[Workflow] Execution failed:`, err)) } } catch (error) { console.error('[Workflow] Listener error:', error) } } return null } export default WorkflowListener \`\`\` # src/features/workflow/components/WorkflowPopover.tsx \`\`\`tsx import { flattenSteps } from '@/features/workflow/utils/flatten' import db, { type Workflow } from '@/libs/db' import confirm from '@/utils/confirm' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { ActionIcon, Box, Center, Divider, Group, Loader, Paper, Popover, ScrollArea, Stack, Text, TextInput, ThemeIcon, Tooltip, } from '@mantine/core' import { useDebouncedValue, useDisclosure } from '@mantine/hooks' import { useLiveQuery } from 'dexie-react-hooks' import React, { useMemo, useState } from 'react' import { WorkflowRunner } from '../engine/WorkflowRunner' interface Props { chat: any } const WorkflowPopover: React.FC<Props> = ({ chat }) => { const [opened, { close, open }] = useDisclosure(false) const [search, setSearch] = useState('') const [debouncedSearch] = useDebouncedValue(search, 300) const [runningId, setRunningId] = useState<number | null>(null) // Fetch only Manual Trigger workflows const workflows = useLiveQuery(async () => { const all = await db.workflows.toArray() return all.filter((w) => { const trigger = w.steps.find((s) => s.type === 'trigger') return trigger?.config?.triggerType === 'manual' }) }, []) || [] const filteredWorkflows = useMemo(() => { if (!workflows) return [] let result = [...workflows] if (debouncedSearch) { const lowerQuery = debouncedSearch.toLowerCase() result = result.filter((w) => w.name.toLowerCase().includes(lowerQuery)) } return result }, [workflows, debouncedSearch]) const handleRun = async (workflow: Workflow) => { if (!chat || !chat.id) return const chatId = chat.id._serialized || chat.id // 1. Check for Confirmation/Dry Run flag const triggerStep = workflow.steps.find((s) => s.type === 'trigger') const requireConfirmation = triggerStep?.config?.requireConfirmation if (requireConfirmation) { const stepCount = flattenSteps(workflow.steps).length const confirmed = await confirm.warning( `Run "${workflow.name}"?`, `This workflow contains ${stepCount} steps. Do you want to execute it on ${chat.name || 'this chat'}?`, ) if (!confirmed) return } // 2. Close popover (optional, maybe keep open to see loader?) // keeping open to show loader state setRunningId(workflow.id) toast.info(`Starting workflow "${workflow.name}"...`) try { const runner = new WorkflowRunner(workflow.steps, { overrideChatId: chatId, triggerMessage: '', // Manual trigger has no incoming message isDryRun: false, }) await runner.run() toast.success(`Workflow "${workflow.name}" finished.`) close() } catch (error: any) { console.error(error) toast.error(`Workflow failed: ${error.message}`) } finally { setRunningId(null) } } return ( <Popover opened={opened} onChange={close} position="right-end" withArrow shadow="xl" trapFocus width={360} offset={14} transitionProps={{ duration: 200, transition: 'pop' }} > <Popover.Target> <div onMouseEnter={open} onMouseLeave={close}> <Tooltip label="Run Workflow" withArrow position="right"> <ActionIcon variant="filled" size={32} radius="50%" color={opened ? 'orange' : undefined} > <Icon icon="tabler:robot" fontSize={18} /> </ActionIcon> </Tooltip> </div> </Popover.Target> <Popover.Dropdown p={0} onMouseEnter={open} onMouseLeave={close} style={{ backgroundColor: 'rgba(0, 0, 0, 0.85)', backdropFilter: 'blur(24px) saturate(180%)', WebkitBackdropFilter: 'blur(24px) saturate(180%)', border: '1px solid rgba(255, 255, 255, 0.1)', color: '#f8fafc', }} > <Stack gap={0}> {/* Header */} <Box p="xs"> <TextInput placeholder="Search workflows..." size="xs" leftSection={<Icon icon="tabler:search" fontSize={14} />} value={search} onChange={(e) => setSearch(e.currentTarget.value)} styles={{ input: { backgroundColor: 'rgba(255, 255, 255, 0.05)', border: '1px solid rgba(255, 255, 255, 0.1)', color: '#fff', '&::placeholder': { color: 'rgba(255, 255, 255, 0.5)' }, }, }} /> </Box> <Divider color="rgba(255,255,255,0.1)" /> {/* List */} <ScrollArea h={350} type="hover"> {filteredWorkflows.length > 0 ? ( <Stack gap={4} p="xs"> {filteredWorkflows.map((workflow) => ( <Paper key={workflow.id} radius="md" p="xs" withBorder style={{ cursor: 'pointer', backgroundColor: 'rgba(255, 255, 255, 0.03)', borderColor: 'rgba(255, 255, 255, 0.08)', transition: 'background-color 0.2s', }} onClick={() => handleRun(workflow)} onMouseEnter={(e) => { e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.08)' }} onMouseLeave={(e) => { e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.03)' }} > <Group justify="space-between" align="center" wrap="nowrap"> {/* Left Side: Icon & Title */} <Group gap="sm" wrap="nowrap" style={{ flex: 1, overflow: 'hidden' }} > <ThemeIcon variant="light" color="orange" size="md" radius="xl" > <Icon icon="tabler:bolt" fontSize={16} /> </ThemeIcon> <Stack gap={0} style={{ overflow: 'hidden' }}> <Text size="sm" fw={600} c="white" truncate> {workflow.name} </Text> <Text size="xs" c="dimmed" truncate> {workflow.steps?.length || 0} steps </Text> </Stack> </Group> {/* Right Side: Action Button or Loader */} <Group gap={4}> {runningId === workflow.id ? ( <Loader size="xs" color="orange" mr={6} /> ) : ( <Tooltip label="Run Now" withArrow position="left"> <ActionIcon radius="xl" color="orange" variant="transparent" size="lg" onClick={(e) => { e.stopPropagation() handleRun(workflow) }} > <Icon icon="tabler:player-play" fontSize={18} /> </ActionIcon> </Tooltip> )} </Group> </Group> </Paper> ))} </Stack> ) : ( <Center h={150}> <Stack align="center" gap={4}> <Icon icon="tabler:robot-off" color="rgba(255,255,255,0.3)" fontSize={24} /> <Text size="xs" c="dimmed"> No manual workflows found </Text> </Stack> </Center> )} </ScrollArea> </Stack> </Popover.Dropdown> </Popover> ) } export default WorkflowPopover \`\`\` # src/features/workflow/constants/stepCategories.ts \`\`\`ts import type { StepType } from '../types' export interface StepItem { type: StepType | 'trigger-message' | 'trigger-manual' label: string description: string icon: string color: string } export interface StepCategory { title: string items: StepItem[] } export const STEP_CATEGORIES: StepCategory[] = [ // --- KATEGORI TRIGGER DIHAPUS --- { title: 'Communication', items: [ { type: 'send-text', label: 'Send Text', description: 'Send a simple text message.', icon: 'tabler:message-circle', color: 'emerald', }, { type: 'send-image', label: 'Send Image', description: 'Send a photo with caption.', icon: 'tabler:photo', color: 'emerald', }, { type: 'send-video', label: 'Send Video', description: 'Send a video file.', icon: 'tabler:video', color: 'emerald', }, { type: 'send-audio', label: 'Send Audio', description: 'Send an audio or voice note.', icon: 'tabler:microphone', color: 'emerald', }, { type: 'send-document', label: 'Send File', description: 'Send PDF, Doc, or other files.', icon: 'tabler:file', color: 'emerald', }, { type: 'send-poll', label: 'Send Poll', description: 'Create a poll for the user.', icon: 'tabler:chart-bar', color: 'emerald', }, { type: 'send-location', label: 'Send Location', description: 'Send specific coordinates.', icon: 'tabler:map-pin', color: 'emerald', }, ], }, { title: 'CRM & Data (Personal Only)', items: [ { type: 'tag', label: 'Tag', description: 'Add or remove a tag. Only works for personal chats.', icon: 'tabler:tag', color: 'indigo', }, { type: 'update-field', label: 'Update Field', description: 'Save data to a field. Only works for personal chats.', icon: 'tabler:database-edit', color: 'blue', }, ], }, { title: 'Chat Management', items: [ { type: 'archive-chat', label: 'Archive Chat', description: 'Archive or unarchive the chat.', icon: 'tabler:archive', color: 'pink', }, { type: 'pin-chat', label: 'Pin Chat', description: 'Pin or unpin the chat.', icon: 'tabler:pin', color: 'pink', }, { type: 'mute-chat', label: 'Mute Chat', description: 'Mute or unmute the chat notifications.', icon: 'tabler:volume-off', color: 'pink', }, ], }, ] \`\`\` # src/features/workflow/engine/handlers/chatHandlers.ts \`\`\`ts import wa from '@/libs/wa' export const handleArchiveChat = async (chatId: string, action: boolean) => { await wa.chat.archive(chatId, action) } export const handlePinChat = async (chatId: string, action: boolean) => { await wa.chat.pin(chatId, action) } export const handleCloseChat = async () => { await wa.chat.closeChat() } export const handleDeleteChat = async (chatId: string) => { await wa.chat._delete(chatId) } export const handleClearChat = async (chatId: string, keepStarred: boolean) => { await wa.chat.clear(chatId, keepStarred) } export const handleMuteChat = async (chatId: string, action: boolean) => { // action: true = mute, false = unmute if (action) { // Mute forever (expiration: -1 means indefinitely) await wa.chat.mute(chatId, { expiration: -1 }) } else { await wa.chat.unmute(chatId) } } \`\`\` # src/features/workflow/engine/handlers/crmHandlers.ts \`\`\`ts import CustomFieldModel from '@/features/contacts/models/CustomFieldModel' import TagModel from '@/features/contacts/models/TagModel' import db from '@/libs/db' export const handleAddTag = async ( config: any, context: { contactId?: number }, ) => { const { contactId } = context if (!contactId) throw new Error('Contact context missing.') const tagName = config.tagName if (!tagName) return const tag = await TagModel.createOrGet(tagName) if (tag && tag.id) { const existing = await db.contactTags .where({ contactId, tagId: tag.id }) .first() if (!existing) { await db.contactTags.add({ contactId, tagId: tag.id }) } } } export const handleRemoveTag = async ( config: any, context: { contactId?: number }, ) => { const { contactId } = context if (!contactId) throw new Error('Contact context missing.') const tagName = config.tagName if (!tagName) return const tag = await db.tags.where({ name: tagName }).first() if (tag && tag.id) { await db.contactTags.where({ contactId, tagId: tag.id }).delete() } } export const handleUpdateField = async ( config: any, context: { contactId?: number variables: Record<string, any> triggerMessage?: string }, updateVariableCb: (fieldId: number, value: any) => Promise<void>, ) => { const { customFieldId, value, useTriggerMessage } = config if (!customFieldId) throw new Error('Custom Field ID not specified.') let finalValue = value if (useTriggerMessage) { finalValue = context.triggerMessage || '' } // Delegate variable update back to runner via callback await updateVariableCb(Number(customFieldId), finalValue) } \`\`\` # src/features/workflow/engine/handlers/messageHandlers.ts \`\`\`ts import { Media } from '@/constants' import { resolveVariables } from '@/features/workflow/utils/variableUtils' import db from '@/libs/db' import wa from '@/libs/wa' import { delay, generateRandomDelay } from '@/utils/util' // ++ ADDED IMPORTS export const handleSendMessage = async ( config: any, context: { chatId: string; variables: Record<string, any> }, ) => { if (!config) throw new Error('Message configuration missing') const { chatId, variables } = context let { messageType, messageContent } = config // Process text variables if (messageType === 'TEXT' && typeof messageContent === 'string') { messageContent = resolveVariables(messageContent, variables) } // ++ ADDED: Presence Logic (Typing/Recording) // Generate a random duration between 1.5 and 3.5 seconds const presenceDuration = generateRandomDelay(1500, 3500) if (messageType === 'AUDIO') { // Show "Recording audio..." status await wa.chat.markIsRecording(chatId) } else { // Show "Typing..." status for Text, Image, Video, etc. await wa.chat.markIsComposing(chatId, presenceDuration) } // Wait for the presence duration to finish before sending await delay(presenceDuration) // ++ END ADDED if (messageType === 'TEXT') { await wa.send.text(chatId, messageContent) } else if (['IMAGE', 'VIDEO', 'AUDIO', 'FILE'].includes(messageType)) { const fileId = config.mediaId if (!fileId) throw new Error('Media ID is missing.') const mediaRecord = await db.media.get(fileId) if (!mediaRecord || !mediaRecord.file) throw new Error('Media file not found.') const caption = messageContent?.caption ? resolveVariables(messageContent.caption, variables) : '' const typeMap: Record<string, any> = { IMAGE: 'image', VIDEO: 'video', AUDIO: 'audio', FILE: 'document', } await wa.send.file(chatId, mediaRecord.file, { type: typeMap[messageType] || 'document', caption: caption, }) } else if (messageType === 'LOCATION') { await wa.send.location(chatId, messageContent) } else if (messageType === 'POLL') { await wa.send.poll(chatId, messageContent.name, messageContent.choices) } } \`\`\` # src/features/workflow/engine/WorkflowRunner.ts \`\`\`ts import CustomFieldModel from '@/features/contacts/models/CustomFieldModel' import db from '@/libs/db' import wa from '@/libs/wa' import { delay } from '@/utils/util' import dayjs from 'dayjs' import type { RunnerOptions, WorkflowContext, WorkflowStep } from '../types' // Handlers import * as chatHandlers from './handlers/chatHandlers' import * as crmHandlers from './handlers/crmHandlers' import * as messageHandlers from './handlers/messageHandlers' export class WorkflowRunner { private steps: WorkflowStep[] private context: WorkflowContext private options: RunnerOptions constructor(steps: WorkflowStep[], options: RunnerOptions = {}) { this.steps = steps this.options = options this.context = { logs: [], status: 'IDLE', triggerMessage: options.triggerMessage || '', variables: options.mockVariables || {}, } } async run(): Promise<void> { this.context.status = 'RUNNING' this.log('Workflow started.') if (this.options.isDryRun) { this.log('âš ï¸ Running in Dry Run mode (Database writes disabled)') } if (Object.keys(this.context.variables).length > 0) { this.log( `ðŸ’‰ Mock Data Injected: ${JSON.stringify(this.context.variables)}`, ) this.emitVariables() } try { await this.initializeContext() await this.processSequence(this.steps) this.context.status = 'COMPLETED' this.log('Workflow completed successfully.') } catch (error: any) { this.context.status = 'FAILED' this.log(`Workflow failed: ${error.message}`) console.error(error) throw error } } private async initializeContext() { let number = '' let name = 'Unknown' if (this.options.overrideChatId) { // Case A: Test Run number = this.options.overrideChatId.includes('@') ? this.options.overrideChatId.split('@')[0] : this.options.overrideChatId this.context.chatId = this.options.overrideChatId.includes('@') ? this.options.overrideChatId : `${number}@c.us` name = 'Test User' } else { // Case B: Live Run const activeChat = await wa.chat.getActiveChat() if (!activeChat || !activeChat.id) { throw new Error( 'No active chat found. Please open a chat conversation first.', ) } this.context.chatId = activeChat.id._serialized number = activeChat.id.user || '' name = activeChat.name || activeChat.formattedTitle || number } // Resolve Contact let contact = null if (number) { contact = await db.contacts.where({ number }).first() } if (!contact && !this.options.isDryRun && number) { try { const id = await db.contacts.add({ number, name: name }) contact = await db.contacts.get(id) } catch (e: any) { this.log(`Warning: Failed to auto-create contact: ${e.message}`) } } else if (!contact && this.options.isDryRun) { contact = { id: 0, number, name } this.log('Simulating contact creation (Dry Run)') } this.context.contactId = contact?.id this.log(`Context initialized for: ${name} (Number: ${number})`) } private async processSequence(steps: WorkflowStep[]): Promise<void> { if (!steps || steps.length === 0) return for (const step of steps) { this.context.currentStepId = step.id if (this.options.onStepStart) { this.options.onStepStart(step.id) } try { await this.processStep(step) } catch (error: any) { this.log(`Error in step "${step.label}": ${error.message}`) throw error } await delay(800) // Visual pacing } } private async processStep(step: WorkflowStep): Promise<void> { this.log(`Executing step: ${step.label} (${step.type})`) const { config } = step const chatId = this.context.chatId! const isDryRun = !!this.options.isDryRun const context = { chatId, variables: this.context.variables } switch (step.type) { case 'trigger': await delay(200) break // Communication case 'send-text': case 'send-image': case 'send-video': case 'send-audio': case 'send-document': case 'send-poll': case 'send-location': case 'send-message': await messageHandlers.handleSendMessage(config, context) break // CRM case 'tag': const isRemove = config.action === 'remove' if (isDryRun) { this.log( `(Dry Run) ${isRemove ? 'Remove' : 'Add'} Tag: ${config.tagName}`, ) } else { if (isRemove) { await crmHandlers.handleRemoveTag(config, { contactId: this.context.contactId, }) this.log(`Tag "${config.tagName}" removed.`) } else { await crmHandlers.handleAddTag(config, { contactId: this.context.contactId, }) this.log(`Tag "${config.tagName}" added.`) } } break case 'update-field': await crmHandlers.handleUpdateField( config, { contactId: this.context.contactId, variables: this.context.variables, triggerMessage: this.context.triggerMessage, }, async (fieldId, value) => { await this.updateVariable(fieldId, value) }, ) break // Chat case 'archive-chat': if (isDryRun) this.log('(Dry Run) Archive Chat') else { await chatHandlers.handleArchiveChat(chatId, config.action !== false) this.log( `Chat ${config.action !== false ? 'archived' : 'unarchived'}.`, ) } break case 'pin-chat': if (isDryRun) this.log('(Dry Run) Pin Chat') else { await chatHandlers.handlePinChat(chatId, config.action !== false) this.log(`Chat ${config.action !== false ? 'pinned' : 'unpinned'}.`) } break case 'mute-chat': if (isDryRun) this.log('(Dry Run) Mute Chat') else { await chatHandlers.handleMuteChat(chatId, config.action !== false) this.log(`Chat ${config.action !== false ? 'muted' : 'unmuted'}.`) } break default: this.log(`Unknown step type: ${step.type}`) } } private async updateVariable( fieldId: number, value: any, fieldName?: string, ) { let name = fieldName if (!name) { const field = await db.customFields.get(Number(fieldId)) name = field?.name || `field_${fieldId}` } if (name) { this.context.variables[name] = value this.emitVariables() } // Only update DB if fieldId is valid (non-zero) and it's not a dry run if (!this.options.isDryRun && this.context.contactId && fieldId > 0) { await CustomFieldModel.updateValue(this.context.contactId, fieldId, value) this.log(`Custom Field ID ${fieldId} updated to "${value}".`) } else if (fieldId > 0) { this.log(`(Dry Run) Database update skipped for field: ${name}`) } } private emitVariables() { if (this.options.onVariablesChange) { this.options.onVariablesChange({ ...this.context.variables }) } } private log(message: string) { console.log(`[WorkflowRunner] ${message}`) const logMsg = `${dayjs().format('HH:mm:ss')}: ${message}` this.context.logs.push(logMsg) if (this.options.onLog) { this.options.onLog(logMsg) } } } \`\`\` # src/features/workflow/PageWorkflow.tsx \`\`\`tsx import AlertBanner from '@/components/AlertBanner' import LayoutPage from '@/components/Layout/LayoutPage' import ModalPricing from '@/components/Modal/ModalPricing' import useDbQuery from '@/hooks/useDbQuery' import useLicense from '@/hooks/useLicense' import db, { type Workflow } from '@/libs/db' import confirm from '@/utils/confirm' import toast from '@/utils/toast' import { Icon } from '@iconify/react' import { ActionIcon, Button, Group, Stack, Switch, Text, TextInput, Tooltip, } from '@mantine/core' import { useDisclosure } from '@mantine/hooks' import { DataTable } from 'mantine-datatable' import React, { useState } from 'react' import ModalWorkflowEditor from './components/ModalWorkflowEditor' const FREE_WORKFLOW_LIMIT = 2 const PageWorkflow: React.FC = () => { const license = useLicense() const dataQuery = useDbQuery<Workflow>({ table: db.workflows, searchField: 'name', initialSort: { field: 'updatedAt', direction: 'desc' }, }) const [showEditor, editorHandlers] = useDisclosure(false) const [editingWorkflow, setEditingWorkflow] = useState<Workflow | null>(null) const handleCreate = () => { if (license.isFree() && dataQuery.totalRecords >= FREE_WORKFLOW_LIMIT) { toast.warning( `Free plan is limited to ${FREE_WORKFLOW_LIMIT} workflow. Upgrade for unlimited workflows.`, ) return } setEditingWorkflow(null) editorHandlers.open() } const handleEdit = (workflow: Workflow) => { setEditingWorkflow(workflow) editorHandlers.open() } const handleSave = async (data: any) => { try { if (editingWorkflow) { await db.workflows.update(editingWorkflow.id, { ...data, updatedAt: new Date(), }) toast.success('Workflow updated') } else { await db.workflows.add({ ...data, createdAt: new Date(), updatedAt: new Date(), }) toast.success('Workflow created') } } catch (error) { console.error(error) toast.error('Failed to save workflow') } } const handleDelete = async (workflow: Workflow) => { if ( await confirm.danger( 'Delete Workflow', 'Are you sure you want to delete this workflow?', ) ) { await db.workflows.delete(workflow.id) } } const handleToggleEnabled = async (workflow: Workflow) => { const newEnabled = !workflow.enabled await db.workflows.update(workflow.id, { enabled: newEnabled }) toast.success(`Workflow ${newEnabled ? 'enabled' : 'disabled'}`) } return ( <> <LayoutPage title="Workflow" width={850} p={0} icon={<Icon icon="tabler:robot" fontSize={24} color="#34d399" />} description="Automate tasks with a step-by-step linear editor." > <AlertBanner message="Limited to 2 workflows in the free version. Go unlimited" /> <Stack h="100%" px="md"> <Group justify="space-between"> <TextInput placeholder="Search workflows..." leftSection={<Icon icon="tabler:search" fontSize={16} />} value={dataQuery.search} onChange={(e) => dataQuery.setSearch(e.currentTarget.value)} size="sm" /> <Button leftSection={<Icon icon="tabler:plus" fontSize={18} />} onClick={handleCreate} color="emerald" > Create Workflow </Button> </Group> <DataTable withTableBorder borderRadius="sm" shadow="xs" striped highlightOnHover records={dataQuery.data} totalRecords={dataQuery.totalRecords} recordsPerPage={dataQuery.pageSize} page={dataQuery.page} onPageChange={dataQuery.setPage} minHeight={300} noRecordsText="No workflows found." columns={[ { accessor: 'name', title: 'Name', render: (r) => <Text fw={500}>{r.name}</Text>, }, { accessor: 'steps', title: 'Steps', render: (r) => ( <Text size="sm">{r.steps?.length || 0} steps</Text> ), }, { accessor: 'enabled', title: 'Status', width: 80, render: (r) => ( <Switch size="sm" color="emerald" checked={r.enabled !== false} onChange={() => handleToggleEnabled(r)} /> ), }, { accessor: 'actions', textAlign: 'right', width: 100, render: (r) => ( <Group gap={4} justify="flex-end" wrap="nowrap"> <Tooltip label="Edit"> <ActionIcon color="blue" variant="subtle" onClick={() => handleEdit(r)} > <Icon icon="tabler:edit" /> </ActionIcon> </Tooltip> <Tooltip label="Delete"> <ActionIcon color="red" variant="subtle" onClick={() => handleDelete(r)} > <Icon icon="tabler:trash" /> </ActionIcon> </Tooltip> </Group> ), }, ]} /> </Stack> </LayoutPage> <ModalWorkflowEditor opened={showEditor} onClose={editorHandlers.close} onSave={handleSave} initialData={editingWorkflow} /> </> ) } export default PageWorkflow \`\`\` # src/features/workflow/types.ts \`\`\`ts export type StepType = | 'trigger' | 'send-text' | 'send-image' | 'send-video' | 'send-audio' | 'send-document' | 'send-poll' | 'send-location' | 'send-message' | 'tag' | 'update-field' | 'archive-chat' | 'pin-chat' | 'mute-chat' export interface WorkflowStep { id: string type: StepType label: string config: any } export interface WorkflowContext { logs: string[] status: 'IDLE' | 'RUNNING' | 'COMPLETED' | 'FAILED' currentStepId?: string | null triggerMessage?: string contactId?: number chatId?: string variables: Record<string, any> } export interface RunnerOptions { triggerMessage?: string overrideChatId?: string onStepStart?: (stepId: string) => void onLog?: (message: string) => void onVariablesChange?: (variables: Record<string, any>) => void skipDelays?: boolean isDryRun?: boolean mockVariables?: Record<string, any> } \`\`\` # src/features/workflow/utils/flatten.ts \`\`\`ts import type { WorkflowStep } from '../types' /** * Flattens the workflow into a single array of steps. * (Simplified after removing branching logic) */ export const flattenSteps = (steps: WorkflowStep[]): WorkflowStep[] => { return [...steps] } \`\`\` # src/features/workflow/utils/search.ts \`\`\`ts import type { WorkflowStep } from '../types' /** * Find the path string for a step by its ID. * Example return: "steps.2" * (Simplified after removing branching logic) */ export const findStepPath = ( steps: WorkflowStep[], targetId: string | null, basePath: string = 'steps', ): string | null => { if (!targetId) return null for (let i = 0; i < steps.length; i++) { const step = steps[i] if (step.id === targetId) { return `${basePath}.${i}` } } return null } \`\`\` # src/features/workflow/utils/stepUtils.ts \`\`\`ts import type { StepType } from '../types' export const getStepIcon = (type: StepType): string => { switch (type) { case 'trigger': return 'tabler:bolt' case 'send-text': return 'tabler:message-circle' case 'send-image': return 'tabler:photo' case 'send-video': return 'tabler:video' case 'send-audio': return 'tabler:microphone' case 'send-document': return 'tabler:file' case 'send-poll': return 'tabler:chart-bar' case 'send-location': return 'tabler:map-pin' case 'send-message': return 'tabler:message-plus' case 'tag': return 'tabler:tag' case 'update-field': return 'tabler:database-edit' case 'archive-chat': return 'tabler:archive' case 'pin-chat': return 'tabler:pin' case 'mute-chat': return 'tabler:volume-off' default: return 'tabler:circle' } } export const getStepColor = (type: StepType): string => { switch (type) { case 'trigger': return 'yellow' case 'send-text': case 'send-image': case 'send-video': case 'send-audio': case 'send-document': case 'send-poll': case 'send-location': case 'send-message': case 'tag': case 'update-field': return 'emerald' case 'archive-chat': case 'pin-chat': case 'mute-chat': return 'orange' default: return 'gray' } } \`\`\` # src/features/workflow/utils/validation.ts \`\`\`ts import type { WorkflowStep } from '../types' export const validateStepConfig = (step: WorkflowStep): boolean => { const { config, type } = step if (!config) return false switch (type) { case 'trigger': if ( config.triggerType !== 'any' && config.triggerType !== 'manual' && !config.keyword ) return false break case 'send-text': if (!config.messageContent) return false break case 'send-image': case 'send-video': case 'send-audio': case 'send-document': if (!config.mediaId) return false break case 'send-poll': if ( !config.messageContent?.name || config.messageContent?.choices?.length < 2 ) return false break case 'send-location': if (!config.messageContent?.lat || !config.messageContent?.lng) return false break case 'send-message': if ( !config.messageContent && !config.mediaId && config.messageType === 'TEXT' ) return false break case 'tag': if (!config.tagName) return false break case 'update-field': if (!config.customFieldId) return false break case 'archive-chat': case 'pin-chat': case 'mute-chat': return true } return true } \`\`\` # src/features/workflow/utils/variableUtils.ts \`\`\`ts import dayjs from 'dayjs' import type { WorkflowStep } from '../types' import { flattenSteps } from './flatten' export const resolveVariables = ( text: string, variables: Record<string, any>, ): string => { if (!text) return '' let processed = text const now = dayjs() // 1. Built-in Variables const builtIns: Record<string, string> = { '{date}': now.format('DD MMMM YYYY'), '{time}': now.format('HH:mm'), } for (const [key, value] of Object.entries(builtIns)) { processed = processed.split(key).join(value) } // 2. Custom/Context Variables for (const [key, value] of Object.entries(variables)) { // Regex for exact match {key} to avoid partial replacements if needed, // but simple split/join is faster for now. processed = processed.split(`{${key}}`).join(String(value)) } return processed } // ++ ADDED: Helper to extract variables defined in steps export interface WorkflowVariable { name: string source: string type: string } export const getWorkflowVariables = ( steps: WorkflowStep[], ): WorkflowVariable[] => { const flatSteps = flattenSteps(steps) const variables: WorkflowVariable[] = [] // 1. Built-in variables.push( { name: 'date', source: 'System', type: 'Built-in' }, { name: 'time', source: 'System', type: 'Built-in' }, { name: 'sender_name', source: 'Trigger', type: 'Context' }, { name: 'sender_number', source: 'Trigger', type: 'Context' }, ) flatSteps.forEach((step) => { // Manual Trigger Inputs if (step.type === 'trigger' && step.config?.triggerType === 'manual') { const inputs = step.config.inputs || [] inputs.forEach((input: any) => { if (input.key) { variables.push({ name: input.key, source: 'Manual Trigger', type: input.type || 'text', }) } }) } }) return variables } \`\`\` # src/hooks/useDbQuery.ts \`\`\`ts import confirm from '@/utils/confirm' import type { EntityTable } from 'dexie' import { useLiveQuery } from 'dexie-react-hooks' import { useMemo, useState } from 'react' type SortDirection = 'asc' | 'desc' interface Sort { field: string direction: SortDirection } type SortState = Sort | null type FilterOperator = | 'equals' | 'contains' | 'startsWith' | 'endsWith' | 'greaterThan' | 'lessThan' | 'between' | 'anyOf' | 'in' // ++ ADDED: 'in' operator support export interface Filter { field: string operator: FilterOperator value: any secondValue?: any } interface useDataQueryOptions<T> { //@ts-ignore table: EntityTable<T, 'id'> initialPageSize?: number searchField?: string initialSort?: Sort initialFilters?: Filter[] } export const useDbQuery = <T>(options: useDataQueryOptions<T>) => { const { table, initialPageSize = 10, searchField = 'name', initialSort = { field: 'id', direction: 'desc' }, initialFilters = [], } = options const [page, setPage] = useState(1) const [pageSize, setPageSize] = useState(initialPageSize) const [search, setSearch] = useState('') const [selectedRecords, setSelectedRecords] = useState<T[]>([]) const [sort, setSort] = useState<SortState>(initialSort) const [filters, setFilters] = useState<Filter[]>(initialFilters) const applyFilter = (query: any, filter: Filter) => { const { field, operator, value, secondValue } = filter switch (operator) { case 'equals': return query.filter((item: any) => item[field] === value) case 'contains': return query.filter((item: any) => String(item[field]) .toLowerCase() .includes(String(value).toLowerCase()), ) case 'startsWith': return query.filter((item: any) => String(item[field]) .toLowerCase() .startsWith(String(value).toLowerCase()), ) case 'endsWith': return query.filter((item: any) => String(item[field]) .toLowerCase() .endsWith(String(value).toLowerCase()), ) case 'greaterThan': return query.filter((item: any) => item[field] > value) case 'lessThan': return query.filter((item: any) => item[field] < value) case 'between': return query.filter( (item: any) => item[field] >= value && item[field] <= (secondValue ?? value), ) case 'anyOf': if (!Array.isArray(value) || value.length === 0) { return query } // Checks if item[field] is an array and shares any elements with value return query.filter( (item: any) => Array.isArray(item[field]) && item[field].some((tag: any) => value.includes(tag)), ) // ++ ADDED: 'in' operator logic case 'in': if (!Array.isArray(value) || value.length === 0) { return query } // Checks if item[field] exists in the value array return query.filter((item: any) => value.includes(item[field])) default: return query } } const data = useLiveQuery(async () => { if (pageSize <= 0) return { data: [], totalItems: 0, hasMore: false } const startIndex = (page - 1) * pageSize let query = search ? table.where(searchField).startsWithIgnoreCase(search) : table.toCollection() let results = await query.toArray() filters.forEach((filter) => { results = applyFilter(results, filter) }) if (sort) { results.sort((a: any, b: any) => { const aValue = a[sort.field] const bValue = b[sort.field] if (aValue === bValue) return 0 const comparison = aValue > bValue ? 1 : -1 return sort.direction === 'asc' ? comparison : -comparison }) } const paginatedResults = results.slice(startIndex, startIndex + pageSize) return { data: paginatedResults, totalItems: results.length, hasMore: startIndex + paginatedResults.length < results.length, } }, [page, pageSize, search, sort, filters]) const _delete = async (id: any) => { const isConfirmed = await confirm.danger( 'Are you sure?', 'This item will be deleted permanently.', ) if (isConfirmed) { await table.delete(id) } } const toggleSort = (field: string) => { setSort((currentSort) => { if (!currentSort || currentSort.field !== field) { return { field, direction: 'asc' } } if (currentSort.direction === 'asc') { return { field, direction: 'desc' } } // Allow clearing sort or default to desc? Let's cycle: asc -> desc -> null if (currentSort.direction === 'desc') { return null } return currentSort }) } const derivedData = useMemo( () => ({ data: data?.data ?? [], totalRecords: data?.totalItems ?? 0, hasMore: data?.hasMore ?? false, }), [data], ) return { ...derivedData, selectedRecords, page, pageSize, search, sort, filters, setPage, setPageSize, setSelectedRecords, setSearch, toggleSort, setFilters, _delete, searchField, } } export default useDbQuery \`\`\` # src/hooks/useFile.ts \`\`\`ts // src/hooks/useFile.ts import toast from '@/utils/toast' import FileSaver from 'file-saver' import * as XLSX from 'xlsx' /** * @hook useFile * @description A hook to provide utility functions for exporting data to files (CSV, XLSX). */ const useFile = () => { /** * @description Converts an array of objects to a specified file format and triggers a download. * @param format The desired file format ('csv' or 'xlsx'). * @param data The array of data to export. * @param filename The base name for the downloaded file (without extension). */ const saveAs = async ( format: 'csv' | 'xlsx' | string, data: any[], filename: string, ) => { if (!data || data.length === 0) { toast.info('No data available to export.') return } try { const worksheet = XLSX.utils.json_to_sheet(data) const workbook = XLSX.utils.book_new() XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet1') let fileBuffer: any let mimeType: string let fileExtension: string switch (format) { case 'xlsx': fileExtension = 'xlsx' mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8' fileBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' }) break case 'csv': default: fileExtension = 'csv' mimeType = 'text/csv;charset=utf-8;' fileBuffer = XLSX.write(workbook, { bookType: 'csv', type: 'array' }) break } const blob = new Blob([fileBuffer], { type: mimeType }) FileSaver.saveAs(blob, `${filename}.${fileExtension}`) toast.success('File exported successfully.') } catch (error) { console.error('File export error:', error) toast.error('An error occurred during the file export.') } } return { saveAs, } } export default useFile \`\`\` # src/hooks/useLicense.ts \`\`\`ts // src/hooks/useLicense.ts import { Setting } from '@/constants' import { storage } from '@/libs/storage' import { useAppStore } from '@/stores/app' import type { License } from '@/types' import toast from '@/utils/toast' import { getStoreId } from '@/utils/util' import { sendToBackground } from '@plasmohq/messaging' import { addDays, isPast } from 'date-fns' interface CachedLicense { data: License timestamp: number } const useLicense = () => { const { license, setLicense } = useAppStore() const callLemonSqueezyApi = async (action: string, body: any) => { return await sendToBackground({ name: 'ls', body: { action, body }, }) } const init = async () => { // First, check for a cached, valid license to avoid unnecessary API calls. const cachedLicense = await storage.get<CachedLicense | null>( Setting.LICENSE_DATA_CACHE, ) if (cachedLicense) { const cacheDurationInDays = 2 const expirationTime = addDays( cachedLicense.timestamp, cacheDurationInDays, ) const isCacheValid = !isPast(expirationTime) if (isCacheValid && cachedLicense.data.license_key.status === 'active') { setLicense(cachedLicense.data) return } } // If no valid cache, proceed with the standard validation flow. const licenseKey = await storage.get<string | null>(Setting.LICENSE_KEY) if (!licenseKey) { setLicense(null) await storage.remove(Setting.LICENSE_DATA_CACHE) return } const response = await callLemonSqueezyApi('validateLicense', { licenseKey, }) if (response.error) { // Validation failed, clear all license-related storage. await storage.remove(Setting.LICENSE_KEY) await storage.remove(Setting.LICENSE_INSTANCE_ID) await storage.remove(Setting.LICENSE_DATA_CACHE) setLicense(null) toast.error( 'Your license key is invalid or has been deactivated. You have been switched to the Free plan.', 'License Invalid', ) return } if (response.data.meta.store_id.toString() !== getStoreId()) { await storage.remove(Setting.LICENSE_KEY) await storage.remove(Setting.LICENSE_INSTANCE_ID) await storage.remove(Setting.LICENSE_DATA_CACHE) setLicense(null) toast.error( 'Your license key is for a different product. You have been switched to the Free plan.', 'License Error', ) return } // Validation successful, update app state and cache the license data if active. setLicense(response.data) if (response.data.license_key.status === 'active') { const cachePayload: CachedLicense = { data: response.data, timestamp: Date.now(), } await storage.set(Setting.LICENSE_DATA_CACHE, cachePayload) } if ( response.data.license_key.expires_at && isPast(new Date(response.data.license_key.expires_at)) ) { toast.info( 'Your license has expired. You have been switched to the Free plan.', 'License Expired', ) await storage.remove(Setting.LICENSE_DATA_CACHE) } } const isFree = (): boolean => { if (!license) { return true } return license.license_key.status !== 'active' } const isPro = () => { if (!license) { return false } return license.license_key.status === 'active' } const isExpired = () => { // For lifetime licenses, 'expires_at' might be null. // The most reliable check is the status. If no expiration date exists, it's not expired. if (!license || !license.license_key.expires_at) { return false } return isPast(new Date(license.license_key.expires_at)) } const getLicense = () => { return license } const activate = async (licenseKey: string) => { const response = await callLemonSqueezyApi('activateLicense', { licenseKey, }) if (!response.error) { setLicense(response.data) await storage.set(Setting.LICENSE_KEY, licenseKey) await storage.set(Setting.LICENSE_INSTANCE_ID, response.data.instance.id) // Cache the license data immediately on successful activation. if (response.data.license_key.status === 'active') { const cachePayload: CachedLicense = { data: response.data, timestamp: Date.now(), } await storage.set(Setting.LICENSE_DATA_CACHE, cachePayload) } } return response } const deactivate = async () => { const licenseKey = await storage.get(Setting.LICENSE_KEY) const instanceId = await storage.get(Setting.LICENSE_INSTANCE_ID) try { const response = await callLemonSqueezyApi('deactivateLicense', { licenseKey, instanceId, }) if (response.data.deactivated) { // Clear all license-related data from storage on deactivation. await storage.remove(Setting.LICENSE_KEY) await storage.remove(Setting.LICENSE_INSTANCE_ID) await storage.remove(Setting.LICENSE_DATA_CACHE) setLicense(null) toast.success('Your license has been deactivated from this device.') } else { toast.error('Failed to deactivate the license. Please contact support.') } } catch (e) { toast.error('An error occurred during deactivation.') } } const goToMyOrders = async () => { if (!license?.meta?.customer_id) { toast.error('Could not find customer information.') return } try { const response = await callLemonSqueezyApi('getCustomer', { customerId: license.meta.customer_id, }) if (response.error) { toast.error('Could not retrieve customer portal link.') return } window.open( response.data.data.attributes.urls.customer_portal, '_blank', 'noopener,noreferrer', ) } catch (e) { toast.error('An error occurred while fetching your subscription details.') } } return { init, isFree, isPro, isExpired, activate, getLicense, goToMyOrders, deactivate, } } export default useLicense \`\`\` # src/hooks/useRuntimeMessage.ts \`\`\`ts import { useCallback, useEffect } from 'react' type MessageListener<T = any> = ( message: T, sender: chrome.runtime.MessageSender, sendResponse: (response?: any) => void, ) => void | boolean /** * A React hook for handling Chrome runtime messages * @param listener The callback function to handle incoming messages * @returns void * * @example * useRuntimeMessage((message, sender, sendResponse) => { * if (message.type === 'getData') { * sendResponse({ data: 'example' }) * } * // Return true to keep the message channel open for async responses * return true * }) */ const useRuntimeMessage = <T = any>(listener: MessageListener<T>): void => { const memoizedHandler = useCallback<MessageListener<T>>( (message, sender, sendResponse) => { return listener(message, sender, sendResponse) }, [listener], ) useEffect(() => { chrome.runtime.onMessage.addListener(memoizedHandler) return () => { chrome.runtime.onMessage.removeListener(memoizedHandler) } }, [memoizedHandler]) } export default useRuntimeMessage \`\`\` # src/hooks/useWa.ts \`\`\`ts import wa from '@/libs/wa' import { useAppStore } from '@/stores/app' const useWa = () => { const { isReady, activeChat, setActiveChat } = useAppStore() return { isReady, activeChat, setActiveChat, ...wa, } } export default useWa \`\`\` # src/hooks/useWindowMessage.ts \`\`\`ts import { useCallback, useEffect } from 'react' type MessageListener<T = any> = (event: MessageEvent<T>) => void const useWindowMessage = <T = any>(listener: MessageListener<T>): void => { const handleMessage = useCallback<MessageListener<T>>( (event) => { listener(event) }, [listener], ) useEffect(() => { window.addEventListener('message', handleMessage) return () => window.removeEventListener('message', handleMessage) }, [handleMessage]) } export default useWindowMessage \`\`\` # src/libs/db.ts \`\`\`ts import Dexie, { type EntityTable } from 'dexie' import packageJson from '../../package.json' export interface Media { id: number parentId: number type: string name: string file: File ext: string } export interface Broadcast { id: number name?: string | null type: string message: any isTyping: number isScheduler: number status: string delayMin: number delayMax: number batchSize?: number batchDelay?: number validateNumber?: number actions?: BroadcastAction[] } export interface BroadcastContact { id: number broadcastId: number number: string name?: string | null status: string error?: string | null scheduledAt?: Date | null sendAt?: Date | null } export interface BroadcastTemplate { id: number name: string type: string message: any } export interface BroadcastRecipient { id: number name: string recipients: { name: string; number: string; source: string }[] createdAt: Date } export interface BroadcastAction { id: string trigger: 'SUCCESS' | 'FAILED' | 'COMPLETE' type: | 'ADD_TAG' | 'REMOVE_TAG' | 'ARCHIVE_CHAT' | 'UPDATE_FIELD' | 'INCREMENT_FIELD' | 'CLEAR_CHAT' | 'DELETE_CHAT' | 'PIN_CHAT' | 'UNPIN_CHAT' | 'SELF_MESSAGE' | 'ADD_NOTE' | 'DELAY' | 'EXPORT_REPORT' | 'MUTE_CHAT' | 'BLOCK_CONTACT' | 'SEND_STATS_SELF' | 'SEND_REPORT_GROUP' payload?: | string | UpdateFieldPayload | SelfMessagePayload | NotePayload | DelayPayload | ExportReportPayload | GroupReportPayload | SendStatsSelfPayload | IncrementFieldPayload } export interface UpdateFieldPayload { customFieldId: number value: string } export interface IncrementFieldPayload { customFieldId: number incrementBy: number } export interface SelfMessagePayload { message: string delaySeconds?: number } export interface NotePayload { content: string } export interface DelayPayload { seconds: number } export interface ExportReportPayload { format: 'csv' | 'xlsx' } export interface GroupReportPayload { groupId: string delaySeconds?: number } export interface SendStatsSelfPayload { delaySeconds?: number } export interface QuickReply { id: number name: string type: string message: any pinned?: number } export interface Contact { id: number number?: string | null name?: string | null } export interface Tag { id: number name: string color: string } export interface ContactTag { id: number contactId: number tagId: number } export interface CustomField { id: number name: string type: string config?: any } export interface ContactCustomField { id: number contactId: number customFieldId: number value?: string | boolean | Date | number | Blob | File | null } export interface ContactNote { id: number contactId: number content: string createdAt: Date } export interface UserStatus { id: number name?: string type: string message: any createdAt: Date status: string backgroundColor?: string font?: number isScheduled?: number scheduledAt?: Date | null postedAt?: Date | null } export interface ScheduledMessage { id: number chatId: string type: string message: any scheduledAt: Date status: string // PENDING, SUCCESS, FAILED error?: string createdAt: Date } export interface WorkflowStep { id: string type: | 'trigger' | 'send-text' | 'send-image' | 'send-video' | 'send-audio' | 'send-document' | 'send-poll' | 'send-location' | 'send-message' | 'tag' | 'update-field' | 'archive-chat' | 'pin-chat' | 'mute-chat' label: string config: any } export interface Workflow { id: number name: string description?: string enabled?: boolean steps: WorkflowStep[] createdAt: Date updatedAt: Date } // ++ ADDED: Smart Segment Interfaces export interface SegmentRule { field: 'tag' | 'name' | 'number' | string // string for custom fields (e.g. 'cf_1') operator: | 'equals' | 'contains' | 'startsWith' | 'greaterThan' | 'lessThan' | 'isEmpty' | 'isNotEmpty' value: any } export interface SmartSegment { id: number name: string logic: 'AND' | 'OR' // Match ALL rules or ANY rule rules: SegmentRule[] pinned?: number // 1 = pinned, 0 or undefined = not pinned createdAt: Date } const db = new Dexie(packageJson.name) as Dexie & { media: EntityTable<Media, 'id'> broadcasts: EntityTable<Broadcast, 'id'> broadcastContacts: EntityTable<BroadcastContact, 'id'> broadcastTemplates: EntityTable<BroadcastTemplate, 'id'> broadcastRecipients: EntityTable<BroadcastRecipient, 'id'> quickReplies: EntityTable<QuickReply, 'id'> contacts: EntityTable<Contact, 'id'> userStatuses: EntityTable<UserStatus, 'id'> customFields: EntityTable<CustomField, 'id'> contactCustomFields: EntityTable<ContactCustomField, 'id'> contactNotes: EntityTable<ContactNote, 'id'> tags: EntityTable<Tag, 'id'> contactTags: EntityTable<ContactTag, 'id'> scheduledMessages: EntityTable<ScheduledMessage, 'id'> workflows: EntityTable<Workflow, 'id'> smartSegments: EntityTable<SmartSegment, 'id'> } db.version(1).stores({ media: '++id, parentId, type, name, file, ext', broadcasts: '++id, name, type, isTyping, isScheduler, status, delayMin, delayMax, batchSize, batchDelay, validateNumber, contentHash', broadcastContacts: '++id, broadcastId, number, name, status, error, scheduledAt, sendAt', broadcastTemplates: '++id, name, type, message', broadcastRecipients: '++id, name, createdAt', quickReplies: '++id, name, type, message, pinned', contacts: '++id, &number, name', userStatuses: '++id, name, type, createdAt, status, backgroundColor, font, isScheduled, scheduledAt, postedAt', customFields: '++id, name, type', contactCustomFields: '++id, &[contactId+customFieldId], customFieldId, value', contactNotes: '++id, contactId, createdAt', tags: '++id, &name', contactTags: '++id, contactId, tagId, [contactId+tagId]', scheduledMessages: '++id, chatId, status, scheduledAt', workflows: '++id, name, enabled, createdAt', // ++ ADDED: New Store Definition smartSegments: '++id, name, createdAt', }) export default db \`\`\` # src/libs/dom/assets.ts \`\`\`ts import { sendToBackground } from '@plasmohq/messaging' import { findAllElements } from './element' export interface SaveAssetsOptions { /** Selector for the element(s) to extract assets from */ selector?: string /** Type of asset source */ type?: 'element' | 'url' /** Direct URL (if type is 'url') */ url?: string /** Optional filename to save as */ filename?: string /** Action on filename conflict */ conflictAction?: 'uniquify' | 'overwrite' | 'prompt' } /** * Extracts the source URL from a DOM element based on its tag. */ const getElementSource = (element: Element): string | null => { if (!element) return null const tagName = element.tagName.toUpperCase() if (tagName === 'IMG') { return (element as HTMLImageElement).src } if (tagName === 'A') { return (element as HTMLAnchorElement).href } if (tagName === 'AUDIO' || tagName === 'VIDEO') { const mediaEl = element as HTMLMediaElement if (mediaEl.src) return mediaEl.src // Check for <source> children const sourceEl = element.querySelector('source') if (sourceEl && sourceEl.src) return sourceEl.src } if (tagName === 'SOURCE') { return (element as HTMLSourceElement).src } // Fallback: check for common source attributes return element.getAttribute('src') || element.getAttribute('href') } /** * Extracts assets from the DOM or processes a direct URL, then requests a download. */ export const saveAssets = async ( options: SaveAssetsOptions, ): Promise<number[]> => { const { selector, type = 'element', url, filename, conflictAction = 'uniquify', } = options let urlsToDownload: string[] = [] if (type === 'url' && url) { urlsToDownload = [url] } else if (type === 'element' && selector) { const elements = findAllElements({ selector }) urlsToDownload = elements .map((el) => getElementSource(el)) .filter((src): src is string => !!src && src.trim() !== '') // Filter unique URLs to avoid downloading the same image multiple times urlsToDownload = [...new Set(urlsToDownload)] } if (urlsToDownload.length === 0) { console.warn('No assets found to save') return [] } const response = await sendToBackground({ //@ts-ignore name: 'downloads', body: { urls: urlsToDownload, filename, conflictAction, }, }) if (response.error) { throw new Error(response.error) } return response.downloadIds || [] } \`\`\` # src/libs/dom/custom.ts \`\`\`ts // src/libs/dom/custom.ts import { waitForElement } from './element' import { triggerEvent, type EventOptions } from './events' export interface DispatchOptions { selector: string eventType: string options?: EventOptions timeout?: number } /** * Dispatches a custom or specific DOM event on a target element. * Useful for triggering 'change', 'blur', 'focus' manually or custom events. */ export const dispatchEvent = async (config: DispatchOptions): Promise<void> => { const { selector, eventType, options = {}, timeout = 5000 } = config const element = await waitForElement(selector, timeout) if (!element) { throw new Error(`Element not found for event dispatch: ${selector}`) } triggerEvent(element, eventType, options) } \`\`\` # src/libs/dom/dialog.ts \`\`\`ts export interface DialogOptions { /** Whether to accept (true) or dismiss (false) the dialog */ accept?: boolean /** Text to enter into a prompt dialog */ promptText?: string } /** * Injects a script into the page to override native dialog functions. * This handles window.alert, window.confirm, window.prompt, and onbeforeunload. */ export const handleDialog = (options: DialogOptions = {}): void => { const { accept = true, promptText = '' } = options // Logic to override native browser dialogs // We use a self-executing function to avoid polluting the global scope more than necessary const code = ` (() => { // Override confirm: returns true/false based on 'accept' window.confirm = function() { return ${accept}; }; // Override alert: returns true/false (effectively silences it) window.alert = function() { return ${accept}; }; // Override prompt: returns text if accepted, null if dismissed window.prompt = function() { return ${accept} ? "${promptText.replace(/"/g, '\\"')}" : null; }; // Prevent "Leave site?" popups window.onbeforeunload = null; })(); ` try { const script = document.createElement('script') script.textContent = code ;(document.head || document.documentElement).appendChild(script) script.remove() } catch (error) { console.error('Failed to inject dialog handler:', error) } } \`\`\` # src/libs/dom/element.ts \`\`\`ts import { isXPath, sleep } from './utils' export interface FindOptions { selector: string root?: Document | Element } /** * Finds an element in the DOM using CSS selectors or XPath. * Supports iframe traversal syntax (e.g., "iframe-id |> #element-id"). */ export const findElement = ({ selector, root = document, }: FindOptions): Element | null => { const selectors = selector.split('|>').map((s) => s.trim()) let currentRoot: Document | Element = root for (let i = 0; i < selectors.length; i++) { const currentSelector = selectors[i] const isLast = i === selectors.length - 1 let element: Element | null = null if (isXPath(currentSelector)) { const xpath = currentSelector.replace(/^xpath:/, '') const contextNode = currentRoot instanceof Document ? currentRoot.documentElement : currentRoot try { const result = document.evaluate( xpath, contextNode, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null, ) element = result.singleNodeValue as Element } catch (e) { console.error(`Invalid XPath: ${xpath}`, e) return null } } else { element = currentRoot.querySelector(currentSelector) } if (!element) return null if (!isLast) { if (element instanceof HTMLIFrameElement && element.contentDocument) { currentRoot = element.contentDocument.body || element.contentDocument } else { return null } } else { return element } } return null } /** * Finds all elements in the DOM matching the selector. * Supports iframe traversal syntax. Returns an array of elements. */ export const findAllElements = ({ selector, root = document, }: FindOptions): Element[] => { const selectors = selector.split('|>').map((s) => s.trim()) let currentRoot: Document | Element = root for (let i = 0; i < selectors.length; i++) { const currentSelector = selectors[i] const isLast = i === selectors.length - 1 if (isLast) { if (isXPath(currentSelector)) { const xpath = currentSelector.replace(/^xpath:/, '') const contextNode = currentRoot instanceof Document ? currentRoot.documentElement : currentRoot try { const result = document.evaluate( xpath, contextNode, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null, ) const elements: Element[] = [] let node = result.iterateNext() while (node) { if (node instanceof Element) elements.push(node) node = result.iterateNext() } return elements } catch (e) { console.error(`Invalid XPath: ${xpath}`, e) return [] } } else { return Array.from(currentRoot.querySelectorAll(currentSelector)) } } else { // Traverse into iframe (same logic as findElement) let element: Element | null = null if (isXPath(currentSelector)) { const xpath = currentSelector.replace(/^xpath:/, '') const contextNode = currentRoot instanceof Document ? currentRoot.documentElement : currentRoot try { const result = document.evaluate( xpath, contextNode, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null, ) element = result.singleNodeValue as Element } catch (e) { return [] } } else { element = currentRoot.querySelector(currentSelector) } if ( element && element instanceof HTMLIFrameElement && element.contentDocument ) { currentRoot = element.contentDocument.body || element.contentDocument } else { return [] } } } return [] } /** * Waits for an element to appear in the DOM. */ export const waitForElement = async ( selector: string, timeout: number = 5000, ): Promise<Element | null> => { const element = findElement({ selector }) if (element) return element const startTime = Date.now() const interval = 200 while (Date.now() - startTime < timeout) { await sleep(interval) const el = findElement({ selector }) if (el) return el } return null } /** * Checks if an element is physically visible in the viewport. * Migrated from src/utils/helper.js -> visibleInViewport */ export const isInViewport = (element: Element): boolean => { const { top, left, bottom, right, height, width } = element.getBoundingClientRect() // Element is considered hidden if it has no dimensions if (height === 0 || width === 0) return false return ( top >= 0 && left >= 0 && bottom <= (window.innerHeight || document.documentElement.clientHeight) && right <= (window.innerWidth || document.documentElement.clientWidth) ) } /** * Checks if an element is visible in the DOM (CSS check). * Migrated from src/content/blocksHandler/handlerConditions.js -> visible logic */ export const isVisible = (element: Element): boolean => { if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) { return false } // Check if element has dimensions const rect = element.getBoundingClientRect() if (rect.width === 0 || rect.height === 0) return false // Check CSS styles const style = window.getComputedStyle(element) const isHidden = style.display === 'none' || style.visibility === 'hidden' || parseFloat(style.opacity) === 0 return !isHidden } export interface CheckOptions extends FindOptions { /** 'exists' | 'notExists' | 'visible' | 'invisible' | 'visibleScreen' */ condition: string } /** * Validates a condition for a selector. * Combined logic from handlerConditions.js */ export const checkCondition = (options: CheckOptions): boolean => { const { selector, condition, root } = options const element = findElement({ selector, root }) switch (condition) { case 'exists': return !!element case 'notExists': return !element case 'visible': return element ? isVisible(element) : false case 'invisible': // Invisible means: element doesn't exist OR exists but hidden via CSS return !element || !isVisible(element) case 'visibleScreen': // Strictly checks if inside viewport return element ? isInViewport(element) : false default: console.warn(`Unknown condition: ${condition}`) return false } } \`\`\` # src/libs/dom/events.ts \`\`\`ts // src/libs/dom/events.ts /** * Comprehensive options for various event types. * Covers Mouse, Keyboard, Touch, Input, and generic events. */ export interface EventOptions { bubbles?: boolean cancelable?: boolean view?: Window detail?: any // Input specific inputType?: string data?: string // Mouse specific clientX?: number clientY?: number screenX?: number screenY?: number button?: number buttons?: number ctrlKey?: boolean shiftKey?: boolean altKey?: boolean metaKey?: boolean relatedTarget?: EventTarget | null // Keyboard specific key?: string code?: string keyCode?: number repeat?: boolean isComposing?: boolean // Wheel specific deltaX?: number deltaY?: number deltaZ?: number deltaMode?: number // Touch specific (simplified) touches?: TouchList targetTouches?: TouchList changedTouches?: TouchList } /** * Infers the correct Event constructor based on the event type string. */ const getEventConstructor = (type: string): any => { const lowerType = type.toLowerCase() if ( [ 'mousedown', 'mouseup', 'click', 'dblclick', 'mousemove', 'mouseenter', 'mouseleave', 'mouseover', 'mouseout', 'contextmenu', ].includes(lowerType) ) { return MouseEvent } if (['keydown', 'keyup', 'keypress'].includes(lowerType)) { return KeyboardEvent } if ( ['touchstart', 'touchend', 'touchmove', 'touchcancel'].includes(lowerType) ) { // Check if TouchEvent is supported in the environment return typeof TouchEvent !== 'undefined' ? TouchEvent : UIEvent } if (['focus', 'blur', 'focusin', 'focusout'].includes(lowerType)) { return FocusEvent } if (['input', 'beforeinput'].includes(lowerType)) { return InputEvent } if (['wheel'].includes(lowerType)) { return WheelEvent } if (['submit', 'reset', 'change'].includes(lowerType)) { return Event } return Event } /** * Dispatches a native event on the target element. * Automatically selects the appropriate Event interface (Mouse, Keyboard, etc.). */ export const triggerEvent = ( element: Element, type: string, options: EventOptions = {}, ) => { const EventConstructor = getEventConstructor(type) const defaultOptions = { bubbles: true, cancelable: true, view: window, } // Merge defaults with user options const eventInit = { ...defaultOptions, ...options } let event: Event try { event = new EventConstructor(type, eventInit) } catch (e) { // Fallback for environments where specific constructors might fail or strictly require new Event() event = new Event(type, eventInit) } element.dispatchEvent(event) } /** * Triggers an InputEvent (specifically for typing simulation) */ export const triggerInputEvent = (element: Element, data: string | null) => { const event = new InputEvent('input', { bubbles: true, cancelable: true, inputType: 'insertText', data, }) element.dispatchEvent(event) } \`\`\` # src/libs/dom/extract.ts \`\`\`ts /** * Options for text extraction. */ export interface TextExtractOptions { /** If true, returns element.outerHTML. Overrides useTextContent. */ includeTags?: boolean /** If true, uses element.textContent instead of element.innerText */ useTextContent?: boolean /** Regex pattern to filter or extract specific parts of the text */ regex?: string /** Regex flags (e.g., 'g', 'i') */ regexFlags?: string } /** * Retrieves text or HTML from an element with optional regex processing. */ export const getText = ( element: Element, options: TextExtractOptions = {}, ): string => { const { includeTags, useTextContent, regex, regexFlags } = options let text = '' // 1. Extract raw content if (includeTags) { text = element.outerHTML } else if (useTextContent) { text = element.textContent || '' } else if (element instanceof HTMLElement) { text = element.innerText } else { text = element.textContent || '' } // 2. Apply Regex if provided if (regex) { try { const re = new RegExp(regex, regexFlags || '') const match = text.match(re) if (match) { // If global flag is set, join all matches with space // Otherwise return the first match return Array.isArray(match) ? match.join(' ') : match } // Return original text if no match found (or empty string based on preference, return text } catch (e) { console.error('Invalid Regex:', e) } } return text.trim() } /** * Retrieves the value of a specific attribute. * Handles special cases for links (href) and checkboxes (checked). */ export const getAttribute = ( element: Element, attributeName: string, ): string | null => { // Special handling for Checkbox/Radio 'checked' state if (attributeName === 'checked' && element.tagName === 'INPUT') { const input = element as HTMLInputElement if (['checkbox', 'radio'].includes(input.type)) { return String(input.checked) } } // Special handling for 'value' property to get current input value (not just initial attribute) if ( attributeName === 'value' && (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') ) { return (element as HTMLInputElement).value } // Special handling for Links to get absolute URL if (attributeName === 'href' && element.tagName === 'A') { return (element as HTMLAnchorElement).href } // Special handling for Images to get absolute src if (attributeName === 'src' && element.tagName === 'IMG') { return (element as HTMLImageElement).src } // Default attribute retrieval return element.getAttribute(attributeName) } \`\`\` # src/libs/dom/form.ts \`\`\`ts import { waitForElement } from './element' import { triggerEvent, triggerInputEvent } from './events' import { sleep } from './utils' /** * Helper to force value update on React controlled components. */ const setNativeValue = (element: Element, value: string) => { const valueSetter = Object.getOwnPropertyDescriptor(element, 'value')?.set const prototype = Object.getPrototypeOf(element) const prototypeValueSetter = Object.getOwnPropertyDescriptor( prototype, 'value', )?.set if (prototypeValueSetter && valueSetter !== prototypeValueSetter) { prototypeValueSetter.call(element, value) } else if (valueSetter) { valueSetter.call(element, value) } else { ;(element as HTMLInputElement).value = value } } // --- Options Interfaces (Hanya untuk parameter opsional) --- export interface TypeTextOptions { /** Delay between keystrokes in ms. Default 0 (instant) */ delay?: number /** Whether to clear the input before typing. Default false */ clear?: boolean /** Timeout to wait for element. Default 5000ms */ timeout?: number } export interface SelectOptionOptions { /** Timeout to wait for element. Default 5000ms */ timeout?: number } export interface SetCheckedOptions { /** Timeout to wait for element. Default 5000ms */ timeout?: number } // --- Functions --- /** * Simulates typing into an input or textarea element. * Usage: typeText('#input-id', 'Hello World') */ export const typeText = async ( selector: string, text: string, options: TypeTextOptions = {}, ) => { const { delay = 100, clear = false, timeout = 5000 } = options // 1. Wait for element automatically const element = await waitForElement(selector, timeout) if (!element) { throw new Error(`Element not found for typeText: ${selector}`) } if (element instanceof HTMLElement) { element.focus() } const isContentEditable = (element as HTMLElement).isContentEditable const isInput = element.tagName === 'INPUT' || element.tagName === 'TEXTAREA' // Clear value if requested if (clear) { if (isInput) { setNativeValue(element, '') triggerEvent(element, 'input') triggerEvent(element, 'change') } else if (isContentEditable) { ;(element as HTMLElement).innerText = '' } } if (!text) return // Type logic if (delay > 0) { for (const char of text) { if (isInput) { const inputEl = element as HTMLInputElement const currentValue = inputEl.value const newValue = currentValue + char setNativeValue(inputEl, newValue) triggerInputEvent(inputEl, char) } else if (isContentEditable) { element.textContent = (element.textContent || '') + char triggerInputEvent(element, char) } await sleep(delay) } } else { // Instant typing if (isInput) { const inputEl = element as HTMLInputElement const newValue = (clear ? '' : inputEl.value) + text setNativeValue(inputEl, newValue) triggerInputEvent(inputEl, null) } else if (isContentEditable) { element.textContent = (clear ? '' : element.textContent) + text triggerInputEvent(element, null) } } triggerEvent(element, 'change') if (element instanceof HTMLElement) { element.blur() } } /** * Selects an option in a <select> element. * Usage: selectOption('#select-id', 'ValueOrText') */ export const selectOption = async ( selector: string, value: string, options: SelectOptionOptions = {}, ) => { const { timeout = 5000 } = options const element = (await waitForElement(selector, timeout)) as HTMLSelectElement if (!element) { throw new Error(`Select element not found: ${selector}`) } if (element.tagName !== 'SELECT') { console.warn(`Element ${selector} is not a SELECT tag.`) return } const optionElements = Array.from(element.options) const optionToSelect = optionElements.find( (opt) => opt.value === value || opt.text === value, ) if (optionToSelect) { setNativeValue(element, optionToSelect.value) triggerEvent(element, 'input') triggerEvent(element, 'change') } else { console.warn(`Option "${value}" not found in select element ${selector}.`) } } /** * Sets the state of a checkbox or radio button. * Usage: setChecked('#checkbox-id', true) */ export const setChecked = async ( selector: string, checked: boolean, options: SetCheckedOptions = {}, ) => { const { timeout = 5000 } = options const element = (await waitForElement(selector, timeout)) as HTMLInputElement if (!element) { throw new Error(`Checkbox/Radio element not found: ${selector}`) } if (element.type !== 'checkbox' && element.type !== 'radio') { throw new Error(`Element ${selector} is not a checkbox or radio button`) } if (element.checked !== checked) { element.click() if (element.checked !== checked) { element.checked = checked triggerEvent(element, 'change') triggerEvent(element, 'input') } } } \`\`\` # src/libs/dom/index.ts \`\`\`ts import { saveAssets } from './assets' import { handleDialog } from './dialog' import { findElement as find, isInViewport, isVisible, waitForElement as wait, } from './element' import { getAttribute, getText } from './extract' import { setChecked as checkbox, selectOption as select, typeText as text, } from './form' import { blurElement as blur, focusElement as focus, selectText, } from './interact' import { pressKey } from './keyboard' import { loopElements as loop } from './loop' import { clickElement as click, doubleClickElement as doubleClick, hoverElement as hover, rightClickElement as rightClick, } from './mouse' import { takeScreenshot as screenshot } from './screenshot' import { scroll } from './scroll' import { uploadFile } from './upload' export default { element: { find, wait, isVisible, isInViewport }, input: { text, checkbox, select, focus, blur }, mouse: { click, doubleClick, rightClick, hover }, attr: { getText, getAttribute, selectText }, keyboard: { pressKey, }, scroll, uploadFile, loop, dialog: { handle: handleDialog, }, assets: { save: saveAssets, }, screenshot, } \`\`\` # src/libs/dom/interact.ts \`\`\`ts // src/libs/dom/interact.ts import { waitForElement } from './element' import { triggerEvent } from './events' export interface InteractOptions { selector: string timeout?: number } /** * Focuses on an element. * Triggers: focus, focusin events and native .focus() */ export const focusElement = async (options: InteractOptions): Promise<void> => { const { selector, timeout = 5000 } = options const element = await waitForElement(selector, timeout) if (!element) { throw new Error(`Element not found for focus: ${selector}`) } if (element instanceof HTMLElement) { element.focus() } triggerEvent(element, 'focus', { bubbles: false }) triggerEvent(element, 'focusin', { bubbles: true }) } /** * Removes focus from an element (Blur). * Triggers: blur, focusout events and native .blur() */ export const blurElement = async (options: InteractOptions): Promise<void> => { const { selector, timeout = 5000 } = options const element = await waitForElement(selector, timeout) if (!element) { throw new Error(`Element not found for blur: ${selector}`) } if (element instanceof HTMLElement) { element.blur() } triggerEvent(element, 'blur', { bubbles: false }) triggerEvent(element, 'focusout', { bubbles: true }) } /** * Selects all text in an input or textarea element. */ export const selectText = async (options: InteractOptions): Promise<void> => { const { selector, timeout = 5000 } = options const element = await waitForElement(selector, timeout) if (!element) { throw new Error(`Element not found for select: ${selector}`) } if ( element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement ) { element.select() triggerEvent(element, 'select', { bubbles: true }) } else { throw new Error( `Element is not selectable (must be input or textarea): ${selector}`, ) } } \`\`\` # src/libs/dom/keyboard-map.ts \`\`\`ts export interface KeyDefinition { keyCode: number code: string key: string text?: string shiftKey?: string } /** * A subset of US Keyboard Layout definitions. * Maps character/key names to their DOM event properties. */ export const keyDefinitions: Record<string, KeyDefinition> = { '0': { keyCode: 48, key: '0', code: 'Digit0' }, '1': { keyCode: 49, key: '1', code: 'Digit1' }, '2': { keyCode: 50, key: '2', code: 'Digit2' }, '3': { keyCode: 51, key: '3', code: 'Digit3' }, '4': { keyCode: 52, key: '4', code: 'Digit4' }, '5': { keyCode: 53, key: '5', code: 'Digit5' }, '6': { keyCode: 54, key: '6', code: 'Digit6' }, '7': { keyCode: 55, key: '7', code: 'Digit7' }, '8': { keyCode: 56, key: '8', code: 'Digit8' }, '9': { keyCode: 57, key: '9', code: 'Digit9' }, Enter: { keyCode: 13, code: 'Enter', key: 'Enter', text: '\r' }, Escape: { keyCode: 27, code: 'Escape', key: 'Escape' }, Tab: { keyCode: 9, code: 'Tab', key: 'Tab' }, Space: { keyCode: 32, code: 'Space', key: ' ' }, ArrowLeft: { keyCode: 37, code: 'ArrowLeft', key: 'ArrowLeft' }, ArrowUp: { keyCode: 38, code: 'ArrowUp', key: 'ArrowUp' }, ArrowRight: { keyCode: 39, code: 'ArrowRight', key: 'ArrowRight' }, ArrowDown: { keyCode: 40, code: 'ArrowDown', key: 'ArrowDown' }, Backspace: { keyCode: 8, code: 'Backspace', key: 'Backspace' }, Delete: { keyCode: 46, code: 'Delete', key: 'Delete' }, // Modifiers Shift: { keyCode: 16, code: 'ShiftLeft', key: 'Shift' }, Control: { keyCode: 17, code: 'ControlLeft', key: 'Control' }, Alt: { keyCode: 18, code: 'AltLeft', key: 'Alt' }, Meta: { keyCode: 91, code: 'MetaLeft', key: 'Meta' }, // Letters (A-Z) generator would be handled in logic, but here are base mappings a: { keyCode: 65, key: 'a', code: 'KeyA' }, b: { keyCode: 66, key: 'b', code: 'KeyB' }, // ... Add more special keys as needed based on USKeyboardLayout.js } /** * Helper to retrieve key definition dynamically */ export const getKeyDefinition = (keyChar: string): KeyDefinition => { // 1. Check direct map if (keyDefinitions[keyChar]) return keyDefinitions[keyChar] // 2. Handle single letters (a-z, A-Z) if (/^[a-zA-Z]$/.test(keyChar)) { const upper = keyChar.toUpperCase() return { keyCode: upper.charCodeAt(0), code: `Key${upper}`, key: keyChar, } } // 3. Fallback for unknown keys return { keyCode: 0, code: `Key${keyChar}`, key: keyChar, } } \`\`\` # src/libs/dom/keyboard.ts \`\`\`ts import { waitForElement } from './element' import { getKeyDefinition, type KeyDefinition } from './keyboard-map' import { sleep } from './utils' interface KeyModifiers { altKey: boolean ctrlKey: boolean metaKey: boolean shiftKey: boolean } /** * Parses a key string (e.g., "Ctrl+Shift+A") into modifiers and the main key. */ const parseKeyCombination = ( keys: string[], ): { modifiers: KeyModifiers; mainKey: string } => { const modifiers: KeyModifiers = { altKey: false, ctrlKey: false, metaKey: false, shiftKey: false, } const modifierMap: Record<string, keyof KeyModifiers> = { Control: 'ctrlKey', Ctrl: 'ctrlKey', Alt: 'altKey', Shift: 'shiftKey', Meta: 'metaKey', Command: 'metaKey', // Mac support Cmd: 'metaKey', } // Filter out modifiers from the keys array and set flags const remainingKeys = keys.filter((key) => { const mapped = modifierMap[key] if (mapped) { modifiers[mapped] = true return false } return true }) // The last remaining key is treated as the main key (e.g., "A" or "Enter") const mainKey = remainingKeys[remainingKeys.length - 1] || '' return { modifiers, mainKey } } /** * Dispatches keydown, keypress (deprecated but needed), and keyup events. */ const dispatchKeyboardEvents = async ( element: HTMLElement, keyDef: KeyDefinition, modifiers: KeyModifiers, pressTime: number, ) => { const eventOptions = { key: keyDef.key, code: keyDef.code, keyCode: keyDef.keyCode, which: keyDef.keyCode, bubbles: true, cancelable: true, view: window, ...modifiers, } // 1. KeyDown const keyDownEvent = new KeyboardEvent('keydown', eventOptions) element.dispatchEvent(keyDownEvent) const isEditable = element.isContentEditable || ['INPUT', 'TEXTAREA'].includes(element.tagName) if (keyDownEvent.defaultPrevented) { // If prevented, stop here } else if (isEditable) { // Handle "Enter" on forms if (keyDef.key === 'Enter' && element.tagName === 'INPUT') { const form = (element as HTMLInputElement).form if ( form && !modifiers.ctrlKey && !modifiers.altKey && !modifiers.shiftKey ) { // In many browsers, Enter submits the form implicitly // We can optionally try to requestSubmit() if supported if (typeof form.requestSubmit === 'function') { form.requestSubmit() } } } // Handle typing regular characters if single letter and not a shortcut else if ( keyDef.key.length === 1 && !modifiers.ctrlKey && !modifiers.altKey && !modifiers.metaKey ) { // Use execCommand for contentEditable/inputs to handle undo stack and native behavior // Although deprecated, it's the most reliable way to simulate "typing" without direct value manipulation document.execCommand('insertText', false, keyDef.key) } } // Wait for press time if (pressTime > 0) await sleep(pressTime) // 2. KeyUp const keyUpEvent = new KeyboardEvent('keyup', eventOptions) element.dispatchEvent(keyUpEvent) } // --- Exported Options & Function --- export interface KeyboardOptions { /** Time to hold the key down in ms. Default: 0 */ pressTime?: number /** Timeout to wait for element. Default: 5000 */ timeout?: number } /** * Simulates pressing a key or key combination on an element. * Usage: pressKey('#input-id', 'Enter') * Usage: pressKey('body', 'Ctrl+Shift+K') */ export const pressKey = async ( selector: string, key: string, options: KeyboardOptions = {}, ): Promise<void> => { const { pressTime = 0, timeout = 5000 } = options const element = (await waitForElement(selector, timeout)) as HTMLElement if (!element) { throw new Error(`Element not found: ${selector}`) } // Focus element before typing element.focus() // Split combination "Ctrl+A" -> ["Ctrl", "A"] const keysArr = key.split('+').map((k) => k.trim()) const { modifiers, mainKey } = parseKeyCombination(keysArr) const keyDefinition = getKeyDefinition(mainKey) await dispatchKeyboardEvents(element, keyDefinition, modifiers, pressTime) } \`\`\` # src/libs/dom/loop.ts \`\`\`ts import { findAllElements, waitForElement } from './element' import { clickElement } from './mouse' import { scroll } from './scroll' import { sleep } from './utils' export interface LoopOptions { /** Unique ID for the loop session */ loopId: string /** CSS or XPath selector for the elements to loop */ selector: string /** Maximum number of items to loop (0 = unlimited) */ max?: number /** Whether to wait for the selector to appear */ waitForSelector?: boolean /** Timeout for waiting in ms */ waitTimeout?: number /** Action to perform to load more items */ loadMoreAction?: 'none' | 'scroll' | 'click-element' | 'click-link' /** Selector for the 'load more' button/link */ actionElementSelector?: string /** Time to wait after loading more items */ actionMaxWaitTime?: number /** Whether to scroll to bottom when loadMoreAction is 'scroll' */ scrollToBottom?: boolean } export interface LoopResult { loopId: string elements: string[] } /** * Assigns a unique attribute to each element in the list. * This allows subsequent blocks to target specific items in the loop accurately. */ const generateLoopSelectors = ( elements: Element[], loopId: string, max: number = 0, ): string[] => { const selectors: string[] = [] const limit = max > 0 ? Math.min(elements.length, max) : elements.length for (let i = 0; i < limit; i++) { const el = elements[i] const attrName = 'automa-loop' const attrValue = `${loopId}--${i}` el.setAttribute(attrName, attrValue) selectors.push(`[${attrName}="${attrValue}"]`) } return selectors } /** * Main function to handle looping over elements. * It handles pagination actions (scroll/click) and returns unique selectors for the found items. */ export const loopElements = async ( options: LoopOptions, ): Promise<LoopResult> => { const { loopId, selector, max = 0, waitForSelector = false, waitTimeout = 5000, loadMoreAction = 'none', actionElementSelector, actionMaxWaitTime = 5, scrollToBottom = false, } = options // 1. Handle "Load More" Actions (Pagination) if (loadMoreAction === 'scroll' && scrollToBottom) { // Scroll to bottom to trigger infinite scroll await scroll({ selector: 'body', y: 999999, smooth: true }) await sleep(actionMaxWaitTime * 1000) } else if ( ['click-element', 'click-link'].includes(loadMoreAction) && actionElementSelector ) { // Click a "Next" or "Load More" button try { await clickElement(actionElementSelector, { timeout: actionMaxWaitTime * 1000, }) await sleep(actionMaxWaitTime * 1000) } catch (e) { console.warn(`Load more element not found: ${actionElementSelector}`) } } // 2. Wait for elements if requested if (waitForSelector) { await waitForElement(selector, waitTimeout) } // 3. Find all matching elements const elements = findAllElements({ selector }) // 4. Tag elements and generate unique selectors const uniqueSelectors = generateLoopSelectors(elements, loopId, max) return { loopId, elements: uniqueSelectors, } } \`\`\` # src/libs/dom/mouse.ts \`\`\`ts // src/libs/dom/mouse.ts import { waitForElement } from './element' import { triggerEvent, type EventOptions } from './events' export interface MouseActionOptions { /** Timeout to wait for element. Default 5000ms */ timeout?: number } /** * Simulates a hover action on an element. * Usage: hoverElement('#menu-item') */ export const hoverElement = async ( selector: string, options: MouseActionOptions = {}, ): Promise<void> => { const { timeout = 5000 } = options const element = await waitForElement(selector, timeout) if (!element) { throw new Error(`Element not found for hover: ${selector}`) } const rect = element.getBoundingClientRect() const clientX = rect.left + rect.width / 2 const clientY = rect.top + rect.height / 2 const mouseOptions: EventOptions = { clientX, clientY, bubbles: true, cancelable: true, view: window, } triggerEvent(element, 'mousemove', mouseOptions) triggerEvent(element, 'mouseenter', { ...mouseOptions, bubbles: false }) triggerEvent(element, 'mouseover', mouseOptions) } /** * Simulates a left click sequence. * Usage: clickElement('#submit-btn') */ export const clickElement = async ( selector: string, options: MouseActionOptions = {}, ): Promise<void> => { const { timeout = 5000 } = options const element = await waitForElement(selector, timeout) if (!element) { throw new Error(`Element not found for click: ${selector}`) } const rect = element.getBoundingClientRect() const center = { clientX: rect.left + rect.width / 2, clientY: rect.top + rect.height / 2, } const eventOpts: EventOptions = { ...center, bubbles: true, cancelable: true, view: window, } triggerEvent(element, 'mousedown', eventOpts) triggerEvent(element, 'mouseup', eventOpts) if (element instanceof HTMLElement && typeof element.click === 'function') { element.click() } else { triggerEvent(element, 'click', eventOpts) } // Optional: Focus logic implies clicking usually focuses if (element instanceof HTMLElement && typeof element.focus === 'function') { element.focus() } } /** * Simulates a double click sequence. * Usage: doubleClickElement('.folder-icon') */ export const doubleClickElement = async ( selector: string, options: MouseActionOptions = {}, ): Promise<void> => { const { timeout = 5000 } = options const element = await waitForElement(selector, timeout) if (!element) { throw new Error(`Element not found for double click: ${selector}`) } const rect = element.getBoundingClientRect() const eventOpts: EventOptions = { clientX: rect.left + rect.width / 2, clientY: rect.top + rect.height / 2, bubbles: true, cancelable: true, view: window, detail: 2, // Indicates double click count } // Standard sequence for dblclick triggerEvent(element, 'mousedown', eventOpts) triggerEvent(element, 'mouseup', eventOpts) triggerEvent(element, 'click', eventOpts) triggerEvent(element, 'mousedown', eventOpts) triggerEvent(element, 'mouseup', eventOpts) triggerEvent(element, 'click', eventOpts) triggerEvent(element, 'dblclick', eventOpts) } /** * Simulates a right click (context menu). * Usage: rightClickElement('.file-item') */ export const rightClickElement = async ( selector: string, options: MouseActionOptions = {}, ): Promise<void> => { const { timeout = 5000 } = options const element = await waitForElement(selector, timeout) if (!element) { throw new Error(`Element not found for right click: ${selector}`) } const rect = element.getBoundingClientRect() const eventOpts: EventOptions = { clientX: rect.left + rect.width / 2, clientY: rect.top + rect.height / 2, bubbles: true, cancelable: true, view: window, button: 2, // Right button buttons: 2, } triggerEvent(element, 'mousedown', eventOpts) triggerEvent(element, 'contextmenu', eventOpts) triggerEvent(element, 'mouseup', eventOpts) } \`\`\` # src/libs/dom/screenshot.ts \`\`\`ts import { sendToBackground } from '@plasmohq/messaging' import { waitForElement } from './element' import { sleep } from './utils' export type ScreenshotType = 'visible' | 'fullpage' | 'element' export interface ScreenshotOptions { /** Selector is required if type is 'element' */ selector?: string type?: ScreenshotType /** Quality of the image (0-100), default 90. Only applies to jpeg */ quality?: number /** Image format, default png */ format?: 'png' | 'jpeg' /** Timeout to wait for element */ timeout?: number } /** * Helper to load an image from a Data URL */ const loadImage = (src: string): Promise<HTMLImageElement> => { return new Promise((resolve, reject) => { const img = new Image() img.onload = () => resolve(img) img.onerror = reject img.src = src }) } /** * Helper to request a raw screenshot of the current viewport from the background script */ const captureViewport = async (options: ScreenshotOptions): Promise<string> => { const response = await sendToBackground({ //@ts-ignore name: 'screenshot', body: { quality: options.quality, format: options.format, }, }) return response.dataUrl } /** * Captures a specific element by scrolling it into view, taking a viewport screenshot, * and cropping the image via Canvas. */ const captureElement = async ( element: Element, options: ScreenshotOptions, ): Promise<string> => { // Scroll element into view element.scrollIntoView({ block: 'center', inline: 'center', behavior: 'instant', // Use instant to avoid waiting for smooth scroll }) // Wait for scroll/rendering to settle await sleep(500) // Capture viewport const dataUrl = await captureViewport(options) const image = await loadImage(dataUrl) // Calculate cropping coordinates const rect = element.getBoundingClientRect() const dpr = window.devicePixelRatio || 1 // Create canvas for cropping const canvas = document.createElement('canvas') canvas.width = rect.width * dpr canvas.height = rect.height * dpr const ctx = canvas.getContext('2d') if (!ctx) throw new Error('Could not get canvas context') // Draw and crop // Source x/y needs to account for DPR and the element's position in the viewport ctx.drawImage( image, rect.left * dpr, rect.top * dpr, rect.width * dpr, rect.height * dpr, 0, 0, rect.width * dpr, rect.height * dpr, ) return canvas.toDataURL(`image/${options.format || 'png'}`) } /** * Captures the full page by scrolling and stitching images. * Note: This is a simplified implementation. Complex sticky headers might need handling via CSS injection. */ const captureFullPage = async (options: ScreenshotOptions): Promise<string> => { const body = document.body const html = document.documentElement const fullHeight = Math.max( body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight, ) const viewportHeight = window.innerHeight const viewportWidth = window.innerWidth const dpr = window.devicePixelRatio || 1 const canvas = document.createElement('canvas') canvas.width = viewportWidth * dpr canvas.height = fullHeight * dpr const ctx = canvas.getContext('2d') if (!ctx) throw new Error('Could not get canvas context') let scrollY = 0 window.scrollTo(0, 0) await sleep(200) while (scrollY < fullHeight) { const dataUrl = await captureViewport(options) const image = await loadImage(dataUrl) // Draw the current viewport to the canvas // We ignore the scrollbar width for simplicity in this version ctx.drawImage( image, 0, 0, image.width, image.height, 0, scrollY * dpr, image.width, image.height, ) scrollY += viewportHeight if (scrollY < fullHeight) { window.scrollTo(0, scrollY) await sleep(500) // Wait for render } } // Restore scroll position window.scrollTo(0, 0) return canvas.toDataURL(`image/${options.format || 'png'}`) } /** * Main entry point for taking screenshots */ export const takeScreenshot = async ( options: ScreenshotOptions = {}, ): Promise<string> => { const { type = 'visible', selector, timeout = 5000 } = options if (type === 'element') { if (!selector) throw new Error('Selector is required for element screenshot') const element = await waitForElement(selector, timeout) if (!element) throw new Error(`Element not found: ${selector}`) return captureElement(element, options) } if (type === 'fullpage') { return captureFullPage(options) } // Default: Visible viewport return captureViewport(options) } \`\`\` # src/libs/dom/scroll.ts \`\`\`ts import { waitForElement } from './element' /** * Checks if an element has scrollable content. */ export const isScrollable = (element: Element): boolean => { if (!(element instanceof HTMLElement)) return false const excludedTags = ['SCRIPT', 'STYLE', 'SVG', 'HEAD'] if (element.tagName.includes('-') || excludedTags.includes(element.tagName)) { return false } const style = window.getComputedStyle(element) const overflowY = style.overflowY const overflowX = style.overflowX // Check if overflow allows scrolling const canScrollY = ['auto', 'scroll'].includes(overflowY) || (overflowY !== 'hidden' && overflowY !== 'visible') const canScrollX = ['auto', 'scroll'].includes(overflowX) || (overflowX !== 'hidden' && overflowX !== 'visible') const hasScrollableContent = element.scrollHeight > element.clientHeight || element.scrollWidth > element.clientWidth return (canScrollY || canScrollX) && hasScrollableContent } /** * Finds the nearest scrollable ancestor or descendant. * Useful when the selected element is just a wrapper or a child of the actual scroll container. */ export const findScrollableElement = ( element: Element = document.documentElement, direction: 'up' | 'down' = 'down', maxDepth: number = 5, ): Element | null => { if (maxDepth === 0) return null if (isScrollable(element)) return element if (direction === 'up') { const parentEl = element.parentElement if (!parentEl) return null return findScrollableElement(parentEl, direction, maxDepth - 1) } // Direction down: search children for (let i = 0; i < element.children.length; i++) { const child = element.children[i] const scrollable = findScrollableElement(child, direction, maxDepth - 1) if (scrollable) return scrollable } return null } export interface ScrollOptions { selector: string timeout?: number /** Whether to simply scroll the element into the viewport */ intoView?: boolean /** Horizontal scroll position (pixels) */ x?: number /** Vertical scroll position (pixels) */ y?: number /** If true, adds x/y to the current scroll position instead of setting it */ increment?: boolean /** Enable smooth scrolling animation */ smooth?: boolean } /** * Handles scrolling operations on an element. */ export const scroll = async (options: ScrollOptions): Promise<void> => { const { selector, timeout = 5000, intoView = false, x = 0, y = 0, increment = false, smooth = false, } = options const element = await waitForElement(selector, timeout) if (!element) { throw new Error(`Element not found for scrolling: ${selector}`) } const behavior: ScrollBehavior = smooth ? 'smooth' : 'auto' if (intoView) { element.scrollIntoView({ behavior, block: 'center', inline: 'center' }) return } // Find the actual element that handles scrolling (often it's a parent div or the body) const target = findScrollableElement(element, 'up', 3) || findScrollableElement(element, 'down', 3) || element let top = y let left = x if (increment) { top += target.scrollTop left += target.scrollLeft } target.scrollTo({ top, left, behavior }) // Dispatch scroll event manually to trigger listeners (e.g., lazy loading) window.dispatchEvent(new Event('scroll')) } \`\`\` # src/libs/dom/upload.ts \`\`\`ts import { waitForElement } from './element' import { triggerEvent } from './events' /** * Helper to fetch a file from a URL and convert it to a DOM File object. */ export const urlToFile = async ( url: string, filename?: string, ): Promise<File> => { try { const response = await fetch(url) if (!response.ok) { throw new Error( `Failed to fetch file from ${url}: ${response.statusText}`, ) } const blob = await response.blob() // Attempt to extract filename from URL if not provided const name = filename || url.split('/').pop()?.split('?')[0] || 'downloaded_file' return new File([blob], name, { type: blob.type }) } catch (error) { throw new Error(`Error converting URL to File: ${error.message}`) } } export interface UploadOptions { selector: string /** * Array of file paths (URLs) or actual File objects. * If a string is provided, it will attempt to fetch it. */ files: (string | File)[] timeout?: number } /** * Simulates uploading files to an input[type="file"] element. * Automatically handles fetching files from URLs if strings are provided. */ export const uploadFile = async (options: UploadOptions): Promise<void> => { const { selector, files, timeout = 5000 } = options const element = (await waitForElement(selector, timeout)) as HTMLInputElement if (!element) { throw new Error(`Element not found: ${selector}`) } if (element.tagName !== 'INPUT' || element.type !== 'file') { throw new Error(`Target element is not a file input: ${selector}`) } const fileObjects: File[] = [] // Process inputs: convert URLs to File objects if necessary for (const item of files) { if (item instanceof File) { fileObjects.push(item) } else if (typeof item === 'string') { // Handle base64 data URIs or remote URLs const file = await urlToFile(item) fileObjects.push(file) } } if (fileObjects.length === 0) { console.warn('No files provided for upload.') return } // Modern way to set input files programmatically const dataTransfer = new DataTransfer() fileObjects.forEach((file) => dataTransfer.items.add(file)) element.files = dataTransfer.files // Dispatch events so frameworks (React/Vue) detect the change triggerEvent(element, 'input', { bubbles: true }) triggerEvent(element, 'change', { bubbles: true }) } \`\`\` # src/libs/dom/utils.ts \`\`\`ts /** * Helper to pause execution for a given time. */ export const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms)) /** * Checks if a selector string is an XPath. */ export const isXPath = (selector: string): boolean => { const regex = /^([(/@]|id\()/ return regex.test(selector) || selector.startsWith('xpath:') } \`\`\` # src/libs/http.ts \`\`\`ts import axios from 'axios' const http = axios.create({}) export default http \`\`\` # src/libs/ls.ts \`\`\`ts import * as lemon from '@lemonsqueezy/lemonsqueezy.js' lemon.lemonSqueezySetup({}) const lemonSqueezy = lemon export default lemonSqueezy \`\`\` # src/libs/storage.ts \`\`\`ts import { Storage } from '@plasmohq/storage' export const storage = new Storage({}) \`\`\` # src/libs/theme.ts \`\`\`ts import { ActionIcon, Badge, Button, createTheme, FileInput, Menu, Modal, MultiSelect, NumberInput, Paper, Popover, Radio, SegmentedControl, // Ditambahkan Select, Switch, TagsInput, Text, Textarea, TextInput, Tooltip, } from '@mantine/core' const theme = createTheme({ primaryColor: 'emerald', defaultRadius: 'md', // REMOVE font customization to revert to Mantine default // Mantine automatically uses safe System Fonts. colors: { // Custom Emerald Palette (MatrixPay style) emerald: [ '#ecfdf5', // 0 '#d1fae5', // 1 '#a7f3d0', // 2 '#6ee7b7', // 3 (300) '#34d399', // 4 (400) '#10b981', // 5 (500) - Primary '#059669', // 6 (600) '#047857', // 7 '#065f46', // 8 '#064e3b', // 9 ], dark: [ '#C1C2C5', '#A6A7AB', '#909296', '#5c5f66', '#373A40', '#2C2E33', '#25262b', '#101113', // 7 '#141517', // 8 '#000000', // 9 - Deep Black ], }, components: { Button: Button.extend({ defaultProps: { size: 'sm', radius: 'xl', }, styles: (theme, props) => { const isFilled = props.variant === 'filled' || props.variant === undefined return { root: { backgroundImage: isFilled ? 'linear-gradient(0deg, #059669, #10b981)' : undefined, boxShadow: isFilled ? '0 0 15px rgba(16, 185, 129, 0.3)' : undefined, border: isFilled ? 'none' : '1px solid rgba(255, 255, 255, 0.1)', transition: 'transform 0.2s ease, box-shadow 0.2s ease', '&:hover': { transform: 'scale(1.02)', boxShadow: isFilled ? '0 0 20px rgba(16, 185, 129, 0.5)' : undefined, }, }, } }, }), ActionIcon: ActionIcon.extend({ defaultProps: { radius: 'md', variant: 'subtle', // Default tetap subtle agar tidak mengganggu UI yang sudah ada }, styles: (theme, props) => { // KONDISI KHUSUS: Jangan terapkan style berat untuk variant subtle/transparent if (props.variant === 'subtle' || props.variant === 'transparent') { return { root: { border: 'none', transition: 'transform 0.2s ease, background-color 0.2s ease', '&:hover': { transform: 'scale(1.1)', // Efek hover minimalis backgroundColor: 'rgba(255, 255, 255, 0.05)', }, }, } } // LOGIKA BUTTON STYLE (Untuk variant Default, Filled, Outline) const isFilled = props.variant === 'filled' const isDefault = props.variant === 'default' return { root: { // Gradient hanya untuk filled backgroundImage: isFilled ? 'linear-gradient(0deg, #059669, #10b981)' : undefined, // Glow effect hanya untuk filled boxShadow: isFilled ? '0 0 15px rgba(16, 185, 129, 0.3)' : undefined, // Border untuk Default dan Outline (mirip Button) border: isDefault || props.variant === 'outline' ? '1px solid rgba(255, 255, 255, 0.1)' : 'none', // Background khusus untuk Default agar terlihat seperti Glass backgroundColor: isDefault ? 'rgba(255, 255, 255, 0.03)' : undefined, transition: 'transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease', '&:hover': { transform: 'scale(1.05)', boxShadow: isFilled ? '0 0 20px rgba(16, 185, 129, 0.5)' : undefined, // Efek hover background untuk Default backgroundColor: isDefault ? 'rgba(255, 255, 255, 0.06)' : undefined, }, }, } }, }), Paper: Paper.extend({ defaultProps: { radius: 'lg', }, styles: (theme) => ({ root: { backgroundColor: 'rgba(15, 23, 42, 0.6) !important', backdropFilter: 'blur(12px)', border: '1px solid rgba(255, 255, 255, 0.1)', color: '#f8fafc', }, }), }), Modal: Modal.extend({ defaultProps: { size: 'xl', withCloseButton: false, withOverlay: true, withinPortal: false, radius: 'xl', transitionProps: { transition: 'fade-up', duration: 200 }, }, styles: { overlay: { backgroundColor: 'rgba(0, 0, 0, 0.7)', backdropFilter: 'blur(4px)', }, content: { backgroundColor: 'rgba(2, 6, 23, 0.95)', border: '1px solid rgba(52, 211, 153, 0.3)', boxShadow: '0 0 40px rgba(0,0,0,0.8)', }, header: { backgroundColor: 'transparent', }, }, }), TextInput: TextInput.extend({ defaultProps: { size: 'md', radius: 'md' }, styles: { input: { backgroundColor: 'rgba(255,255,255,0.03)', borderColor: 'rgba(255,255,255,0.1)', color: '#fff', '&:focus': { borderColor: '#10b981', boxShadow: '0 0 0 1px #10b981', }, }, }, }), Textarea: Textarea.extend({ defaultProps: { size: 'md', radius: 'md' }, }), NumberInput: NumberInput.extend({ defaultProps: { size: 'md', radius: 'md' }, }), Select: Select.extend({ defaultProps: { size: 'md', radius: 'md', comboboxProps: { withinPortal: false }, styles: { input: { backgroundColor: 'rgba(255,255,255,0.03)', borderColor: 'rgba(255,255,255,0.1)', color: '#fff', '&:focus': { borderColor: '#10b981', boxShadow: '0 0 0 1px #10b981', }, }, }, }, }), MultiSelect: MultiSelect.extend({ defaultProps: { size: 'md', radius: 'md', comboboxProps: { withinPortal: false }, }, }), TagsInput: TagsInput.extend({ defaultProps: { size: 'md', radius: 'md', comboboxProps: { withinPortal: false }, styles: { input: { backgroundColor: 'rgba(255,255,255,0.03)', borderColor: 'rgba(255,255,255,0.1)', color: '#fff', '&:focus': { borderColor: '#10b981', boxShadow: '0 0 0 1px #10b981', }, }, }, }, }), Menu: Menu.extend({ defaultProps: { withinPortal: false, shadow: 'xl', }, styles: { dropdown: { backgroundColor: 'rgba(2, 6, 23, 0.95)', backdropFilter: 'blur(16px)', border: '1px solid rgba(52, 211, 153, 0.2)', boxShadow: '0 4px 30px rgba(0, 0, 0, 0.5), 0 0 20px rgba(16, 185, 129, 0.1)', }, item: { color: '#f8fafc', transition: 'all 0.15s ease', '&:hover': { backgroundColor: 'rgba(16, 185, 129, 0.15)', }, '&[data-hovered]': { backgroundColor: 'rgba(16, 185, 129, 0.15)', }, }, itemLabel: { color: '#f8fafc', }, label: { color: 'rgba(255, 255, 255, 0.5)', fontSize: '11px', textTransform: 'uppercase', letterSpacing: '0.05em', }, divider: { borderColor: 'rgba(255, 255, 255, 0.1)', }, }, }), Popover: Popover.extend({ defaultProps: { withinPortal: false, }, }), Badge: Badge.extend({ defaultProps: { variant: 'light', radius: 'sm' }, styles: { root: { backgroundColor: 'rgba(16, 185, 129, 0.15)', color: '#6ee7b7', letterSpacing: '0.05em', fontWeight: 600, }, }, }), Text: Text.extend({ defaultProps: { c: 'gray.3' }, }), Tooltip: Tooltip.extend({ defaultProps: { position: 'left', withinPortal: false, withArrow: true, }, styles: { tooltip: { backgroundColor: '#000', border: '1px solid rgba(255,255,255,0.2)', color: '#fff', }, }, }), // ADDED: Global Switch styling for cursor pointer Switch: Switch.extend({ styles: { root: { cursor: 'pointer' }, input: { cursor: 'pointer' }, track: { cursor: 'pointer' }, thumb: { cursor: 'pointer' }, label: { cursor: 'pointer' }, }, }), SegmentedControl: SegmentedControl.extend({ defaultProps: { radius: 'xl', size: 'md', withItemsBorders: false, }, styles: (theme) => ({ root: { backgroundColor: 'rgba(255, 255, 255, 0.05)', border: '1px solid rgba(255, 255, 255, 0.1)', padding: '4px', }, indicator: { // Match the primary button style (Emerald Gradient) backgroundImage: 'linear-gradient(0deg, #059669, #10b981)', boxShadow: '0 0 15px rgba(16, 185, 129, 0.3)', }, label: { transition: 'all 0.2s ease', '&[data-active]': { fontWeight: 600, }, '&:hover': {}, }, }), }), }, }) export default theme \`\`\` # src/libs/wa/blocklist.ts \`\`\`ts import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' export const all = async (): Promise<Wid[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.ALL, body: {}, }) } export const blockContact = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.BLOCK_CONTACT, body: chatId, }) } export const isBlocked = async (chatId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.IS_BLOCKED, body: chatId, }) } export const unblockContact = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Blocklist.UNBLOCK_CONTACT, body: chatId, }) } \`\`\` # src/libs/wa/cart.ts \`\`\`ts import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { SendMessageOptions } from '@wppconnect/wa-js/dist/chat' /** * Add product in cart * * @example * \`\`\`javascript * const cart = wa.cart.add('[number]@c.us', [ * { id: 'productId', qnt: 2 }, * ]); * \`\`\` */ export const add = async ( chatId: string, products: { id: string qnt: number }[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.ADD, body: { chatId, products }, }) } /** * Clear all items of cart * */ export const clear = async (wid: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.CLEAR, body: wid, }) } /** * Get products in cart chat * * @example * \`\`\`javascript * const cart = wa.cart.get('[number]@c.us'); * \`\`\` */ export const get = async (wid: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.GET, body: wid, }) } /** * Get thumb of a cart * * @example * \`\`\`javascript * const cart = wa.cart.getThumbFromCart('[number]@c.us'); * \`\`\` */ export const getThumbFromCart = async (wid: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.GET_THUMB_FROM_CART, body: wid, }) } /** * Remove a product in cart * * @example * \`\`\`javascript * const cart = wa.cart.remove('[number]@c.us', '6987301181294productId'); * \`\`\` */ export const remove = async ( chatId: string, productId: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.REMOVE, body: { chatId, productId }, }) } /** * Send a request order to business chat * * @example * \`\`\`javascript * const cart = wa.cart.submit('[number]@c.us'); * \`\`\` * * @example * \`\`\`javascript * // Send cart with a custom message * const cart = wa.cart.submit('[number]@c.us', 'Custom message here'); * \`\`\` */ export const submit = async ( wid: string, msg?: string, options?: SendMessageOptions, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.SUBMIT, body: { wid, msg, options }, }) } /** * Update product in cart * * @example * \`\`\`javascript * const cart = wa.cart.update('[number]@c.us', '6987301181294productId', { quantity: 12 }); * \`\`\` */ export const update = async ( chatId: string, productId: string, options: { quantity: number }, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Cart.UPDATE, body: { chatId, productId, options }, }) } \`\`\` # src/libs/wa/catalog.ts \`\`\`ts import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { createProductParams } from '@wppconnect/wa-js/dist/catalog/functions/createProduct' import type { editProductParams } from '@wppconnect/wa-js/dist/catalog/functions/editProduct' /** * Add image on product * This function include additional images on product * for change main image use @changeProductImage * * @example * \`\`\`javascript * await wa.catalog.addProductImage('686859858689', 'data:image/jpeg;base64,.....'); * \`\`\` */ export const addProductImage = async ( productId: string, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.ADD_PRODUCT_IMAGE, body: { productId, content }, }) } /** * Add image on product * This function change main image of product * for change additional images use @addProductImage * * @example * \`\`\`javascript * await wa.catalog.changeProductImage('686859858689', 'data:image/jpeg;base64,.....'); * \`\`\` */ export const changeProductImage = async ( productId: string, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.CHANGE_PRODUCT_IMAGE, body: { productId, content }, }) } /** * Create new collection * * @example * \`\`\`javascript * const myCatalog = await wa.catalog.createCollection('Collection Name', ['565656589898']); * \`\`\` */ export const createCollection = async ( collectionName: string, productsId: string[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.CREATE_COLLECTION, body: { collectionName, productsId }, }) } /** * Create new product * * @example * \`\`\`javascript * const myCatalog = await wa.catalog.addProduct( { name: 'Product name', image: 'base64 image string', description: 'product description', price: '89.90', isHidden: false, url: 'https://wppconnect.io', retailerId: 'AKA001', } ); * \`\`\` */ export const createProduct = async ( params: createProductParams, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.CREATE_PRODUCT, body: params, }) } /** * Delete a collection * * @example * \`\`\`javascript * const myCatalog = await wa.catalog.deleteCollection("377095767832354"); * \`\`\` * * @return Return sucess or error */ export const deleteCollection = async (collectionId: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.DELETE_COLLECTION, body: collectionId, }) } /** * @example * \`\`\`javascript * * // Delete various products * const myCatalog = await wa.catalog.delProducts(['6104203702939361', '6104289702939361']); * \`\`\` */ export const deleteProduct = async (productsIds: string[]): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.DELETE_PRODUCT, body: productsIds, }) } /** * @example * \`\`\`javascript * const myCatalog = await wa.catalog.EditCollection('565656589898', { collectionName: 'New Name for collection', productsToAdd: ['5656523223'], productsToRemove: ['5656523232']}); * \`\`\` */ interface paramsEditCollection { name?: string productsToAdd?: string[] productsToRemove?: string[] } export const editCollection = async ( collectionId: string, params: paramsEditCollection, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.EDIT_COLLECTION, body: { collectionId, params }, }) } /** * @example * \`\`\`javascript * // Get your current catalog * const myCatalog = wa.catalog.editProduct('5498255476885590', {name: 'Plano 01', price: '89990', description: 'Insert description for your product', isHidden: true, url: 'http://www.wppconnect.io', retailerId: 'AKA001'}); * \`\`\` */ export const editProduct = async ( productId: string, params: editProductParams, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.EDIT_PRODUCT, body: { productId, params }, }) } /** * Get collections of catalog * * @example * \`\`\`javascript * // Retrieve 20 collections of chat * const myCatalog = await wa.catalog.getCollections('552198554578@c.us', '20'); * * // Retrieve 20 collections of chat and products arrays limit with 10 products * const myCatalog = await wa.catalog.getCollections('552198554578@c.us', '20', '10'); * \`\`\` */ export const getCollections = async ( chatId: string, qnt?: number, productsCount?: number, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_COLLECTIONS, body: { chatId, qnt, productsCount }, }) } /** * Get your current catalog * * @example * \`\`\`javascript * // Get your current catalog * const myCatalog = await wa.catalog.getMyCatalog(); * \`\`\` */ export const getMyCatalog = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_MY_CATALOG, body: {}, }) } /** * Retrieves product by id * * @example * \`\`\`javascript * // Retrieve data of product * await wa.catalog.getProductById('5521985565656@c.us', '68685985868923'); * \`\`\` */ export const getProductById = async ( chatId: string, productId: number, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_PRODUCT_BY_ID, body: { chatId, productId }, }) } /** * Retrieves product by contact id * * @example * Get products of catalogs * \`\`\`javascript * await wa.catalog.getProducts('5521985625689@c.us', 10); * \`\`\` */ export const getProducts = async (chatId: string, qnt: number): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.GET_PRODUCTS, body: { chatId, qnt }, }) } /** * Remove image on product * This function remove additional images of product * for change main image use @changeProductImage * * @example * \`\`\`javascript * await wa.catalog.removeProductImage('68685985868923', '0'); * \`\`\` */ export const removeProductImage = async ( productId: string, index: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.REMOVE_PRODUCT_IMAGE, body: { productId, index }, }) } /** * Get your current catalog * * @example * \`\`\`javascript * // Set product visibility hidden * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, true); * \`\`\` * // Set product visible * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, false); * \`\`\` */ export const setProductVisibility = async ( productId: any, isHidden: boolean, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.SET_PRODUCT_VISIBILITY, body: { productId, isHidden }, }) } /** * Get your current catalog * * @example * \`\`\`javascript * // Set product visibility hidden * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, true); * \`\`\` * // Set product visible * const myCatalog = await wa.catalog.setProductVisibility(54985569989897, false); * \`\`\` * * @return Return sucess of product visibility set */ export const updateCartEnabled = async (enabled: boolean): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Catalog.UPDAGE_CART_ENABLED, body: enabled, }) } \`\`\` # src/libs/wa/chat.ts \`\`\`ts import { Action } from '@/constants' import type { Response } from '@/types' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ChatListOptions, DeleteMessageReturn, ForwardMessagesOptions, GetMessagesOptions, RawMessage, } from '@wppconnect/wa-js/dist/chat' import type { ParticipantStatusACK } from '@wppconnect/wa-js/dist/chat/functions/getMessageACK' import type { Stringable } from '@wppconnect/wa-js/dist/types' import type { MsgKey, MsgModel, Wid } from '@wppconnect/wa-js/dist/whatsapp' import type { ACK } from '@wppconnect/wa-js/dist/whatsapp/enums' /** * Archive a chat * * @example * // Archive a chat * wa.chat.archive('[number]@c.us'); * * // Unarchive a chat * wa.chat.archive('[number]@c.us', false); * \`\`\` */ export const archive = async ( chatId: string | Wid, archive = true, ): Promise<{ wid: Wid archive: boolean }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.ARCHIVE, body: { chatId, archive }, }) } /** * Pin a chat * * @example * \`\`\`javascript * // Pin a chat * WPP.chat.pin('[number]@c.us'); * * // Unpin a chat * WPP.chat.pin('[number]@c.us', false); * // or * WPP.chat.unpin('[number]@c.us'); * \`\`\` * @category Chat */ export const pin = async (chatId: string | Wid, pin = true): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.PIN, body: { chatId, pin }, }) } /** * Get if message can played * * @example * \`\`\`javascript * wa.chat.canMarkPlayed('[message_id]'); * \`\`\` */ export const canMarkPlayed = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CAN_MARK_PLAYED, body: messageId, }) } /** * Check if is possible to mute this chat * * @example * \`\`\`javascript * const canMute = wa.chat.canMute('[number]@c.us'); * \`\`\` */ export const canMute = async (chatId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CAN_MUTE, body: chatId, }) } /** * Get if message can reply * * @example * \`\`\`javascript * wa.chat.canReply('[message_id]'); * \`\`\` */ export const canReply = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CAN_REPLY, body: messageId, }) } /** * Clear a chat message * */ export const clear = async ( chatId: string | Wid, keepStarred = true, ): Promise<{ wid: Wid status: number keepStarred: boolean }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CLEAR, body: { chatId, keepStarred }, }) } /** * Close the chat tab * * @example * \`\`\`javascript * await wa.chat.closeChat(); * \`\`\` * */ export const closeChat = async (): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.CLOSE_CHAT, body: {}, }) } /** * Delete a chat * */ export const _delete = async (chatId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.DELETE, body: chatId, }) } /** * Delete a message * * @example * \`\`\`javascript * // Delete a message * wa.chat.deleteMessage('[number]@c.us', 'msgid'); * // Delete a list of messages * wa.chat.deleteMessage('[number]@c.us', ['msgid1', 'msgid2]); * // Delete a message and delete media * wa.chat.deleteMessage('[number]@c.us', 'msgid', true); * // Revoke a message * wa.chat.deleteMessage('[number]@c.us', 'msgid', true, true); * \`\`\` * */ export const deleteMessage = async ( chatId: string | Wid, ids: string | string[], deleteMediaInDevice = false, revoke = false, ): Promise<DeleteMessageReturn | DeleteMessageReturn[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.DELETE_MESSAGE, body: { chatId, ids, deleteMediaInDevice, revoke }, }) } /** * Downloads media from a message * * @example * \`\`\`javascript * await wa.chat.downloadMedia('messageId'); * \`\`\` */ export const downloadMedia = async ( messageId: string | MsgKey, ): Promise<Blob | null> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.DOWNLOAD_MEDIA, body: messageId, }) } export const find = async (chatId: string | Wid): Promise<Response<any>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.FIND, body: chatId, }) } /** * Forward messages to a chat * * @example * \`\`\`javascript * // Forward messages * wa.chat.forwardMessage('[number]@c.us', 'true_[number]@c.us_ABCDEF'); * \`\`\` */ export const forwardMessage = async ( toChatId: string | Wid, msgId: string | MsgKey, options: ForwardMessagesOptions = {}, ): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.FORWARD_MESSAGE, body: { toChatId, msgId, options }, }) } /** * Find a chat by id * */ export const get = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET, body: chatId, }) } export const getActiveChat = async () => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_ACTIVE_CHAT, body: {}, }) } /** * Get timestamp of last seen * @example * \`\`\`javascript * wa.chat.getLastSeen('[number]@c.us'); * \`\`\` */ export const getLastSeen = async ( chatId: string | Wid, ): Promise<number | boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_LAST_SEEN, body: chatId, }) } /** * Get message ACK from a message * * @example * \`\`\`javascript * // Get message ACK * const ackInfo = await WPP.chat.getMessageACK('true_[number]@c.us_ABCDEF'); * * console.log(ackInfo.deliveryRemaining); // Delivery Remaining * console.log(ackInfo.readRemaining); // Read Remaining * console.log(ackInfo.playedRemaining); // PlayedRemaining, for audio(ptt) only * * console.log(ackInfo.participants[0].deliveredAt); // Delivered At, in timestamp format * console.log(ackInfo.participants[0].readAt); // Read At, in timestamp format * console.log(ackInfo.participants[0].playedAt); // Played At, in timestamp format, for audio(ptt) only * * //To get only how was received * const received = ackInfo.participants.filter(p => p.deliveredAt || p.readAt || p.playedAt); * * //To get only how was read * const read = ackInfo.participants.filter(p => p.readAt || p.playedAt); * * //To get only how was played * const played = ackInfo.participants.filter(p => p.playedAt); * \`\`\` */ export const getMessageACK = async ( msgId: string | MsgKey, ): Promise<{ ack: ACK fromMe: boolean deliveryRemaining: number readRemaining: number playedRemaining: number participants: ParticipantStatusACK[] }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_MESSAGE_ACK, body: msgId, }) } /** * Fetch messages from a chat * * @example * \`\`\`javascript * // Some messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * }); * * // All messages * wa.chat.getMessages('[number]@c.us', { * count: -1, * }); * * // Last 20 unread messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * onlyUnread: true, * }); * * // All unread messages * wa.chat.getMessages('[number]@c.us', { * count: -1, * onlyUnread: true, * }); * * // 20 messages before specific message * wa.chat.getMessages('[number]@c.us', { * count: 20, * direction: 'before', * id: '<full message id>' * }); * * // Only media messages (url, document and links) * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'all', * }); * * // Only image messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'image', * }); * * // Only document messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'document', * }); * * // Only link (url) messages * wa.chat.getMessages('[number]@c.us', { * count: 20, * media: 'url', * }); * \`\`\` */ export const getMessages = async ( chatId: string | Wid, options: GetMessagesOptions = {}, ): Promise<any[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_MESSAGES, body: { chatId, options }, }) } /** * Get notes from a contact * Only when are connected with business device * @example * \`\`\`javascript * wa.chat.getNotes('[number]@c.us', 'Text for your notes'); * \`\`\` */ export const getNotes = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_NOTES, body: chatId, }) } /** * Get the platform message from message ID * * The platform can be: * * android * * iphone * * web * * unknown * * @example * \`\`\`javascript * // to get platform from a message * const platform = wa.chat.getPlatformFromMessage('[message_id]'); * \`\`\` */ export const getPlatformFromMessage = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<'android' | 'iphone' | 'web' | 'unknown'> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.GET_PLATFORM_MESSAGE, body: messageId, }) } /** * Return a list of chats * * @example * \`\`\`javascript * // All chats * const chats = await wa.chat.list(); * * // Some chats * const chats = wa.chat.list({count: 20}); * * // 20 chats before specific chat * const chats = wa.chat.list({count: 20, direction: 'before', id: '[number]@c.us'}); * * // Only users chats * const chats = await wa.chat.list({onlyUsers: true}); * * // Only groups chats * const chats = await wa.chat.list({onlyGroups: true}); * * // Only communities chats * const chats = await wa.chat.list({onlyCommunities: true}); * * // Only Newsletter * const chats = await wa.chat.list({onlyNewsletter: true}); * * // Only with label Text * const chats = await wa.chat.list({withLabels: ['Test']}); * * // Only with label id * const chats = await wa.chat.list({withLabels: ['1']}); * * // Only with label with one of text or id * const chats = await wa.chat.list({withLabels: ['Alfa','5']}); * \`\`\` * */ export const list = async (options: ChatListOptions = {}): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.LIST, body: options, }) } /** * Mark a chat to composing state * and keep sending "is writting a message" * * @example * \`\`\`javascript * // Mark is composing * wa.chat.markIsComposing('[number]@c.us'); * * // Mark is composing for 5 seconds * wa.chat.markIsComposing('[number]@c.us', 5000); * \`\`\` */ export const markIsComposing = async ( chatId: string | Wid, duration?: number, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_COMPOSING, body: { chatId, duration }, }) } /** * Mark a chat is paused state * * @example * \`\`\`javascript * // Mark as recording * wa.chat.markIsPaused('[number]@c.us'); * \`\`\` */ export const markIsPaused = async (chatId: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_PAUSED, body: chatId, }) } /** * Mark a chat as read and send SEEN event * * @example * \`\`\`javascript * // Some messages * wa.chat.markIsRead('[number]@c.us'); * \`\`\` */ export const markIsRead = async ( chatId: string, ): Promise<{ wid: Wid unreadCount: number }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_READ, body: chatId, }) } /** * Mark a chat to recording state * and keep sending "is recording" * * @example * \`\`\`javascript * // Mark is recording * wa.chat.markIsRecording('[number]@c.us'); * * // Mark is recording for 5 seconds * wa.chat.markIsRecording('[number]@c.us', 5000); * \`\`\` */ export const markIsRecording = async (chatId: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_RECORDING, body: chatId, }) } /** * Mark a chat as unread * * @example * \`\`\`javascript * // Some messages * wa.chat.markIsUnread('[number]@c.us'); * \`\`\` */ export const markIsUnread = async ( chatId: string | Wid, ): Promise<{ wid: Wid }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_IS_UNREAD, body: chatId, }) } /** * Mark message as played * * @example * \`\`\`javascript * wa.chat.markPlayed('[message_id]'); * \`\`\` */ export const markPlayed = async ( messageId: string | MsgKey | MsgModel | Stringable, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MARK_PLAYED, body: messageId, }) } /** * Mute a chat, you can use duration or expiration * For expiration, use unix timestamp (seconds only) * For duration, use seconds * * @example * \`\`\`javascript * // Mute for 60 seconds * wa.chat.mute('[number]@c.us', {duration: 60}); * * // Mute util 2021-01-01 * wa.chat.mute('[number]@c.us', {expiration: 1641006000}); * * // or using date * const expiration = new Date('2022-01-01 00:00:00'); * wa.chat.mute('[number]@c.us', {expiration: expiration}); * \`\`\` * */ export const mute = async ( chatId: string | Wid, time: { expiration: number | Date } | { duration: number }, ): Promise<{ wid: Wid expiration: number isMuted: boolean }> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.MUTE, body: { chatId, time }, }) } /** * Unmute a chat * @example * \`\`\`javascript * wa.chat.unmute('[number]@c.us'); * \`\`\` */ export const unmute = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.UNMUTE, body: chatId, }) } /** * Open the chat in the WhatsApp interface in a specific message * * @example * \`\`\`javascript * await wa.chat.openChatAt('[number]@c.us', <message_id>); * \`\`\` * */ export const openChatAt = async ( chatId: string | Wid, messageId: string, ): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.OPEN_CHAT_AT, body: { chatId, messageId }, }) } /** * Open the chat in the WhatsApp interface in bottom position * * @example * \`\`\`javascript * await wa.chat.openChatBottom('[number]@c.us'); * \`\`\` * */ export const openChatBottom = async ( chatId: string, ): Promise<Response<any>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.OPEN_CHAT_BOTTOM, body: chatId, }) } /** * Open the chat in the WhatsApp interface from first unread message * * @example * \`\`\`javascript * await wa.chat.openChatFromUnread('[number]@c.us'); * \`\`\` * */ export const openChatFromUnread = async ( chatId: string | Wid, ): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.OPEN_CHAT_FROM_UNREAD, body: chatId, }) } /** * Pin a message in chat * * @example * \`\`\`javascript * // Pin a message in chat * wa.chat.pinMsg('true_[number]@c.us_ABCDEF'); * * // Pin a message in chat for 30 days * wa.chat.pinMsg('true_[number]@c.us_ABCDEF', 2592000); * * // Unpin a message * wa.chat.pinMsg('true_[number]@c.us_ABCDEF', false); * \`\`\` */ export const pinMsg = async ( msgId: string | MsgKey, pin = true, seconds = 604800, // default 7 days ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.PIN_MSG, body: { msgId, pin, seconds }, }) } /** * Set custom Chat list in panel of whatsapp * * @example * \`\`\`javascript * // Your custom list * wa.chat.setChatList('custom', ['number@c.us', 'number2@c.us']); * * // List only with unread chats * wa.chat.setChatList('unread'); * * // List only with favorites chats * wa.chat.setChatList('favorites'); * * // List only with groups chats * wa.chat.setChatList('group'); * * // List only labels chat * wa.chat.setChatList('labels', '454545_labelId'); * \`\`\` */ export const setChatList = async (type: string, ids?: string | string[]) => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.SET_CHAT_LIST, body: { type, ids }, }) } export const setInputText = async (text: string, chatId?: string | Wid) => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.SET_INPUT_TEXT, body: { text, chatId }, }) } /** * Set notes for a contact * Only when are connected with business device * @example * \`\`\`javascript * wa.chat.setNotes('[number]@c.us', 'Text for your notes'); * \`\`\` */ export const setNotes = async ( chatId: string | Wid, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Chat.SET_NOTES, body: { chatId, content }, }) } \`\`\` # src/libs/wa/conn.ts \`\`\`ts import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' /** * Alternative login method using code * Get the Link Device Code for Authentication using the phone number * * @example * \`\`\`javascript * const code = await wa.conn.genLinkDeviceCodeForPhoneNumber('[number]'); * * // Disable push notification * const code = await wa.conn.genLinkDeviceCodeForPhoneNumber('[number]', false); * \`\`\` */ export const genLinkDeviceCodeForPhoneNumber = async (): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Conn.GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER, }) } /** * Return the current auth code * * @example * \`\`\`javascript * const authCode = await wa.conn.getAuthCode(); * console.log(authCode.fullCode); // Output: a long string to generate a QRCode * \`\`\` */ export const getAuthCode = async (): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Conn.GET_AUTH_CODE, }) } export const getMyUserId = async (): Promise<Wid | undefined> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Conn.GET_MY_USER_ID, }) } \`\`\` # src/libs/wa/contact.ts \`\`\`ts import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ContactListOptions } from '@wppconnect/wa-js/dist/contact' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' /** * Get a contact by id * * @example * \`\`\`javascript * await wa.contact.get('[number]@c.us'); * \`\`\` * */ export const get = async (contactId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET, body: contactId, }) } /** * Get the current text status * * @example * \`\`\`javascript * const url = await wa.contact.getBusinessProfile('[number]@c.us'); * \`\`\` * */ export const getBusinessProfile = async ( contactId: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_BUSINESS_PROFILE, body: contactId, }) } /** * Get all commons groups for the contact * * @example * \`\`\`javascript * const groups_ids = await wa.contact.getCommonGroups('[number]@c.us'); * \`\`\` * */ export const getCommonGroups = async (wid: Wid | string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_COMMON_GROUPS, body: wid, }) } /** * Get the current text status * * @example * \`\`\`javascript * const url = await wa.contact.getProfilePictureUrl('[number]@c.us'); * \`\`\` * */ export const getProfilePictureUrl = async ( contactId: string | Wid, full = true, ): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_PROFILE_PICTURE_URL, body: { contactId, full }, }) } /** * Get the current text status * * @example * \`\`\`javascript * await wa.contact.getStatus('[number]@c.us'); * \`\`\` */ export const getStatus = async (contactId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.GET_STATUS, body: contactId, }) } export const list = async (options: ContactListOptions = {}): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.LIST, body: options, }) } export const isExist = async (contactId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Contact.IS_EXIST, body: contactId, }) } \`\`\` # src/libs/wa/group.ts \`\`\`ts import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ChatListOptions } from '@wppconnect/wa-js/dist/chat' import type { GroupProperty } from '@wppconnect/wa-js/dist/group' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' /** * Add one or more participants to a group * * The method return a object with the result of each participant as the key * * @example * \`\`\`javascript * const result = await wa.group.addParticipants('[group@g.us]', [number@c.us]); * * // Get participant result: * console.log(result['123@c.us'].code); * console.log(result['123@c.us'].invite_code); * console.log(result['123@c.us'].invite_code_exp); * console.log(result['123@c.us'].message); * console.log(result['123@c.us'].wid); * * const memberResult = result['123@c.us']; // To a variable * // or * const memberResult = Object.values(result)[0]; // Always the first member result * * // How to send a custom invite link * const link = 'https://chat.whatsapp.com/' + result['123@c.us'].invite_code; * console.log(link); * \`\`\` */ export const addParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.ADD_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Approve a membership request to group * * @example * \`\`\`javascript * await wa.group.approve(12345645@g.us, 5554999999999@c.us); * \`\`\` * */ export const approve = async ( groupId: string | Wid, membershipIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.APPROVE, body: { groupId, membershipIds }, }) } /** * Check if your account is allowed to add new participants * * @example * \`\`\`javascript * const result = await wa.group.canAdd('group@g.us'); * console.log(result); * \`\`\` */ export const canAdd = async (groupId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_ADD, body: groupId, }) } /** * Check if your account is allowed to demote participants * * @example * \`\`\`javascript * await wa.group.canDemote('group@g.us'); * console.log(result); * \`\`\` */ export const canDemote = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_DEMOTE, body: { groupId, participantsIds }, }) } /** * Check if your account is allowed to promote participants * * @example * \`\`\`javascript * await WPP.group.canPromote('group@g.us'); * console.log(result); * \`\`\` * */ export const canPromote = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_PROMOTE, body: { groupId, participantsIds }, }) } /** * Check if your account is allowed to remove participants * * @example * \`\`\`javascript * const result = await wa.group.canRemove('group@g.us'); * console.log(result); * \`\`\` */ export const canRemove = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CAN_REMOVE, body: { groupId, participantsIds }, }) } /** * Create a new group * * The method return a object with the result of each participant as the key * * @example * \`\`\`javascript * const result = await wa.group.create('Test Group', ['number@c.us']); * * console.log(result.gid.toString()); // Get the group ID * * // Get participant result: * console.log(result['number@c.us'].code); * console.log(result['number@c.us'].invite_code); * console.log(result['number@c.us'].invite_code_exp); * console.log(result['number@c.us'].message); * console.log(result['number@c.us'].wid); * * const memberResult = result['number@c.us']; // To a variable * // or * const memberResult = Object.values(result)[0]; // Always the first member result * * // How to send a custom invite link * const link = 'https://chat.whatsapp.com/' + result['number@c.us'].invite_code; * console.log(link); * * // Create a Subgroup for a community * const result = await wa.group.create('Test Group', ['number@c.us'], 'communit@g.us'); * \`\`\` */ export const create = async ( groupName: string, participantsIds: (string | Wid) | (string | Wid)[], parentGroup: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.CREATE, body: { groupName, participantsIds, parentGroup }, }) } /** * @example * \`\`\`javascript * // One member * await wa.group.demoteParticipants('123456@g.us', '123456@c.us'); * * // More than one member * await wa.group.demoteParticipants('123456@g.us', ['123456@c.us','123456@c.us']); * \`\`\` */ export const demoteParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.DEMOTE_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Get group info from an inviteCode * * @example * \`\`\`javascript * await wa.group.getGroupInfoFromInviteCode('<inviteCode>'); * \`\`\` */ export const getGroupInfoFromInviteCode = async ( inviteCode: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_GROUP_INFO_FROM_INVITE_CODE, body: inviteCode, }) } /** * Get the max number of participants for a group * * @example * \`\`\`javascript * const limit = await wa.group.getGroupSizeLimit(); * console.log(limit); * \`\`\` */ export const getGroupSizeLimit = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_GROUP_SIZE_LIMIT, body: {}, }) } export const list = async (options: ChatListOptions = {}): Promise<[]> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.LIST, }) } /** * @description Sends a request to the background script to get a group's invite link. * @param groupId The ID of the group (e.g., '1234567890@g.us'). * @returns A promise that resolves with the invite link string. */ export const getInviteLink = async (groupId: string): Promise<string> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_INVITE_LINK, body: { groupId }, }) } /** * Retrieve a lista of a membership approval requests * * @example * \`\`\`javascript * await wa.group.getMembershipRequests(12345645@g.us); * \`\`\` */ export const getMembershipRequests = async ( groupId: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_MEMBERSHIP_REQUESTS, body: groupId, }) } /** * Get an array of participants of a group * * @example * \`\`\`javascript * wa.group.getParticipants('[group-id]@g.us'); * \`\`\` */ export const getParticipants = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.GET_PARTICIPANTS, body: groupId, }) } export const iAmAdmin = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_ADMIN, body: groupId, }) } export const iAmMember = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_MEMBER, body: groupId, }) } export const iAmRestrictedMember = async ( groupId: string | Wid, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_RESTRICTED_MEMBER, body: groupId, }) } export const iAmSuperAdmin = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.IAM_SUPER_ADMIN, body: groupId, }) } /** * Join in a group from an invite code. * * @example * \`\`\`javascript * await wa.group.join('abcde....'); * \`\`\` */ export const join = async (inviteCode: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.JOIN, body: inviteCode, }) } /** * Leave from a group. * * @example * \`\`\`javascript * await wa.group.leave('[number]@g.us'); * \`\`\` */ export const leave = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.LEAVE, body: groupId, }) } /** * Promote group member to admin * * @example * \`\`\`javascript * // One member * await wa.group.promoteParticipants('123456@g.us', '123456@c.us'); * * // More than one member * await wa.group.promoteParticipants('123456@g.us', ['123456@c.us','123456@c.us']); * \`\`\` * * @category Group */ export const promoteParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.PROMOTE_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Reject a membership request to group * * @example * \`\`\`javascript * await wa.group.reject(12345645@g.us, 5554999999999@c.us); * \`\`\` */ export const reject = async ( groupId: string | Wid, membershipIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REJECT, body: { groupId, membershipIds }, }) } /** * Remove the group icon (group profile picture) * * @example * \`\`\`javascript * await wa.group.removeIcon('[group@g.us]'); * \`\`\` */ export const removeIcon = async (groupId: string | Wid): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REMOVE_ICON, body: groupId, }) } /** * Remove participants of a group * * @example * \`\`\`javascript * // One member * await wa.group.removeParticipants('123456@g.us', '123456@c.us'); * * // More than one member * await wa.group.removeParticipants('123456@g.us', ['123456@c.us','123456@c.us']); * \`\`\` */ export const removeParticipants = async ( groupId: string | Wid, participantsIds: (string | Wid) | (string | Wid)[], ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REMOVE_PARTICIPANTS, body: { groupId, participantsIds }, }) } /** * Revoke the current invite code and generate new one. * * @example * \`\`\`javascript * const code = WPP.group.revokeInviteCode('[group-id]@g.us'); * const link = 'https://chat.whatsapp.com/' + code; * \`\`\` */ export const revokeInviteCode = async (groupId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.REVOKE_INVITE_CODE, body: groupId, }) } /** * Define the group description * * @example * \`\`\`javascript * await wa.group.setDescription('[group-id]@g.us', 'new group description'); * \`\`\` */ export const setDescription = async ( groupId: string | Wid, description: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_DESCRIPTION, body: { groupId, description }, }) } /** * Set the group icon (group profile picture) * * @example * \`\`\`javascript * await wa.group.setIcon('[group@g.us]', 'data:image/jpeg;base64,.....'); * \`\`\` */ export const setIcon = async ( groupId: string | Wid, content: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_ICON, body: { groupId, content }, }) } /** * Set the group property * * @example * \`\`\`javascript * // Only admins can send message * await wa.group.setProperty('[group-id]@g.us', 'announcement', true); * * // All can send message * await wa.group.setProperty('[group-id]@g.us', 'announcement', false); * * // Disatble temporary messages * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 0); * * // Enable temporary messages for 24 hours * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 86400); * * // Enable temporary messages for 7 days * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 604800); * * // Enable temporary messages for 90 days * await wa.group.setProperty('[group-id]@g.us', 'ephemeral', 7776000); * * // Only admins can edit group properties * await wa.group.setProperty('[group-id]@g.us', 'restrict', true); * * // All can edit group properties * await wa.group.setProperty('[group-id]@g.us', 'restrict', false); * \`\`\` */ export const setProperty = async ( groupId: string | Wid, property: GroupProperty, value: 0 | 1 | 86400 | 604800 | 7776000 | boolean, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_PROPERTY, body: { groupId, property, value }, }) } /** * Define the group subject * * @example * \`\`\`javascript * await wa.group.setSubject('[group-id]@g.us', 'new group subject'); * \`\`\` */ export const setSubject = async ( groupId: string | Wid, subject: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Group.SET_SUBJECT, body: { groupId, subject }, }) } \`\`\` # src/libs/wa/index.ts \`\`\`ts import * as blocklist from './blocklist' import * as chat from './chat' import * as conn from './conn' import * as contact from './contact' import * as group from './group' import * as on from './on' import * as send from './send' import * as status from './status' export default { on, conn, send, contact, chat, group, status, blocklist, } \`\`\` # src/libs/wa/newsletter.ts \`\`\`ts import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' /** * Create a newsletter * * @example * \`\`\`javascript * // To edit name * wa.newsletter.create('Name for your newsletter', { * description: 'Description for that', * picture: '<base64_string', * }); * \`\`\` */ export const create = async ( name: string, opts: { description?: string; picture?: string }, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.CREATE, body: { name, opts }, }) } /** * Delete a newsletter * * @example * \`\`\`javascript * const code = wa.newsletter.destroy('[newsletter-id]@newsletter'); * \`\`\` */ export const destroy = async (id: string): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.DESTROY, body: id, }) } /** * Edit the newsletter data * * @example * \`\`\`javascript * // To edit name * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * name: 'New Name' * }); * * // To edit description * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * description: 'New description' * }); * * // To change picture * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * picture: '<base64_image>' * }); * * // To remove picture * const code = wa.newsletter.edit('[newsletter-id]@newsletter', { * picture: null * }); * \`\`\` */ export const edit = async ( newsletterId: string, opts: { name?: string description?: string picture?: string }, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.EDIT, body: { newsletterId, opts }, }) } /** * Get subscribers of a newsletters * * @example * \`\`\`javascript * const code = wa.newsletter.getSubscribers('[newsletter-id]@newsletter'); * \`\`\` */ export const getSubscribers = async (id: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.GET_SUBSCRIBERS, body: id, }) } /** * Mute and unmute a newsletter * * @example * // Mute * \`\`\`javascript * wa.newsletter.mute('[newsletter-id]@newsletter', true); * \`\`\` * * // Unmute * \`\`\`javascript * wa.newsletter.mute('[newsletter-id]@newsletter', false); * \`\`\` */ export const mute = async ( newsletterId: string, value?: boolean, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Newsletter.MUTE, body: { newsletterId, value }, }) } \`\`\` # src/libs/wa/on.ts \`\`\`ts export const ready = (callback = () => {}) => { const targetSelector = '#side' const node = document.querySelector(targetSelector) if (node) { require('@wppconnect/wa-js/dist/wppconnect-wa') callback() return } // Wait for the node to appear only once const observer = new MutationObserver(() => { const el = document.querySelector(targetSelector) if (el) { console.log('âœ…âœ…âœ…âœ…âœ…') observer.disconnect() // stop watching require('@wppconnect/wa-js/dist/wppconnect-wa') callback() } }) observer.observe(document.body, { childList: true, subtree: true, }) } \`\`\` # src/libs/wa/profile.ts \`\`\`ts import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { BusinessProfileModel } from '@wppconnect/wa-js/dist/whatsapp' /** * Update your business profile * * @example * \`\`\`javascript * await wa.profile.editBusinessProfile({description: 'New description for profile'}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({categories: { id: "133436743388217", localized_display_name: "Artes e entretenimento", not_a_biz: false, }}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({adress: 'Street 01, New York'}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({adress: 'Street 01, New York'}); * \`\`\` * * \`\`\`javascript * await wa.profile.editBusinessProfile({email: 'test@test.com.br'}); * \`\`\` * * Change website of profile (max 2 sites) * \`\`\`javascript * await wa.profile.editBusinessProfile({website: [ "https://www.wppconnect.io", "https://www.teste2.com.br", ]}); * \`\`\` * * Change businessHours for Specific Hours * \`\`\`javascript * await wa.profile.editBusinessProfile({ businessHours: { * { tue: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, wed: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, thu: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, fri: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, sat: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, sun: { mode: "specific_hours", hours: [ [ 540, 1080, ], ], }, } }, timezone: "America/Sao_Paulo" }); * * Change businessHours for Always Opened * \`\`\`javascript * await wa.profile.editBusinessProfile({ businessHours: { { mon: { mode: "open_24h", }, tue: { mode: "open_24h", }, wed: { mode: "open_24h", }, thu: { mode: "open_24h", }, fri: { mode: "open_24h", }, sat: { mode: "open_24h", }, sun: { mode: "open_24h", }, } timezone: "America/Sao_Paulo" }); * * Change businessHours for Appointment Only * \`\`\`javascript * await wa.profile.editBusinessProfile({ businessHours: { { mon: { mode: "appointment_only", }, tue: { mode: "appointment_only", }, wed: { mode: "appointment_only", }, thu: { mode: "appointment_only", }, fri: { mode: "appointment_only", }, sat: { mode: "appointment_only", }, sun: { mode: "appointment_only", }, } timezone: "America/Sao_Paulo" }); * * */ export const editBusinessProfile = async ( params: BusinessProfileModel, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.EDIT_BUSINESS_PROFILE, body: params, }) } /** * Get your current profile name * * @example * \`\`\`javascript * const myProfileName = wa.profile.getMyProfileName(); * \`\`\` */ export const getMyProfileName = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.GET_MY_PROFILE_NAME, body: {}, }) } /** * Get your current profile picture * * @example * \`\`\`javascript * await wa.profile.getMyProfilePicture(); * \`\`\` */ export const getMyProfilePicture = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.GET_MY_PROFILE_PICTURE, body: {}, }) } /** * Get your current text status * * @example * \`\`\`javascript * await wa.profile.getMyStatus(); * \`\`\` */ export const getMyStatus = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.GET_MY_STATUS, body: {}, }) } /** * Return the current logged user is Bussiness or not * * @example * \`\`\`javascript * wa.profile.isBusiness(); * \`\`\` */ export const isBusiness = async (): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.IS_BUSINESS, body: {}, }) } /** * Remove your profile picture * * @example * \`\`\`javascript * await wa.profile.removeMyProfilePicture(); * \`\`\` */ export const removeMyProfilePicture = async (): Promise<boolean> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.REMOVE_MY_PROFILE_PICTURE, body: {}, }) } /** * Update your current profile name * * @example * \`\`\`javascript * await wa.profile.setMyProfileName('My new name'); * \`\`\` */ export const setMyProfileName = async (name: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.SET_MY_PROFILE_NAME, body: {}, }) } /** * Update your profile picture * * @example * \`\`\`javascript * await wa.profile.setMyProfilePicture('data:image/jpeg;base64,.....'); * \`\`\` */ export const setMyProfilePicture = async (content: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.SET_MY_PROFILE_PICTURE, body: content, }) } /** * Update your current text status * * @example * \`\`\`javascript * await wa.profile.setMyStatus('Example text'); * \`\`\` */ export const setMyStatus = async (statusText: string): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Profile.SET_MY_STATUS, body: statusText, }) } \`\`\` # src/libs/wa/send.ts \`\`\`ts import { Action } from '@/constants' import type { Response } from '@/types' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { AudioMessageOptions, AutoDetectMessageOptions, DocumentMessageOptions, ImageMessageOptions, LocationMessageOptions, PoolMessageOptions, SendMessageOptions, StickerMessageOptions, TextMessageOptions, VCardContact, VideoMessageOptions, } from '@wppconnect/wa-js/dist/chat' import type { Wid } from '@wppconnect/wa-js/dist/whatsapp' import type { SendMsgResult } from '@wppconnect/wa-js/dist/whatsapp/enums' export const text = async ( chatId: any, content: any, options: TextMessageOptions = {}, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.TEXT, body: { chatId, content, options, }, }) } export const file = async ( chatId: string | Wid, content: string | Blob | File, options: | AutoDetectMessageOptions | AudioMessageOptions | DocumentMessageOptions | ImageMessageOptions | VideoMessageOptions | StickerMessageOptions | TextMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.FILE, body: { chatId, content, options, }, }) } export const location = async ( chatId: string | Wid, options: LocationMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.LOCATION, body: { chatId, options, }, }) } export const poll = async ( chatId: any, name: string, choices: string[], options?: PoolMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.POLL, body: { chatId, name, choices, options, }, }) } export const vcard = async ( chatId: string | Wid, contacts: string | Wid | VCardContact | (string | Wid | VCardContact)[], options?: SendMessageOptions, ): Promise<Response<SendMsgResult>> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Send.VCARD, body: { chatId, contacts, options, }, }) } \`\`\` # src/libs/wa/status.ts \`\`\`ts import { Action } from '@/constants' import { sendToBackgroundViaRelay } from '@plasmohq/messaging' import type { ImageStatusOptions, TextStatusOptions, VideoStatusOptions, } from '@wppconnect/wa-js/dist/status' import type { MsgKey, Wid } from '@wppconnect/wa-js/dist/whatsapp' export const get = async (chatId: string | Wid): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.GET, body: chatId, }) } export const getMyStatus = async (): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.GET_MY_STATUS, body: {}, }) } export const remove = async (msgId: string | MsgKey): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.REMOVE, body: msgId, }) } /** * Send a image message to status stories * * @example * \`\`\`javascript * wa.status.sendImageStatus('data:image/jpeg;base64,<a long base64 file...>'); * \`\`\` */ export const sendImageStatus = async ( content: any, options: ImageStatusOptions = {}, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_IMAGE_STATUS, body: { content, options }, }) } /** * Mark status as read/seen * * @example * \`\`\`javascript * wa.status.sendReadStatus('[phone_number]@c.us', 'false_status@broadcast_3A169E0FD4BC6E92212F_5521526232927@c.us'); * \`\`\` */ export const sendReadStatus = async ( chatId: string | Wid, statusId: string, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_READ_STATUS, body: { chatId, statusId }, }) } /** * Send a text message to status stories * * @example * \`\`\`javascript * wa.status.sendTextStatus(`Bootstrap primary color: #0275d8`, { backgroundColor: '#0275d8', font: 2}); * \`\`\` */ export const sendTextStatus = async ( content: any, options: TextStatusOptions = {}, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_TEXT_STATUS, body: { content, options }, }) } /** * Send a video message to status stories * * @example * \`\`\`javascript * wa.status.sendVideoStatus('data:video/mp4;base64,<a long base64 file...>'); * \`\`\` */ export const sendVideoStatus = async ( content: any, options: VideoStatusOptions = {}, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.SEND_VIDEO_STATUS, body: { content, options }, }) } /** * Define a custom list of participants to send the status message * * @example * \`\`\`javascript * // Use a custom list * await wa.status.updateParticipants(['123@c.us', '456@c.us']); * // Use the contacts by default * await wa.status.updateParticipants(null); * \`\`\` */ export const updateParticipants = async ( ids?: (string | Wid)[] | null, ): Promise<any> => { return await sendToBackgroundViaRelay({ //@ts-ignore name: Action.Status.UPDATE_PARTICIPANTS, body: ids, }) } \`\`\` # src/relays/blocklist.relay.ts \`\`\`ts import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const all = () => { relay( { name: Action.Blocklist.ALL, }, async ({ body }) => { return WPP.blocklist.all() }, ) } const blockContact = () => { relay( { name: Action.Blocklist.BLOCK_CONTACT, }, async ({ body }) => { return await WPP.blocklist.blockContact(body) }, ) } const isBlocked = () => { relay( { name: Action.Blocklist.IS_BLOCKED, }, async ({ body }) => { return WPP.blocklist.isBlocked(body) }, ) } const unblockContact = () => { relay( { name: Action.Blocklist.UNBLOCK_CONTACT, }, async ({ body }) => { return WPP.blocklist.unblockContact(body) }, ) } const initBlocklistRelays = () => { all() blockContact() isBlocked() unblockContact() } export default initBlocklistRelays \`\`\` # src/relays/cart.relay.ts \`\`\`ts import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const add = () => { relay( { name: Action.Cart.ADD, }, async ({ body }) => { const { chatId, products } = body return await WPP.cart.add(chatId, products) }, ) } const clear = () => { relay( { name: Action.Cart.CLEAR, }, async ({ body }) => { return await WPP.cart.clear(body) }, ) } const get = () => { relay( { name: Action.Cart.GET, }, async ({ body }) => { return WPP.cart.get(body) }, ) } const getThumbFromCart = () => { relay( { name: Action.Cart.GET_THUMB_FROM_CART, }, async ({ body }) => { return await WPP.cart.getThumbFromCart(body) }, ) } const remove = () => { relay( { name: Action.Cart.REMOVE, }, async ({ body }) => { const { chatId, productId } = body return WPP.cart.remove(chatId, productId) }, ) } const submit = () => { relay( { name: Action.Cart.SUBMIT, }, async ({ body }) => { const { wid, msg, options } = body return WPP.cart.submit(wid, msg, options) }, ) } const update = () => { relay( { name: Action.Cart.SUBMIT, }, async ({ body }) => { const { chatId, productId, options } = body return WPP.cart.update(chatId, productId, options) }, ) } const initCartRelays = () => { add() clear() get() getThumbFromCart() remove() submit() update() } export default initCartRelays \`\`\` # src/relays/catalog.relay.ts \`\`\`ts import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const addProductImage = () => { relay( { name: Action.Catalog.ADD_PRODUCT_IMAGE, }, async ({ body }) => { const { productId, content } = body return await WPP.catalog.addProductImage(productId, content) }, ) } const changeProductImage = () => { relay( { name: Action.Catalog.CHANGE_PRODUCT_IMAGE, }, async ({ body }) => { const { productId, content } = body return await WPP.catalog.changeProductImage(productId, content) }, ) } const createCollection = () => { relay( { name: Action.Catalog.CREATE_COLLECTION, }, async ({ body }) => { const { collectionName, productsId } = body return await WPP.catalog.createCollection(collectionName, productsId) }, ) } const createProduct = () => { relay( { name: Action.Catalog.CREATE_COLLECTION, }, async ({ body }) => { return await WPP.catalog.createProduct(body) }, ) } const deleteCollection = () => { relay( { name: Action.Catalog.DELETE_COLLECTION, }, async ({ body }) => { return await WPP.catalog.deleteCollection(body) }, ) } const deleteProduct = () => { relay( { name: Action.Catalog.DELETE_PRODUCT, }, async ({ body }) => { return await WPP.catalog.delProducts(body) }, ) } const editCollection = () => { relay( { name: Action.Catalog.EDIT_COLLECTION, }, async ({ body }) => { const { collectionId, params } = body return await WPP.catalog.editCollection(collectionId, params) }, ) } const editProduct = () => { relay( { name: Action.Catalog.EDIT_PRODUCT, }, async ({ body }) => { const { productId, params } = body return await WPP.catalog.editProduct(productId, params) }, ) } const getCollections = () => { relay( { name: Action.Catalog.GET_COLLECTIONS, }, async ({ body }) => { const { chatId, qnt, productsCount } = body return await WPP.catalog.getCollections(chatId, qnt, productsCount) }, ) } /** * Get your current catalog * * @example * \`\`\`javascript * // Get your current catalog * const myCatalog = await wa.catalog.getMyCatalog(); * \`\`\` */ const getMyCatalog = () => { relay( { name: Action.Catalog.GET_MY_CATALOG, }, async ({ body }) => { return await WPP.catalog.getMyCatalog() }, ) } const getProductById = () => { relay( { name: Action.Catalog.GET_PRODUCT_BY_ID, }, async ({ body }) => { const { chatId, productId } = body return await WPP.catalog.getProductById(chatId, productId) }, ) } const getProducts = () => { relay( { name: Action.Catalog.GET_PRODUCTS, }, async ({ body }) => { const { chatId, qnt } = body return await WPP.catalog.getProducts(chatId, qnt) }, ) } const removeProductImage = () => { relay( { name: Action.Catalog.REMOVE_PRODUCT_IMAGE, }, async ({ body }) => { const { productId, index } = body return await WPP.catalog.removeProductImage(productId, index) }, ) } const setProductVisibility = () => { relay( { name: Action.Catalog.SET_PRODUCT_VISIBILITY, }, async ({ body }) => { const { productId, isHidden } = body return await WPP.catalog.setProductVisibility(productId, isHidden) }, ) } const updateCartEnabled = () => { relay( { name: Action.Catalog.UPDAGE_CART_ENABLED, }, async ({ body }) => { return await WPP.catalog.updateCartEnabled(body) }, ) } const initCatalogRelays = () => { addProductImage() changeProductImage() createCollection() createProduct() deleteCollection() deleteProduct() editCollection() editProduct() getCollections() getMyCatalog() getProductById() getProducts() removeProductImage() setProductVisibility() updateCartEnabled() } export default initCatalogRelays \`\`\` # src/relays/chat.relay.ts \`\`\`ts import { Action } from '@/constants' import { response } from '@/utils/response' import serialize from '@/utils/serialize' import { relay } from '@plasmohq/messaging/relay' const archive = () => { relay( { name: Action.Chat.ARCHIVE, }, async ({ body }) => { const { chatId, archive } = body return await WPP.chat.archive(chatId, archive) }, ) } const pin = () => { relay( { name: Action.Chat.PIN, }, async ({ body }) => { try { const { chatId, pin } = body await WPP.chat.pin(chatId, pin) return true } catch (error) { return false } }, ) } const canMarkPlayed = () => { relay( { name: Action.Chat.CAN_MARK_PLAYED, }, async ({ body }) => { return await WPP.chat.canMarkPlayed(body) }, ) } const canMute = () => { relay( { name: Action.Chat.CAN_MUTE, }, async ({ body }) => { return WPP.chat.canMute(body) }, ) } const canReply = () => { relay( { name: Action.Chat.CAN_REPLY, }, async ({ body }) => { return await WPP.chat.canReply(body) }, ) } const clear = () => { relay( { name: Action.Chat.CLEAR, }, async ({ body }) => { return await WPP.chat.clear(body) }, ) } const closeChat = () => { relay( { name: Action.Chat.CLOSE_CHAT, }, async ({ body }) => { return await WPP.chat.closeChat() }, ) } const _delete = () => { relay( { name: Action.Chat.DELETE, }, async ({ body }) => { return await WPP.chat.delete(body) }, ) } const deleteMessage = () => { relay( { name: Action.Chat.DELETE_MESSAGE, }, async ({ body }) => { const { chatId, ids, deleteMediaInDevice, revoke } = body return await WPP.chat.deleteMessage( chatId, ids, deleteMediaInDevice, revoke, ) }, ) } const list = () => { relay( { name: Action.Chat.LIST, }, async ({ body }) => { return (await WPP.chat.list(body)).map(serialize.chat) }, ) } const find = () => { relay( { name: Action.Chat.FIND, }, async (req) => { try { const chatId = req.body const chat = await WPP.chat.find(chatId) return response.success(serialize.chat(chat)) } catch (error) { return response.error(error.message) } }, ) } const forwardMessage = () => { relay( { name: Action.Chat.FORWARD_MESSAGE, }, async ({ body }) => { const { toChatId, msgId, options } = body return await WPP.chat.forwardMessage(toChatId, msgId, options) }, ) } const get = () => { relay( { name: Action.Chat.GET, }, async ({ body }) => { try { const chat = WPP.chat.get(body) return serialize.chat(chat) } catch (error) {} }, ) } const getActiveChat = () => { relay( { name: Action.Chat.GET_ACTIVE_CHAT, }, async (req) => { try { const chat = WPP.chat.getActiveChat() if (!chat) { return null } return serialize.chat(chat) } catch (error) { return null } }, ) } const getLastSeen = () => { relay( { name: Action.Chat.GET_LAST_SEEN, }, async ({ body }) => { return await WPP.chat.getLastSeen(body) }, ) } const getMessageACK = () => { relay( { name: Action.Chat.GET_MESSAGE_ACK, }, async ({ body }) => { return await WPP.chat.getMessageACK(body) }, ) } const getMessages = () => { relay( { name: Action.Chat.GET_MESSAGES, }, async ({ body }) => { const { chatId, options } = body const messages = await WPP.chat.getMessages(chatId, options) return messages.map(serialize.message) }, ) } const getNotes = () => { relay( { name: Action.Chat.GET_NOTES, }, async ({ body }) => { return await WPP.chat.getNotes(body) }, ) } const getPlatformFromMessage = () => { relay( { name: Action.Chat.GET_PLATFORM_MESSAGE, }, async ({ body }) => { return WPP.chat.getPlatformFromMessage(body) }, ) } const markIsComposing = () => { relay( { name: Action.Chat.MARK_IS_COMPOSING, }, async ({ body }) => { const { chatId, duration } = body return WPP.chat.markIsComposing(chatId, duration) }, ) } const markIsPaused = () => { relay( { name: Action.Chat.MARK_IS_PAUSED, }, async ({ body }) => { return await WPP.chat.markIsPaused(body) }, ) } const markIsRead = () => { relay( { name: Action.Chat.MARK_IS_READ, }, async ({ body }) => { return await WPP.chat.markIsRead(body) }, ) } const markIsRecording = () => { relay( { name: Action.Chat.MARK_IS_RECORDING, }, async ({ body }) => { return await WPP.chat.markIsRecording(body) }, ) } const markIsUnread = () => { relay( { name: Action.Chat.MARK_IS_UNREAD, }, async ({ body }) => { return await WPP.chat.markIsUnread(body) }, ) } const markPlayed = () => { relay( { name: Action.Chat.MARK_PLAYED, }, async ({ body }) => { return await WPP.chat.markPlayed(body) }, ) } const mute = () => { relay( { name: Action.Chat.MUTE, }, async ({ body }) => { const { chatId, time } = body return await WPP.chat.mute(chatId, time) }, ) } const unmute = () => { relay( { name: Action.Chat.UNMUTE, }, async ({ body }) => { return await WPP.chat.unmute(body) }, ) } const openChatAt = () => { relay( { name: Action.Chat.OPEN_CHAT_AT, }, async ({ body }) => { const { chatId, messageId } = body return await WPP.chat.openChatAt(chatId, messageId) }, ) } const openChatFromUnread = () => { relay( { name: Action.Chat.OPEN_CHAT_FROM_UNREAD, }, async ({ body }) => { return await WPP.chat.openChatFromUnread(body) }, ) } const pinMsg = () => { relay( { name: Action.Chat.PIN_MSG, }, async ({ body }) => { const { msgId, pin, seconds } = body return await WPP.chat.pinMsg(msgId, pin, seconds) }, ) } const openChatBottom = () => { relay( { name: Action.Chat.OPEN_CHAT_BOTTOM, }, async (req) => { try { const chatId = req.body return await WPP.chat.openChatBottom(chatId) } catch (error) { return false } }, ) } const setChatList = () => { relay( { name: Action.Chat.SET_CHAT_LIST, }, async (req) => { try { const { type, ids } = req.body await WPP.chat.setChatList(type, ids) } catch (error) { console.error(`setChatList: ${error}`) } }, ) } const setInputText = () => { relay( { name: Action.Chat.SET_INPUT_TEXT, }, async ({ body }) => { const { text, chatId } = body return await WPP.chat.setInputText(text, chatId) }, ) } const setNotes = () => { relay( { name: Action.Chat.SET_NOTES, }, async ({ body }) => { const { chatId, content } = body return await WPP.chat.setNotes(chatId, content) }, ) } const downloadMedia = () => { relay( { name: Action.Chat.DOWNLOAD_MEDIA, }, async ({ body: messageId }) => { try { const media = await Promise.race([ WPP.chat.downloadMedia(messageId), new Promise((_, reject) => setTimeout(() => reject(new Error('Error download media')), 3000), ), ]) return media } catch (error) { return null } }, ) } const initChatRelay = () => { archive() pin() canMarkPlayed() canMute() canReply() clear() closeChat() _delete() deleteMessage() downloadMedia() find() forwardMessage() get() getActiveChat() getLastSeen() getMessageACK() getMessages() getNotes() getPlatformFromMessage() markIsComposing() markIsPaused() markIsRead() markIsRecording() markIsUnread() markPlayed() mute() unmute() list() openChatBottom() openChatAt() openChatFromUnread() pinMsg() setChatList() setInputText() setNotes() } export default initChatRelay \`\`\` # src/relays/community.relay.ts \`\`\`ts import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const all = () => { relay( { name: Action.Blocklist.ALL, }, async ({ body }) => { return WPP.blocklist.all() }, ) } const initCommunityRelays = () => { all() } export default initCommunityRelays \`\`\` # src/relays/conn.relay.ts \`\`\`ts import { Account, Action } from '@/constants' import { delay } from '@/utils/util' import { relay } from '@plasmohq/messaging/relay' import _ from 'lodash' const genLinkDeviceCodeForPhoneNumber = () => { relay( { name: Action.Conn.GEN_LINK_DEVICE_CODE_FOR_PHONE_NUMBER, }, async ({ body }) => { const { phone, sendPushNotification } = body return await WPP.conn.genLinkDeviceCodeForPhoneNumber( phone, sendPushNotification, ) }, ) } const getAuthCode = () => { relay( { name: Action.Conn.GET_AUTH_CODE, }, async ({ body }) => { return await WPP.conn.getAuthCode() }, ) } const getMyUserId = () => { relay( { name: Action.Conn.GET_MY_USER_ID, }, async (req) => { return WPP.conn.getMyUserId() }, ) } const getProfile = () => { relay( { name: Action.Conn.GET_PROFILE, }, async (req) => { await delay(1000) const { user: number } = WPP.conn.getMyUserId() const contact = await WPP.contact.get(`${number}@c.us`) const countryCode = await WPP.whatsapp.functions.getCountryShortcodeByPhone(contact.id.user) return { name: contact.pushname || contact.formattedName || contact.name || contact.verifiedName, number, type: contact.isBusiness ? Account.BUSINESS : Account.PERSONAL, } }, ) } const initConnRelays = () => { genLinkDeviceCodeForPhoneNumber() getAuthCode() getMyUserId() getProfile() } export default initConnRelays \`\`\` # src/relays/contact.relay.ts \`\`\`ts import { Action } from '@/constants' import filterBy from '@/utils/filterBy' import serialize from '@/utils/serialize' import { relay } from '@plasmohq/messaging/relay' const get = () => { relay( { name: Action.Contact.GET, }, async ({ body }) => { return await WPP.contact.get(body) }, ) } const getBusinessProfile = () => { relay( { name: Action.Contact.GET_BUSINESS_PROFILE, }, async ({ body }) => { return await WPP.contact.get(body) }, ) } const getCommonGroups = () => { relay( { name: Action.Contact.GET_COMMON_GROUPS, }, async ({ body }) => { return await WPP.contact.get(body) }, ) } const getProfilePictureUrl = () => { relay( { name: Action.Contact.GET_PROFILE_PICTURE_URL, }, async ({ body }) => { const { contactId, full } = body return await WPP.contact.getProfilePictureUrl(contactId, full) }, ) } const getStatus = () => { relay( { name: Action.Contact.GET_STATUS, }, async ({ body }) => { return await WPP.contact.getStatus(body) }, ) } const list = () => { relay( { name: Action.Contact.LIST, }, async (req) => { const options = req.body const contacts = ((await WPP.contact.list(options)) ?? []).map( serialize.contact, ) return contacts }, ) } const isExist = () => { relay( { name: Action.Contact.IS_EXIST, }, async (req) => { try { const contactId = req.body const result = await WPP.contact.queryExists(contactId) return !!result?.wid } catch (error) { return false } }, ) } const initContactRelay = () => { get() getBusinessProfile() getCommonGroups() getProfilePictureUrl() getStatus() isExist() list() } export default initContactRelay \`\`\` # src/relays/group.relay.ts \`\`\`ts import { Action } from '@/constants' import serialize from '@/utils/serialize' import { relay } from '@plasmohq/messaging/relay' import { contact } from '@wppconnect/wa-js' import _ from 'lodash' const addParticipants = () => { relay( { name: Action.Group.ADD_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.addParticipants(groupId, participantsIds) }, ) } const approve = () => { relay( { name: Action.Group.APPROVE, }, async ({ body }) => { const { groupId, membershipIds } = body return await WPP.group.approve(groupId, membershipIds) }, ) } const canAdd = () => { relay( { name: Action.Group.CAN_ADD, }, async ({ body }) => { return await WPP.group.canAdd(body) }, ) } const canDemote = () => { relay( { name: Action.Group.CAN_DEMOTE, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.canDemote(groupId, participantsIds) }, ) } const canPromote = () => { relay( { name: Action.Group.CAN_PROMOTE, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.canPromote(groupId, participantsIds) }, ) } const canRemove = () => { relay( { name: Action.Group.CAN_REMOVE, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.canRemove(groupId, participantsIds) }, ) } const create = () => { relay( { name: Action.Group.CREATE, }, async ({ body }) => { const { groupName, participantsIds, parentGroup } = body return await WPP.group.create(groupName, participantsIds, parentGroup) }, ) } const demoteParticipants = () => { relay( { name: Action.Group.DEMOTE_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.demoteParticipants(groupId, participantsIds) }, ) } const getGroupInfoFromInviteCode = () => { relay( { name: Action.Group.GET_GROUP_INFO_FROM_INVITE_CODE, }, async ({ body }) => { return await WPP.group.getGroupInfoFromInviteCode(body) }, ) } const getGroupSizeLimit = () => { relay( { name: Action.Group.GET_GROUP_SIZE_LIMIT, }, async ({ body }) => { return await WPP.group.getGroupSizeLimit() }, ) } const list = () => { relay( { name: Action.Group.LIST, }, async ({ body }) => { try { const me = WPP.conn.getMyUserId() const groups = (await WPP.chat.list({ onlyGroups: true })).map( (group) => { const participants = group.groupMetadata.participants .getModelsArray() .map(serialize.participant) const id = `${group.id.user}@${group.id.server}` return { id, name: group.name || group.formattedTitle, desc: group.groupMetadata?.desc, avatar: group.contact?.getProfilePicThumb().__x_eurl, size: group.groupMetadata?.size, participants, isAdmin: group.groupMetadata?.participants?.iAmAdmin(), isSuperAdmin: group.groupMetadata?.participants?.iAmSuperAdmin(), type: group.groupMetadata.groupType, } }, ) return _.sortBy(groups, 'name') } catch (error) { return [] } }, ) } const getInviteLink = () => { relay( { name: Action.Group.GET_INVITE_LINK, }, async (req) => { try { const { groupId } = req.body const link = await WPP.group.getInviteCode(groupId) return `https://chat.whatsapp.com/${link}` } catch (error) { console.error(`getInviteLink relay error: ${error}`) return null } }, ) } const getMembershipRequests = () => { relay( { name: Action.Group.GET_MEMBERSHIP_REQUESTS, }, async ({ body }) => { return await WPP.group.getMembershipRequests(body) }, ) } const getParticipants = () => { relay( { name: Action.Group.GET_PARTICIPANTS, }, async ({ body }) => { try { const participants = await WPP.group.getParticipants(body) return participants.map(serialize.participant) } catch (error) { return [] } }, ) } const iAmAdmin = () => { relay( { name: Action.Group.IAM_ADMIN, }, async ({ body }) => { return await WPP.group.iAmAdmin(body) }, ) } const iAmMember = () => { relay( { name: Action.Group.IAM_MEMBER, }, async ({ body }) => { return await WPP.group.iAmMember(body) }, ) } const iAmRestrictedMember = () => { relay( { name: Action.Group.IAM_RESTRICTED_MEMBER, }, async ({ body }) => { return await WPP.group.iAmRestrictedMember(body) }, ) } const iAmSuperAdmin = () => { relay( { name: Action.Group.IAM_SUPER_ADMIN, }, async ({ body }) => { return await WPP.group.iAmSuperAdmin(body) }, ) } const join = () => { relay( { name: Action.Group.JOIN, }, async ({ body }) => { return await WPP.group.join(body) }, ) } const leave = () => { relay( { name: Action.Group.LEAVE, }, async ({ body }) => { return await WPP.group.leave(body) }, ) } const promoteParticipants = () => { relay( { name: Action.Group.PROMOTE_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.promoteParticipants(groupId, participantsIds) }, ) } const reject = () => { relay( { name: Action.Group.REJECT, }, async ({ body }) => { const { groupId, membershipIds } = body return await WPP.group.reject(groupId, membershipIds) }, ) } const removeIcon = () => { relay( { name: Action.Group.REMOVE_ICON, }, async ({ body }) => { return await WPP.group.removeIcon(body) }, ) } const removeParticipants = () => { relay( { name: Action.Group.REMOVE_PARTICIPANTS, }, async ({ body }) => { const { groupId, participantsIds } = body return await WPP.group.removeParticipants(groupId, participantsIds) }, ) } const revokeInviteCode = () => { relay( { name: Action.Group.REVOKE_INVITE_CODE, }, async ({ body }) => { return await WPP.group.revokeInviteCode(body) }, ) } const setDescription = () => { relay( { name: Action.Group.SET_DESCRIPTION, }, async ({ body }) => { const { groupId, description } = body return await WPP.group.setDescription(groupId, description) }, ) } const setIcon = () => { relay( { name: Action.Group.SET_ICON, }, async ({ body }) => { const { groupId, content } = body return await WPP.group.setIcon(groupId, content) }, ) } const setProperty = () => { relay( { name: Action.Group.SET_PROPERTY, }, async ({ body }) => { const { groupId, property, value } = body return await WPP.group.setProperty(groupId, property, value) }, ) } const setSubject = () => { relay( { name: Action.Group.SET_SUBJECT, }, async ({ body }) => { const { groupId, subject } = body return await WPP.group.setSubject(groupId, subject) }, ) } const initGroupRelay = () => { addParticipants() approve() canAdd() canDemote() canPromote() canRemove() create() demoteParticipants() getInviteLink() getGroupInfoFromInviteCode() getGroupSizeLimit() getMembershipRequests() getParticipants() list() iAmAdmin() iAmMember() iAmRestrictedMember() iAmSuperAdmin() join() leave() promoteParticipants() reject() removeIcon() removeParticipants() revokeInviteCode() setDescription() setIcon() setProperty() setSubject() } export default initGroupRelay \`\`\` # src/relays/index.ts \`\`\`ts import initBlocklistRelays from './blocklist.relay' import initCartRelays from './cart.relay' import initChatRelay from './chat.relay' import initConnRelays from './conn.relay' import initContactRelay from './contact.relay' import initGroupRelay from './group.relay' import initSendRelay from './send.relay' import initStatusRelay from './status.relay' export const initInjectScriptRelays = () => { initBlocklistRelays() initCartRelays() initChatRelay() initConnRelays() initContactRelay() initGroupRelay() initSendRelay() initStatusRelay() } \`\`\` # src/relays/newsletter.relay.ts \`\`\`ts import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const create = () => { relay( { name: Action.Newsletter.CREATE, }, async ({ body }) => { const { name, opts } = body return await WPP.newsletter.create(name, opts) }, ) } const destroy = () => { relay( { name: Action.Newsletter.DESTROY, }, async ({ body }) => { return await WPP.newsletter.destroy(body) }, ) } const edit = () => { relay( { name: Action.Newsletter.EDIT, }, async ({ body }) => { const { newsletterId, opts } = body return await WPP.newsletter.edit(newsletterId, opts) }, ) } const getSubscribers = () => { relay( { name: Action.Newsletter.GET_SUBSCRIBERS, }, async ({ body }) => { return await WPP.newsletter.getSubscribers(body) }, ) } const mute = () => { relay( { name: Action.Newsletter.MUTE, }, async ({ body }) => { const { newsletterId, value } = body return await WPP.newsletter.mute(newsletterId, value) }, ) } const initNewsletterRelay = () => { create() destroy() edit() getSubscribers() mute() } export default initNewsletterRelay \`\`\` # src/relays/profile.relay.ts \`\`\`ts import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const get = () => { relay( { name: Action.Profile.EDIT_BUSINESS_PROFILE, }, async ({ body }) => { return WPP.status.get(body) }, ) } const initProfileRelays = () => { get() } export default initProfileRelays \`\`\` # src/relays/send.relay.ts \`\`\`ts import { Action } from '@/constants' import { response } from '@/utils/response' import { relay } from '@plasmohq/messaging/relay' const sendText = () => { relay( { name: Action.Send.TEXT, }, async (req) => { try { const { chatId, content, options } = req.body const { sendMsgResult } = await WPP.chat.sendTextMessage( chatId, content, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendFile = () => { relay( { name: Action.Send.FILE, }, async (req) => { console.log('req', req) try { const { chatId, content, options } = req.body const { sendMsgResult } = await WPP.chat.sendFileMessage( chatId, content, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendLocation = () => { relay( { name: Action.Send.LOCATION, }, async (req) => { try { const { chatId, options } = req.body const { sendMsgResult } = await WPP.chat.sendLocationMessage( chatId, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendPoll = () => { relay( { name: Action.Send.POLL, }, async (req) => { try { const { chatId, name, choices, options } = req.body const { sendMsgResult } = await WPP.chat.sendCreatePollMessage( chatId, name, choices, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const sendVCard = () => { relay( { name: Action.Send.VCARD, }, async (req) => { try { const { chatId, contacts, options } = req.body const { sendMsgResult } = await WPP.chat.sendVCardContactMessage( chatId, contacts, options, ) const result = await sendMsgResult return response.success(result) } catch (error) { return response.error(error.message) } }, ) } const initSendRelay = () => { sendText() sendFile() sendLocation() sendPoll() sendVCard() } export default initSendRelay \`\`\` # src/relays/status.relay.ts \`\`\`ts import { Action } from '@/constants' import { relay } from '@plasmohq/messaging/relay' const get = () => { relay( { name: Action.Status.GET, }, async ({ body }) => { return WPP.status.get(body) }, ) } const getMyStatus = () => { relay( { name: Action.Status.GET_MY_STATUS, }, async ({ body }) => { return await WPP.status.getMyStatus() }, ) } const remove = () => { relay( { name: Action.Status.REMOVE, }, async ({ body }) => { return await WPP.status.remove(body) }, ) } const sendImageStatus = () => { relay( { name: Action.Status.SEND_IMAGE_STATUS, }, async ({ body }) => { const { content, options } = body return await WPP.status.sendImageStatus(content, options) }, ) } const sendReadStatus = () => { relay( { name: Action.Status.SEND_READ_STATUS, }, async ({ body }) => { const { chatId, statusId } = body return await WPP.status.sendReadStatus(chatId, statusId) }, ) } const sendTextStatus = () => { relay( { name: Action.Status.SEND_TEXT_STATUS, }, async ({ body }) => { try { const { content, options } = body await WPP.status.sendTextStatus(content, options) return { success: true } } catch (error) { return { success: true } } }, ) } const sendVideoStatus = () => { relay( { name: Action.Status.SEND_VIDEO_STATUS, }, async ({ body }) => { const { content, options } = body return await WPP.status.sendVideoStatus(content, options) }, ) } const updateParticipants = () => { relay( { name: Action.Status.UPDATE_PARTICIPANTS, }, async ({ body }) => { return await WPP.status.updateParticipants(body) }, ) } const initStatusRelay = () => { get() getMyStatus() remove() sendImageStatus() sendReadStatus() sendTextStatus() sendVideoStatus() updateParticipants() } export default initStatusRelay \`\`\` # src/stores/app.ts \`\`\`ts import type { License } from '@/types' import { create } from 'zustand' interface AppState { isReady: boolean setIsReady: (isReady: boolean) => void profile: any setProfile: (profile: any) => void license?: License | null setLicense: (license: any) => void groups: any[] setGroups: (groups: []) => void isLoading: boolean setIsLoading: (state: boolean) => void activeChat: any setActiveChat: (chat: any) => void // ++ ADDED: State to hold the specific contact selected from the list selectedContact: any | null setSelectedContact: (contact: any | null) => void } export const useAppStore = create<AppState>((set) => ({ isReady: false, setIsReady: (isReady: boolean) => set({ isReady }), license: null, setLicense: (license: any) => set({ license: license }), groups: [], setGroups: (groups: []) => set({ groups }), profile: {}, setProfile: (profile: any) => set({ profile }), isLoading: false, setIsLoading: (state: any) => set({ isLoading: state }), activeChat: {}, setActiveChat: (chat: any) => set({ activeChat: chat }), // ++ ADDED: Initial state and setter selectedContact: null, setSelectedContact: (contact: any) => set({ selectedContact: contact }), })) \`\`\` # src/stores/confirm.ts \`\`\`ts import { create } from 'zustand' export type ConfirmType = 'info' | 'warning' | 'danger' | 'success' interface ConfirmOptions { title: string message: string type: ConfirmType onConfirm: () => void onCancel: () => void } interface ConfirmState { options: ConfirmOptions | null show: (options: ConfirmOptions) => void hide: () => void } export const useConfirmStore = create<ConfirmState>((set) => ({ options: null, show: (options) => set({ options }), hide: () => set({ options: null }), })) \`\`\` # src/stores/toast.ts \`\`\`ts import { create } from 'zustand' export interface Toast { id: number type: 'success' | 'error' | 'info' | 'warning' title: string message: string duration?: number } interface ToastState { toasts: Toast[] addToast: (toast: Omit<Toast, 'id'>) => void removeToast: (id: number) => void } export const useToastStore = create<ToastState>((set) => ({ toasts: [], addToast: (toast) => set((state) => ({ toasts: [...state.toasts, { ...toast, id: Date.now() }], })), removeToast: (id) => set((state) => ({ toasts: state.toasts.filter((toast) => toast.id !== id), })), })) \`\`\` # src/styles/globals.css \`\`\`css :root { /* MatrixPay Design Tokens */ --matrix-bg-page: #000000; --matrix-bg-card: rgba(15, 23, 42, 0.4); --matrix-bg-card-hover: rgba(15, 23, 42, 0.6); --matrix-glass-overlay: rgba(255, 255, 255, 0.05); --matrix-text-primary: #f8fafc; --matrix-text-secondary: #94a3b8; --matrix-text-tertiary: #64748b; --matrix-emerald-300: #6ee7b7; --matrix-emerald-400: #34d399; --matrix-emerald-500: #10b981; --matrix-emerald-600: #059669; --matrix-glow-primary: rgba(16, 185, 129, 0.4); --matrix-border-subtle: rgba(255, 255, 255, 0.1); --matrix-border-highlight: rgba(52, 211, 153, 0.3); /* Gradients */ --matrix-grad-btn: linear-gradient( 0deg, var(--matrix-emerald-600), var(--matrix-emerald-500) ); --matrix-grad-glass: linear-gradient( to bottom right, rgba(16, 185, 129, 0.15), rgba(0, 0, 0, 0) ); } /* Animations */ @keyframes pulse-glow { 0%, 100% { box-shadow: 0 0 0 rgba(16, 185, 129, 0); } 50% { box-shadow: 0 0 20px rgba(16, 185, 129, 0.3); } } @keyframes fadeInUpBlur { 0% { opacity: 0; transform: translateY(20px); filter: blur(8px); } 100% { opacity: 1; transform: translateY(0); filter: blur(0); } } @keyframes scan-line { 0% { transform: translateY(-100%); opacity: 0; } 50% { opacity: 1; } 100% { transform: translateY(300px); opacity: 0; } } div.plasmo-csui-container { color-scheme: dark; /* USE MANTINE DEFAULT FONT */ font-family: var(--mantine-font-family); font-size: 16px; line-height: 1.5; background-color: transparent; color: var(--matrix-text-primary); -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } /* Global Scrollbar Styling */ div.plasmo-csui-container ::-webkit-scrollbar { width: 6px; height: 6px; } div.plasmo-csui-container ::-webkit-scrollbar-track { background: var(--matrix-bg-page); } div.plasmo-csui-container ::-webkit-scrollbar-thumb { background: var(--matrix-border-subtle); border-radius: 99px; } div.plasmo-csui-container ::-webkit-scrollbar-thumb:hover { background: var(--matrix-emerald-500); } \`\`\` # src/types/globals.d.ts \`\`\`ts import type * as wajs from '@wppconnect/wa-js' declare global { interface Window { WPP: typeof wajs } const WPP: typeof wajs } \`\`\` # src/types/index.d.ts \`\`\`ts import type { Status } from '@/constants' export interface Response<T> { status: keyof typeof Status | string data?: T | null error?: string | null } interface LicenseInstance { createt_at: Date id: string name: string } interface LicenseKey { activation_limit: number activation_usage: number create_at: Date expires_at: Date id: number status: string test_mode: boolean } interface LicenseMeta { customer_email: string customer_id: number customer_name: string order_id: number order_item_id: number product_id: number store_id: number variant_id: number variant_name: string } export interface License { activated?: boolean | null valid?: boolean | null instance?: LicenseInstance | null license_key: LicenseKey meta: LicenseMeta } \`\`\` # src/utils/confirm.ts \`\`\`ts import { useConfirmStore, type ConfirmType } from '@/stores/confirm' interface ConfirmParams { title: string message: string } const _show = (params: ConfirmParams, type: ConfirmType): Promise<boolean> => { return new Promise((resolve) => { useConfirmStore.getState().show({ ...params, type: type, onConfirm: () => { useConfirmStore.getState().hide() resolve(true) }, onCancel: () => { useConfirmStore.getState().hide() resolve(false) }, }) }) } // Export the new, clean API with the requested signature const danger = (title: string, message: string): Promise<boolean> => { return _show({ title, message }, 'danger') } const warning = (title: string, message: string): Promise<boolean> => { return _show({ title, message }, 'warning') } const success = (title: string, message: string): Promise<boolean> => { return _show({ title, message }, 'success') } const info = (title: string, message: string): Promise<boolean> => { return _show({ title, message }, 'info') } export default { danger, warning, success, info, } \`\`\` # src/utils/env.ts \`\`\`ts const isProduction = () => { return process.env.NODE_ENV === 'production' } const isDevelopment = () => { return process.env.NODE_ENV === 'development' } export const isStaging = () => { return process.env.PLASMO_PUBLIC_STAGING === 'true' } export default { isProduction, isDevelopment, isStaging, } \`\`\` # src/utils/ext.ts \`\`\`ts import type { Tabs } from 'webextension-polyfill' import browser from 'webextension-polyfill' export async function getCurrentTab(): Promise<Tabs.Tab> { const queryOptions = { active: true, currentWindow: true } const [tab] = await browser.tabs.query(queryOptions) return tab } export async function getTabs(): Promise<Tabs.Tab[]> { return new Promise(async (resolve, reject) => { try { const tabs = await browser.tabs.query({ currentWindow: true }) const filteredTabs = tabs.filter( (tab) => !tab.url?.startsWith('chrome://'), ) return resolve(filteredTabs) } catch (error) { reject(error) } }) } export async function getTabByUrl(url: string): Promise<Tabs.Tab | null> { const queryOptions = { url: url } const tabs = await browser.tabs.query(queryOptions) return tabs.length > 0 ? tabs[0] : null } export const openWa = async () => { await browser.tabs.create({ url: 'https://web.whatsapp.com' }) } export const isWaTabActive = async (): Promise<boolean> => { const result = await getTabByUrl('https://web.whatsapp.com/') return result?.active } export const isWaTabAvailable = async (): Promise<boolean> => { const result = await getTabByUrl('https://web.whatsapp.com/') return !!result } export function injectCss(path: string) { try { let element = document.createElement('link') element.setAttribute('rel', 'stylesheet') element.setAttribute('type', 'text/css') element.setAttribute('href', chrome.runtime.getURL(path)) document.getElementsByTagName('head')[0].appendChild(element) } catch (error) { console.error(`Error injecting css ${path} `, error) } } export function injectJs(path: string) { try { const script = document.createElement('script') script.src = chrome.runtime.getURL(path) document.body.appendChild(script) } catch (error) { console.error(`Error injecting javascript ${path} `, error) } } \`\`\` # src/utils/filterBy.ts \`\`\`ts import { AccountType, ContactType, MessageType } from '@/constants' const dontIncludeLid = (contact: any) => contact.id?.includes('@c.us') const dontIncludeMe = (contact: any, number: any) => contact.phoneNumber !== number const accountType = (contact: any, type: string) => { switch (type) { case AccountType.ALL: return true case AccountType.PERSONAL: return contact.isBusiness === false case AccountType.BUSINESS: return contact.isBusiness === true default: return true } } const contactType = (contact: any, type: string): boolean => { switch (type) { case ContactType.ALL: return true case ContactType.SAVED_CONTACTS: return contact.isMyContact === true case ContactType.UNSAVED_CONTACTS: return contact.isMyContact === false default: return true } } const includeAdmin = (data: any, isIncludeAdmin: boolean) => { if (isIncludeAdmin) { if (data.isAdmin) { return true } } else { if (data.isAdmin) return false } return true } const onlyMyContact = (data: any, onlyMyContact: boolean) => { if (onlyMyContact) { return data.isMyContact === true } else { return data.isMyContact !== true } } const messageType = (contact: any, type: string): boolean => { switch (type) { case MessageType.ALL: return true case MessageType.HAVE_UNREAD_MESSAGES: return contact.hasUnread === true case MessageType.NO_UNREAD_MESSAGES: return contact.hasUnread === false default: return true } } const country = (contact: any, country: string) => { const countryCode = WPP.whatsapp.functions.getCountryShortcodeByPhone( contact.id.user, ) return countryCode === country } export default { dontIncludeLid, dontIncludeMe, accountType, includeAdmin, onlyMyContact, contactType, messageType, country, } \`\`\` # src/utils/page.ts \`\`\`ts import { Action } from '@/constants' import { postMessage } from './util' const goTo = (page: string) => { postMessage(Action.Window.GO_TO_PAGE, page) } export default { goTo, } \`\`\` # src/utils/parse.ts \`\`\`ts // src/utils/util.ts import type { BroadcastContact } from '@/libs/db' import _ from 'lodash' /** * @description Processes Spintax recursively to handle nested variations. * It finds patterns like {option1|option2}, randomly selects one, * and repeats until no patterns are left. * @param {string} text The text containing Spintax format. * @returns {string} The processed text with one variation chosen. */ const processSpintax = (text: string): string => { const spintaxRegex = /{([^{}]*)}/ let processedText = text let match = spintaxRegex.exec(processedText) while (match) { const options = match[1].split('|') const randomIndex = Math.floor(Math.random() * options.length) const chosenOption = options[randomIndex] processedText = processedText.replace(match[0], chosenOption) match = spintaxRegex.exec(processedText) } return processedText } /** * @description Parses a message string by first processing Spintax for variations, * and then replacing personalization placeholders like {name} and {number}. * @param {string} message The message template. * @param {BroadcastContact} contact The recipient's data, containing name and number. * @returns {string} The fully parsed and personalized message. */ const text = (message: string, contact: BroadcastContact): string => { const contactName = contact.name || 'there' const contactNumber = contact.number.split('@')[0] return _.chain(message) .replace(/{name}/g, contactName) .replace(/{number}/g, contactNumber) .value() } export default { text, } \`\`\` # src/utils/privacy.ts \`\`\`ts import { Setting } from '@/constants' import { storage } from '@/libs/storage' const STYLE_ID = 'supawazap-privacy-styles' const init = async () => { // Load settings and apply styles on initialization await updatePrivacyStyles() } /** * Helper to create CSS rules */ const createRule = ( selector: string, shouldBlur: boolean, unblurOnHover: boolean, ) => { if (!shouldBlur) return '' const baseStyle = ` ${selector} { filter: blur(5px) !important; transition: filter 0.2s ease !important; } ` const hoverStyle = unblurOnHover ? ` ${selector}:hover { filter: none !important; } ` : '' return baseStyle + hoverStyle } /** * Main function to generate and inject CSS into head */ const updatePrivacyStyles = async () => { // 1. Get all latest settings from storage const blurProfilePictures = (await storage.get(Setting.BLUR_PROFILE_PICTURES)) ?? false const blurMessages = (await storage.get(Setting.BLUR_MESSAGES)) ?? false const blurUserGroupNames = (await storage.get(Setting.BLUR_USER_GROUP_NAMES)) ?? false const blurRecentMessages = (await storage.get(Setting.BLUR_RECENT_MESSAGES)) ?? false const unblurOnHover = (await storage.get(Setting.UNBLUR_ON_HOVER)) ?? false // 2. Define Selectors (Matching current WhatsApp Web classes) // Note: Classes like _ak8q can change anytime if WA updates. const selectors = { profile: [ '.x1n2onr6.x1c9tyrk', // Profile picture in chat list 'span[data-icon="default-contact-refreshed"]', 'span[data-icon="default-group-refreshed"]', 'span[data-icon="default-community-refreshed"]', 'header img', // Profile picture in chat header ], messages: ['.message-in', '.message-out'], names: ['div[class="_ak8q"]', 'span[dir="auto"][title]'], recent: ['div[class="_ak8k"]'], } // 3. Build CSS String let css = '' // Profile Pictures css += createRule( selectors.profile.join(', '), Boolean(blurProfilePictures), Boolean(unblurOnHover), ) // Messages (Chat content) css += createRule( selectors.messages.join(', '), Boolean(blurMessages), Boolean(unblurOnHover), ) // User/Group Names css += createRule( selectors.names.join(', '), Boolean(blurUserGroupNames), Boolean(unblurOnHover), ) // Recent Messages (Sidebar) css += createRule( selectors.recent.join(', '), Boolean(blurRecentMessages), Boolean(unblurOnHover), ) // 4. Inject or Update Style Tag in Head let styleEl = document.getElementById(STYLE_ID) if (!styleEl) { styleEl = document.createElement('style') styleEl.id = STYLE_ID document.head.appendChild(styleEl) } styleEl.textContent = css } const blurProfilePictures = async () => updatePrivacyStyles() const blurMessages = async () => updatePrivacyStyles() const blurUserGroupNames = async () => updatePrivacyStyles() const blurRecentMessages = async () => updatePrivacyStyles() export default { init, blurProfilePictures, blurMessages, blurUserGroupNames, blurRecentMessages, } \`\`\` # src/utils/response.ts \`\`\`ts import { Status } from '@/constants' import type { Response } from '@/types' const success = <T = any>(data?: T | null): Response<T | undefined | null> => { return { status: Status.SUCCESS, data: data, } } const error = (error: string | undefined | null): Response<null> => { return { status: Status.FAILED, error: error, } } export const response = { success, error, } \`\`\` # src/utils/serialize.ts \`\`\`ts import type { ChatModel, ContactModel, GroupMetadataModel, MediaDataModel, MsgModel, ParticipantModel, } from '@wppconnect/wa-js/dist/whatsapp' import _ from 'lodash' import { getContactId, getContactName } from './util' const button = (buttons: any[]) => { return buttons .map(({ type, label, value }) => { switch (type) { case 'text': return { text: value } case 'url': return { text: label, url: value } case 'phoneNumber': return { text: label, phoneNumber: value } default: break } }) .filter((button) => !!button) } const list = (rows: any[]) => { return rows.filter((row) => row.title !== '') } const contact = (contact: ContactModel) => { if (!contact) return {} const hasUnread = WPP.chat.get(contact.id._serialized)?.hasUnread ?? false const id = getContactId(contact) return { id: id?._serialized, number: id?.user, avatar: contact.getProfilePicThumb().__x_eurl, name: getContactName(contact), labels: contact.labels, isGroup: id?._serialized?.includes('@g'), isUser: id?._serialized?.includes('@c'), isBusiness: !!contact.isBusiness, isMe: contact.isMe, isMyContact: contact.isWAContact, hasUnread, } } const mediaData = (data?: MediaDataModel) => { if (!data) return {} return { mimeType: data?.mimetype, size: data?.size, base64: data?.preview?.base64, height: data?.fullHeight, width: data?.fullWidth, } } const message = (msgModel: MsgModel) => { return { id: msgModel.id._serialized, ack: msgModel.ack, body: msgModel.body, from: msgModel.from, isViewOnce: msgModel.isViewOnce, timestamp: msgModel.t * 1000, to: msgModel.to, type: msgModel.type, mimetype: msgModel.mimetype, size: msgModel.size, filename: msgModel.filename, caption: msgModel.caption, duration: msgModel.duration, height: msgModel.height, width: msgModel.width, quotedMessage: msgModel.quotedMsg, contact: contact(msgModel.senderObj), } } const groupMetadata = (data: GroupMetadataModel) => { return { id: data?.id?._serialized, description: data?.desc, size: data?.size, subject: data?.subject, creation: data?.creation * 1000, participants: data?.participants?.getModelsArray().map(participant), } } const chat = (chat: ChatModel) => { return { id: chat.id._serialized, name: getContactName(chat.contact), number: chat.id.user, messages: chat.msgs.getModelsArray().map(message), contact: contact(chat.contact), groupMetadata: groupMetadata(chat.groupMetadata), formattedNumber: chat.id._serialized, isPinned: !!chat.pin, isArchived: !!chat.archive, isMuted: !!chat.muteExpiration, isGroup: chat.id._serialized?.includes('@g'), isUser: chat.id._serialized?.includes('@c'), } } const participant = (participant: ParticipantModel) => { return { isAdmin: participant.isAdmin, isSuperAdmin: participant.isSuperAdmin, contact: contact(participant.contact), } } export default { button, list, contact, chat, participant, message, } \`\`\` # src/utils/style.ts \`\`\`ts import appStyle from 'data-text:@/components/App.module.css' import layoutStyle from 'data-text:@/components/Layout/LayoutPage.module.css' import toastStyle from 'data-text:@/components/Toast/Toast.module.css' import globalsStyle from 'data-text:@/styles/globals.css' import coreStyle from 'data-text:@mantine/core/styles.css' import dateStyle from 'data-text:@mantine/dates/styles.css' import dropzoneStyle from 'data-text:@mantine/dropzone/styles.css' import tableStyle from 'data-text:mantine-datatable/styles.layer.css' const styles = [ coreStyle, dateStyle, dropzoneStyle, tableStyle, toastStyle, globalsStyle, layoutStyle, appStyle, ] const generate = () => { return styles.join('') } // MatrixPay Design: Gradient Text Style export const gradientText = { background: 'linear-gradient(to right, #a7f3d0, #34d399, #d1fae5)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent', filter: 'drop-shadow(0 0 20px rgba(52, 211, 153, 0.3))', } export default { generate, gradientText } \`\`\` # src/utils/throwError.ts \`\`\`ts const broadcastNotFound = () => { throw new Error('Broadcast not found') } const mediaNotFound = () => { throw new Error('Media not found') } const contactNotExist = () => { throw new Error('Contact not exist') } export default { broadcastNotFound, mediaNotFound, contactNotExist, } \`\`\` # src/utils/toast.ts \`\`\`ts import { useToastStore } from '@/stores/toast' const showSuccess = (message: string, title: string = 'Success') => { useToastStore.getState().addToast({ type: 'success', title, message }) } const showError = (message: string, title: string = 'Error') => { useToastStore.getState().addToast({ type: 'error', title, message }) } const showInfo = (message: string, title: string = 'Information') => { useToastStore.getState().addToast({ type: 'info', title, message }) } const showWarning = (message: string, title: string = 'Warning') => { useToastStore.getState().addToast({ type: 'warning', title, message }) } export default { success: showSuccess, error: showError, info: showInfo, // ADDED: Export the new 'warning' function. warning: showWarning, } \`\`\` # src/utils/util.ts \`\`\`ts import { Action, Message } from '@/constants' import { Window } from '@/constants/action' import type { UseFormReturnType } from '@mantine/form' import _ from 'lodash' export async function delay(timeoutMs = 1000) { await new Promise((resolve) => setTimeout(resolve, timeoutMs)) } export const generateRandomDelay = (min: number, max: number) => { const minThousand = Math.ceil(min / 1000) const maxThousand = Math.floor(max / 1000) const randomThousand = Math.floor(Math.random() * (maxThousand - minThousand + 1)) + minThousand return randomThousand * 1000 } export const postMessage = (action: string, body: any = null) => { window.postMessage({ action, body, }) } export const showModalUpgrade = () => { postMessage(Action.Window.SHOW_MODAL_UPGRADE) } export const showModalPricing = () => { postMessage(Action.Window.SHOW_MODAL_PRICING) } export const showModalMain = () => { postMessage(Action.Window.SHOW_MODAL_MAIN) } export const showModalActivation = () => { postMessage(Action.Window.SHOW_MODAL_ACTIVATION) } export const goToHistoryPage = () => { postMessage(Action.Window.GO_TO_HISTORY_PAGE) } export const getStoreId = () => { return process.env.PLASMO_PUBLIC_STORE_ID } export const truncate = (data: string, length: number = 30) => { return _.chain(data) .thru((str) => (str.length > length ? `${str.slice(0, length)}...` : str)) .value() } export const formHasErrors = ( form1: UseFormReturnType<any>, form2: UseFormReturnType<any>, ): boolean => { let hasError = false if (form1.validate().hasErrors) { hasError = true } if (form2.validate().hasErrors) { hasError = true } return hasError } export const resetForms = ( form1: UseFormReturnType<any>, form2: UseFormReturnType<any>, ) => { form1.reset() form2.reset() } export const isGroup = (number: string) => { return number.includes('@g.us') } export const isPersonal = (number: string) => { return !number.includes('@g.us') } export const closePage = () => { postMessage(Window.CLOSE_PAGE) } export const isTypeMessageMedia = (type: string) => { return [ Message.MEDIA, Message.IMAGE, Message.VIDEO, Message.AUDIO, // Added AUDIO Message.FILE, ].includes(type) } export const goToBroadcastHistory = () => { postMessage(Window.GO_TO_HISTORY_PAGE) } export const getContactName = (contact: any) => { return ( contact.name || contact.pushname || contact.notifyName || contact.formattedName || '-' ) } export const getContactId = (contact: any) => { return contact.id._serialized.includes('@lid') ? contact?.phoneNumber : contact.id } \`\`\` # tsconfig.json \`\`\`json { "extends": "plasmo/templates/tsconfig.base", "exclude": ["node_modules"], "include": [".plasmo/index.d.ts", "./**/*.ts", "./**/*.tsx"], "compilerOptions": { "paths": { "@/*": ["src/*"], }, "baseUrl": ".", }, } \`\`\`
```

# src/app/favicon.ico

This is a binary file of the type: Binary

# src/app/globals.css

```css
:root { /* Colors - Background */ --bg-page: #000000; --bg-card-primary: rgba(15, 23, 42, 0.4); --bg-card-secondary: rgba(2, 6, 23, 0.6); --bg-glass-overlay: rgba(255, 255, 255, 0.05); /* Colors - Text */ --text-primary: #f8fafc; --text-secondary: #94a3b8; --text-tertiary: #64748b; --text-accent: #34d399; /* Colors - Brand */ --brand-emerald-300: #6ee7b7; --brand-emerald-400: #34d399; --brand-emerald-500: #10b981; --brand-emerald-600: #059669; --brand-glow-primary: rgba(16, 185, 129, 0.4); /* Colors - Borders */ --border-subtle: rgba(255, 255, 255, 0.1); --border-highlight: rgba(52, 211, 153, 0.3); /* Layout */ --container-max-width: 1152px; --radius-sm: 0.375rem; --radius-md: 0.5rem; --radius-lg: 1rem; --radius-xl: 1.5rem; --radius-2xl: 2rem; --radius-full: 9999px; /* Effects */ --shadow-glow-sm: 0 0 15px rgba(16, 185, 129, 0.4); --shadow-glow-lg: 0 0 60px rgba(16, 185, 129, 0.15); --shadow-card-hover: 0 20px 40px -10px rgba(0, 0, 0, 0.5); --gradient-text: linear-gradient(to right, #a7f3d0, #34d399, #d1fae5); --gradient-beam: radial-gradient( 65.28% 65.28% at 50% 100%, rgba(52, 211, 153, 0.8) 0%, rgba(52, 211, 153, 0) 100% ); } @media (prefers-color-scheme: dark) { :root { --background: var(--bg-page); --foreground: var(--text-primary); } } body { color: var(--text-primary); background: var(--bg-page); font-family: var(--font-geist-sans), "Inter", system-ui, sans-serif; overflow-x: hidden; } /* Typography Utilities */ h1 { font-size: 3.75rem; line-height: 1; font-weight: 400; letter-spacing: -0.025em; } h2 { font-size: 2.25rem; line-height: 2.5rem; font-weight: 500; letter-spacing: -0.025em; } .font-mono-label { font-family: "Space Mono", var(--font-geist-mono), monospace; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.12em; } /* Animations */ @keyframes fadeInUpBlur { 0% { opacity: 0; transform: translateY(20px); filter: blur(8px); } 100% { opacity: 1; transform: translateY(0); filter: blur(0); } } @keyframes pulse-glow { 0%, 100% { box-shadow: 0 0 0 rgba(16, 185, 129, 0); } 50% { box-shadow: 0 0 20px rgba(16, 185, 129, 0.3); } } @keyframes float-card { 0%, 100% { transform: rotateY(-15deg) rotateX(5deg) translateY(0px); } 50% { transform: rotateY(-15deg) rotateX(5deg) translateY(-15px); } } @keyframes gradient-x { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } } @keyframes scan-line { 0% { transform: translateY(-100%); opacity: 0; } 50% { opacity: 1; } 100% { transform: translateY(300px); opacity: 0; } } /* Utility Classes */ .animate-entry { animation: fadeInUpBlur 0.7s cubic-bezier(0.2, 0.8, 0.2, 1) forwards; } .animate-infinite-glow { animation: pulse-glow 3s infinite; } .text-gradient { background: var(--gradient-text); -webkit-background-clip: text; background-clip: text; color: transparent; background-size: 200% auto; animation: gradient-x 3s linear infinite; } /* Component Styles */ .btn-primary-action { background: linear-gradient( 0deg, var(--brand-emerald-600), var(--brand-emerald-500) ); box-shadow: 0 0 15px rgba(16, 185, 129, 0.3); border-radius: 9999px; color: #ffffff; transition: transform 0.2s ease; } .btn-primary-action:hover { transform: scale(1.05); } .card-glass-panel { background: linear-gradient( to bottom right, rgba(16, 185, 129, 0.15), rgba(0, 0, 0, 0) ); backdrop-filter: blur(12px); border-radius: 24px; border: 1px solid transparent; width: 100%; position: relative; } /* Pseudo-border gradient technique */ .card-glass-panel::before { content: ""; position: absolute; inset: 0; border-radius: 24px; padding: 1px; background: linear-gradient(to bottom, var(--border-highlight), transparent); -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0); mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0); -webkit-mask-composite: xor; mask-composite: exclude; pointer-events: none; } .card-feature { background: var(--bg-card-primary); border: 1px solid var(--bg-glass-overlay); border-radius: 16px; transition: all 0.3s ease-out; } .card-feature:hover { transform: translateY(-4px); box-shadow: var(--shadow-card-hover); border-color: var(--border-highlight); } .badge-status-pill { background: rgba(16, 185, 129, 0.15); color: #a7f3d0; border-radius: 9999px; padding: 2px 8px; font-size: 0.75rem; display: inline-block; } * { box-sizing: border-box; padding: 0; margin: 0; } a { color: inherit; text-decoration: none; } @media (prefers-color-scheme: dark) { html { color-scheme: dark; } } /* Custom Scrollbar */ ::-webkit-scrollbar { width: 5px; } ::-webkit-scrollbar-track { background: #0a0a0a; } ::-webkit-scrollbar-thumb { background: #262626; border-radius: 5px; } ::-webkit-scrollbar-thumb:hover { background: #404040; } .text-gradient { background: linear-gradient(135deg, #ffffff 0%, #94a3b8 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; } @keyframes rotate-border { from { transform: rotate(0deg); } to { transform: rotate(360deg); } } .feature-card-group:hover .feature-overlay { opacity: 1 !important; } .feature-card-group:hover .view-demo-btn { transform: translateY(0) !important; } /* --- INFINITE MARQUEE ANIMATION --- */ @keyframes scroll-left { from { transform: translateX(0); } to { transform: translateX(-50%); } } @keyframes scroll-right { from { transform: translateX(-50%); } to { transform: translateX(0); } } .marquee-container { display: flex; overflow: hidden; user-select: none; gap: 2rem; /* Jarak antar kartu */ /* Gradient Mask: Membuat efek fade di kiri dan kanan */ mask-image: linear-gradient( to right, transparent, black 10%, black 90%, transparent ); -webkit-mask-image: linear-gradient( to right, transparent, black 10%, black 90%, transparent ); } .marquee-content { flex-shrink: 0; display: flex; justify-content: space-around; gap: 2rem; /* Harus sama dengan container gap */ min-width: 100%; } .animate-scroll-left { animation: scroll-left 40s linear infinite; } .animate-scroll-right { animation: scroll-right 40s linear infinite; } /* Pause animasi saat user hover agar bisa dibaca */ .marquee-container:hover .marquee-content { animation-play-state: paused; }
```

# src/app/layout.tsx

```tsx
import type { Metadata } from "next"; import { Geist, Geist_Mono } from "next/font/google"; import { ColorSchemeScript, MantineProvider } from "@mantine/core"; import "@mantine/core/styles.css"; import "./globals.css"; import { theme } from "@/theme"; const geistSans = Geist({ variable: "--font-geist-sans", subsets: ["latin"], }); const geistMono = Geist_Mono({ variable: "--font-geist-mono", subsets: ["latin"], }); export const metadata: Metadata = { title: "Supawazap: WhatsAppâ„¢ Web with Superpowers", description: "Supercharge your WA with CRM, Bulk Sender, Scheduler, Workflow, Quick Reply, Export Contacts, and privacy tools.", }; export default function RootLayout({ children, }: Readonly<{ children: React.ReactNode; }>) { return ( <html lang="en" suppressHydrationWarning> <head> <ColorSchemeScript /> </head> <body className={`${geistSans.variable} ${geistMono.variable}`} suppressHydrationWarning > <MantineProvider theme={theme}>{children}</MantineProvider> </body> </html> ); }
```

# src/app/page.module.css

```css
.page { --background: #fafafa; --foreground: #fff; --text-primary: #000; --text-secondary: #666; --button-primary-hover: #383838; --button-secondary-hover: #f2f2f2; --button-secondary-border: #ebebeb; display: flex; min-height: 100vh; align-items: center; justify-content: center; font-family: var(--font-geist-sans); background-color: var(--background); } .main { display: flex; min-height: 100vh; width: 100%; max-width: 800px; flex-direction: column; align-items: flex-start; justify-content: space-between; background-color: var(--foreground); padding: 120px 60px; } .intro { display: flex; flex-direction: column; align-items: flex-start; text-align: left; gap: 24px; } .intro h1 { max-width: 320px; font-size: 40px; font-weight: 600; line-height: 48px; letter-spacing: -2.4px; text-wrap: balance; color: var(--text-primary); } .intro p { max-width: 440px; font-size: 18px; line-height: 32px; text-wrap: balance; color: var(--text-secondary); } .intro a { font-weight: 500; color: var(--text-primary); } .ctas { display: flex; flex-direction: row; width: 100%; max-width: 440px; gap: 16px; font-size: 14px; } .ctas a { display: flex; justify-content: center; align-items: center; height: 40px; padding: 0 16px; border-radius: 128px; border: 1px solid transparent; transition: 0.2s; cursor: pointer; width: fit-content; font-weight: 500; } a.primary { background: var(--text-primary); color: var(--background); gap: 8px; } a.secondary { border-color: var(--button-secondary-border); } /* Enable hover only on non-touch devices */ @media (hover: hover) and (pointer: fine) { a.primary:hover { background: var(--button-primary-hover); border-color: transparent; } a.secondary:hover { background: var(--button-secondary-hover); border-color: transparent; } } @media (max-width: 600px) { .main { padding: 48px 24px; } .intro { gap: 16px; } .intro h1 { font-size: 32px; line-height: 40px; letter-spacing: -1.92px; } } @media (prefers-color-scheme: dark) { .logo { filter: invert(); } .page { --background: #000; --foreground: #000; --text-primary: #ededed; --text-secondary: #999; --button-primary-hover: #ccc; --button-secondary-hover: #1a1a1a; --button-secondary-border: #1a1a1a; } }
```

# src/app/page.tsx

```tsx
import { BrowserMockup } from "@/components/BrowserMockup/BrowserMockup"; import { FAQ } from "@/components/FAQ/FAQ"; import { FeaturedOn } from "@/components/FeaturedOn/FeaturedOn"; import { Features } from "@/components/Features/Features"; import { SecondaryFeatures } from "@/components/Features/SecondaryFeatures"; import { Footer } from "@/components/Footer/Footer"; import { Navbar } from "@/components/Navbar/Navbar"; import { PainVsGain } from "@/components/PainVsGain/PainVsGain"; import { Pricing } from "@/components/Pricing/Pricing"; import { Stats } from "@/components/Stats"; import { Testimonials } from "@/components/Testimonials"; import { Typewriter } from "@/components/Typewriter"; import { Icon } from "@iconify/react"; import { Avatar, Box, Button, Container, Group, SimpleGrid, Stack, Text, Title, rem, AvatarGroup, ThemeIcon, } from "@mantine/core"; export default function Home() { return ( <Box pb={100} style={{ backgroundColor: "#030712", // Grid pattern background backgroundImage: "linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px)", backgroundSize: "32px 32px", minHeight: "100vh", color: "white", position: "relative", overflow: "hidden", // Prevents spotlight overflow scrollbars }} > {/* 1. SPOTLIGHT EFFECT */} {/* A large radial gradient positioned behind the hero content */} <Box style={{ position: "absolute", top: "-20%", left: "50%", transform: "translateX(-50%)", width: "140%", height: "1000px", background: "radial-gradient(circle at center, rgba(16, 185, 129, 0.15) 0%, rgba(3, 7, 18, 0) 60%)", zIndex: 0, pointerEvents: "none", }} /> <Navbar /> <Container size="xl" mt={135} style={{ position: "relative", zIndex: 1 }}> <Stack gap="xl" align="center"> {/* Hero Title */} <Title order={1} className="text-gradient" style={{ fontSize: rem(60), fontWeight: 800, lineHeight: 1.1, letterSpacing: "-0.02em", textAlign: "center", }} > WhatsApp Web with Superpowers <br /> <Text span inherit style={{ background: "linear-gradient(to right, #34d399, #10b981)", WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent", }} > <Typewriter words={[ "Workflow Automation", "CRM", "24/7 Auto-Reply", "Smart Broadcasting", "Quick Reply", "Direct Chat", "Custom Field", "Smart Segmentation", "Export Contact", "Backup Chat", "Privacy First", ]} typingSpeed={75} deletingSpeed={50} pauseTime={1500} /> </Text> </Title> {/* Subtitle */} <Text c="dimmed" size="xl" ta="center" maw={700} style={{ fontSize: rem(26), lineHeight: 1.6 }} > The only local-first extension that combines Smart Broadcasting, Visual Workflow Automation, and Deep CRM features, without compromising privacy. </Text> {/* CTA Group */} <Stack align="center" gap="xs"> <Button size="xl" radius="xl" className="btn-primary-action" leftSection={<Icon icon="logos:chrome" fontSize={24} />} style={{ height: rem(60), fontSize: rem(18), }} > Add to Chrome - It's Free </Button> {/* UPGRADE: Helper Text dengan Social Proof */} <Box mt="lg" py={10} px={24} style={{ borderRadius: 999, backgroundColor: "rgba(255, 255, 255, 0.03)", border: "1px solid rgba(255, 255, 255, 0.08)", backdropFilter: "blur(10px)", WebkitBackdropFilter: "blur(10px)", display: "inline-block", boxShadow: "0 4px 20px rgba(0,0,0,0.2)", }} > <Group gap="xl" wrap="wrap" justify="center"> {/* No Credit Card */} <Group gap={8}> <ThemeIcon size={22} color="gray" variant="light" radius="xl" style={{ backgroundColor: "rgba(255, 255, 255, 0.05)", }} > <Text size="xs">ðŸ’³</Text> </ThemeIcon> <Text size="sm" c="gray.2" fw={500}> No credit card </Text> </Group> {/* Divider */} <Box w={1} h={20} bg="rgba(255,255,255,0.1)" visibleFrom="xs" /> {/* No Sign Up */} <Group gap={8}> <ThemeIcon size={22} color="gray" variant="light" radius="xl" style={{ backgroundColor: "rgba(255, 255, 255, 0.05)", }} > <Text size="xs">ðŸ‘¤</Text> </ThemeIcon> <Text size="sm" c="gray.2" fw={500}> No sign up </Text> </Group> {/* Divider */} {/* <Box w={1} h={20} bg="rgba(255,255,255,0.1)" visibleFrom="xs" /> */} {/* Trusted */} {/* <Group gap={8}> <ThemeIcon size={22} color="gray" variant="light" radius="xl" style={{ backgroundColor: "rgba(255, 255, 255, 0.05)", }} > <Text size="xs">â­</Text> </ThemeIcon> <Text size="sm" c="gray.2" fw={500}> Trusted by{" "} <Text span fw={700} c="white"> Professionals </Text> </Text> </Group> */} </Group> </Box> </Stack> </Stack> <BrowserMockup /> <Stats /> </Container> <Features /> <SecondaryFeatures /> {/* <PainVsGain /> */} <Testimonials /> <Pricing /> {/* <FeaturedOn /> */} <FAQ /> <Footer /> </Box> ); }
```

# src/app/privacy/page.tsx

```tsx
"use client"; import { Box, Container, Title, Text, Stack, rem, Anchor, List, ThemeIcon, Paper, Group, } from "@mantine/core"; import { Icon } from "@iconify/react"; import Link from "next/link"; import Image from "next/image"; // Logo Component const Logo = () => ( <Link href="/" style={{ textDecoration: "none" }}> <Group gap={8} style={{ cursor: "pointer" }} wrap="nowrap"> <Image src="/logo.png" alt="Supawazap Logo" width={32} height={32} style={{ objectFit: "contain", filter: "drop-shadow(0 0 10px rgba(16, 185, 129, 0.4))", }} /> <Text fw={"bold"} size={"xl"} c="white" style={{ letterSpacing: "-0.02em", }} > Supa <Text span c="emerald.5" fw={"bold"} size="xl"> wazap </Text> </Text> </Group> </Link> ); export default function PrivacyPolicyPage() { return ( <Box style={{ minHeight: "100vh", background: "#030712", }} > {/* Header */} <Box py="lg" px="xl" style={{ borderBottom: "1px solid rgba(255,255,255,0.05)", }} > <Container size="lg"> <Group justify="space-between"> <Logo /> <Link href="/" style={{ color: "var(--mantine-color-emerald-4)", fontSize: "var(--mantine-font-size-sm)", textDecoration: "none", }} > â† Back to Home </Link> </Group> </Container> </Box> {/* Content */} <Container size="md" py={80}> <Stack gap="xl"> {/* Header */} <Stack gap="sm" align="center" ta="center" mb="xl"> <Title order={1} style={{ fontSize: rem(48) }} className="text-gradient" > Privacy Policy </Title> <Text c="dimmed" size="lg"> Last updated: December 16, 2024 </Text> </Stack> {/* Introduction */} <Paper p="xl" radius="lg" style={{ background: "rgba(255,255,255,0.02)", border: "1px solid rgba(255,255,255,0.05)", }} > <Stack gap="md"> <Group gap="sm"> <ThemeIcon color="emerald" size="lg" radius="xl"> <Icon icon="tabler:shield-check" width={20} /> </ThemeIcon> <Title order={3} c="white"> Your Privacy is Our Priority </Title> </Group> <Text c="gray.4" size="md" lh={1.7}> Supawazap is designed with a{" "} <strong>local-first architecture</strong>. This means your data stays on YOUR device. We don&apos;t have access to your contacts, messages, or any personal information. </Text> </Stack> </Paper> {/* Section 1 */} <Stack gap="md"> <Title order={2} c="white" size="h3"> 1. Data We Collect </Title> <Text c="gray.4" lh={1.7}> Supawazap operates as a browser extension and stores all data locally in your browser&apos;s IndexedDB. We do NOT collect: </Text> <List spacing="sm" icon={ <ThemeIcon color="emerald" size={20} radius="xl"> <Icon icon="tabler:x" width={12} /> </ThemeIcon> } > <List.Item> <Text c="gray.3">Your WhatsApp contacts or phone numbers</Text> </List.Item> <List.Item> <Text c="gray.3"> Your chat messages or conversation history </Text> </List.Item> <List.Item> <Text c="gray.3"> Your media files (photos, videos, documents) </Text> </List.Item> <List.Item> <Text c="gray.3">Your CRM data, tags, or custom fields</Text> </List.Item> <List.Item> <Text c="gray.3">Your workflow automations or templates</Text> </List.Item> </List> </Stack> {/* Section 2 */} <Stack gap="md"> <Title order={2} c="white" size="h3"> 2. Data Storage </Title> <Text c="gray.4" lh={1.7}> All data created and managed by Supawazap is stored locally on your device using browser storage technologies (IndexedDB). This includes: </Text> <List spacing="sm" icon={ <ThemeIcon color="emerald" size={20} radius="xl"> <Icon icon="tabler:database" width={12} /> </ThemeIcon> } > <List.Item> <Text c="gray.3">Contact information and custom fields</Text> </List.Item> <List.Item> <Text c="gray.3">Tags, segments, and filters</Text> </List.Item> <List.Item> <Text c="gray.3">Workflow automation configurations</Text> </List.Item> <List.Item> <Text c="gray.3">Quick reply templates</Text> </List.Item> <List.Item> <Text c="gray.3">Extension settings and preferences</Text> </List.Item> </List> </Stack> {/* Section 3 */} <Stack gap="md"> <Title order={2} c="white" size="h3"> 3. License Verification </Title> <Text c="gray.4" lh={1.7}> To verify your license and enable Pro features, we may collect: </Text> <List spacing="sm" icon={ <ThemeIcon color="blue" size={20} radius="xl"> <Icon icon="tabler:check" width={12} /> </ThemeIcon> } > <List.Item> <Text c="gray.3">Email address (for license activation)</Text> </List.Item> <List.Item> <Text c="gray.3">License key (for authentication)</Text> </List.Item> <List.Item> <Text c="gray.3"> Device identifier (for multi-device limits) </Text> </List.Item> </List> <Text c="gray.5" size="sm"> This data is processed securely through our payment provider (Lemon Squeezy) and is never shared with third parties. </Text> </Stack> {/* Section 4 */} <Stack gap="md"> <Title order={2} c="white" size="h3"> 4. Third-Party Services </Title> <Text c="gray.4" lh={1.7}> Supawazap integrates with the following third-party services: </Text> <List spacing="sm" icon={ <ThemeIcon color="gray" size={20} radius="xl"> <Icon icon="tabler:external-link" width={12} /> </ThemeIcon> } > <List.Item> <Text c="gray.3"> <strong>Lemon Squeezy</strong> â€“ Payment processing and license management </Text> </List.Item> <List.Item> <Text c="gray.3"> <strong>WhatsApp Web</strong> â€“ The extension operates on top of web.whatsapp.com </Text> </List.Item> </List> </Stack> {/* Section 5 */} <Stack gap="md"> <Title order={2} c="white" size="h3"> 5. Your Rights </Title> <Text c="gray.4" lh={1.7}> Since all data is stored locally on your device, you have full control: </Text> <List spacing="sm" icon={ <ThemeIcon color="emerald" size={20} radius="xl"> <Icon icon="tabler:check" width={12} /> </ThemeIcon> } > <List.Item> <Text c="gray.3"> Export your data anytime (Excel, CSV, JSON) </Text> </List.Item> <List.Item> <Text c="gray.3"> Delete all data by clearing browser storage </Text> </List.Item> <List.Item> <Text c="gray.3"> Uninstall the extension to remove all traces </Text> </List.Item> </List> </Stack> {/* Section 6 */} <Stack gap="md"> <Title order={2} c="white" size="h3"> 6. Contact Us </Title> <Text c="gray.4" lh={1.7}> If you have any questions about this Privacy Policy, please contact us at: </Text> <Paper p="md" radius="md" style={{ background: "rgba(16, 185, 129, 0.1)", border: "1px solid rgba(16, 185, 129, 0.2)", }} > <Group gap="sm"> <Icon icon="tabler:mail" color="#34d399" width={20} /> <Anchor href="mailto:supawazap@gmail.com" c="emerald.3"> supawazap@gmail.com </Anchor> </Group> </Paper> </Stack> {/* Footer */} <Box ta="center" mt="xl" pt="xl" style={{ borderTop: "1px solid rgba(255,255,255,0.05)" }} > <Text c="dimmed" size="sm"> Â© {new Date().getFullYear()} Supawazap. All rights reserved. </Text> </Box> </Stack> </Container> </Box> ); }
```

# src/app/terms/page.tsx

```tsx
"use client"; import { Box, Container, Title, Text, Stack, rem, Anchor, List, ThemeIcon, Paper, Group, } from "@mantine/core"; import { Icon } from "@iconify/react"; import Link from "next/link"; import Image from "next/image"; // Logo Component const Logo = () => ( <Link href="/" style={{ textDecoration: "none" }}> <Group gap={8} style={{ cursor: "pointer" }} wrap="nowrap"> <Image src="/logo.png" alt="Supawazap Logo" width={32} height={32} style={{ objectFit: "contain", filter: "drop-shadow(0 0 10px rgba(16, 185, 129, 0.4))", }} /> <Text fw={"bold"} size={"xl"} c="white" style={{ letterSpacing: "-0.02em", }} > Supa <Text span c="emerald.5" fw={"bold"} size="xl"> wazap </Text> </Text> </Group> </Link> ); export default function TermsOfServicePage() { return ( <Box style={{ minHeight: "100vh", background: "#030712", }} > {/* Header */} <Box py="lg" px="xl" style={{ borderBottom: "1px solid rgba(255,255,255,0.05)", }} > <Container size="lg"> <Group justify="space-between"> <Logo /> <Link href="/" style={{ color: "var(--mantine-color-emerald-4)", fontSize: "var(--mantine-font-size-sm)", textDecoration: "none", }} > â† Back to Home </Link> </Group> </Container> </Box> {/* Content */} <Container size="md" py={80}> <Stack gap="xl"> {/* Header */} <Stack gap="sm" align="center" ta="center" mb="xl"> <Title order={1} style={{ fontSize: rem(48) }} className="text-gradient" > Terms of Service </Title> <Text c="dimmed" size="lg"> Last updated: December 16, 2024 </Text> </Stack> {/* Introduction */} <Paper p="xl" radius="lg" style={{ background: "rgba(255,255,255,0.02)", border: "1px solid rgba(255,255,255,0.05)", }} > <Stack gap="md"> <Group gap="sm"> <ThemeIcon color="emerald" size="lg" radius="xl"> <Icon icon="tabler:file-text" width={20} /> </ThemeIcon> <Title order={3} c="white"> Agreement to Terms </Title> </Group> <Text c="gray.4" size="md" lh={1.7}> By installing and using Supawazap (&quot;the Extension&quot;), you agree to be bound by these Terms of Service. If you do not agree to these terms, please do not use the Extension. </Text> </Stack> </Paper> {/* Section 1 */} <Stack gap="md"> <Title order={2} c="white" size="h3"> 1. Description of Service </Title> <Text c="gray.4" lh={1.7}> Supawazap is a browser extension that enhances your WhatsApp Web experience with productivity features including: </Text> <List spacing="sm" icon={ <ThemeIcon color="emerald" size={20} radius="xl"> <Icon icon="tabler:check" width={12} /> </ThemeIcon> } > <List.Item> <Text c="gray.3">Broadcast messaging and automation</Text> </List.Item> <List.Item> <Text c="gray.3">Contact management (CRM)</Text> </List.Item> <List.Item> <Text c="gray.3">Workflow automation</Text> </List.Item> <List.Item> <Text c="gray.3">Quick replies and templates</Text> </List.Item> <List.Item> <Text c="gray.3">Data export and backup tools</Text> </List.Item> </List> </Stack> {/* Section 2 */} <Stack gap="md"> <Title order={2} c="white" size="h3"> 2. Acceptable Use </Title> <Text c="gray.4" lh={1.7}> You agree to use Supawazap responsibly and in compliance with all applicable laws. You must NOT use the Extension to: </Text> <List spacing="sm" icon={ <ThemeIcon color="red" size={20} radius="xl"> <Icon icon="tabler:x" width={12} /> </ThemeIcon> } > <List.Item> <Text c="gray.3">Send spam or unsolicited messages</Text> </List.Item> <List.Item> <Text c="gray.3">Harass, abuse, or harm others</Text> </List.Item> <List.Item> <Text c="gray.3">Violate WhatsApp&apos;s Terms of Service</Text> </List.Item> <List.Item> <Text c="gray.3">Engage in illegal activities</Text> </List.Item> <List.Item> <Text c="gray.3">Distribute malware or malicious content</Text> </List.Item> </List> </Stack> {/* Section 3 */} <Stack gap="md"> <Title order={2} c="white" size="h3"> 3. License and Subscription </Title> <Text c="gray.4" lh={1.7}> Supawazap offers both Free and Pro plans: </Text> <List spacing="sm" icon={ <ThemeIcon color="blue" size={20} radius="xl"> <Icon icon="tabler:info-circle" width={12} /> </ThemeIcon> } > <List.Item> <Text c="gray.3"> <strong>Free Plan:</strong> Limited features with usage restrictions </Text> </List.Item> <List.Item> <Text c="gray.3"> <strong>Pro Plan:</strong> Full access to all features with a valid license key </Text> </List.Item> <List.Item> <Text c="gray.3"> License keys are non-transferable and tied to your account </Text> </List.Item> <List.Item> <Text c="gray.3"> Refunds are subject to our refund policy (within 7 days of purchase) </Text> </List.Item> </List> </Stack> {/* Section 4 */} <Stack gap="md"> <Title order={2} c="white" size="h3"> 4. Disclaimer of Warranties </Title> <Text c="gray.4" lh={1.7}> Supawazap is provided &quot;as is&quot; without warranties of any kind. We do not guarantee: </Text> <List spacing="sm" icon={ <ThemeIcon color="orange" size={20} radius="xl"> <Icon icon="tabler:alert-triangle" width={12} /> </ThemeIcon> } > <List.Item> <Text c="gray.3">Uninterrupted or error-free operation</Text> </List.Item> <List.Item> <Text c="gray.3"> Compatibility with future WhatsApp updates </Text> </List.Item> <List.Item> <Text c="gray.3"> That the Extension will meet your specific requirements </Text> </List.Item> </List> </Stack> {/* Section 5 */} <Stack gap="md"> <Title order={2} c="white" size="h3"> 5. Limitation of Liability </Title> <Text c="gray.4" lh={1.7}> To the maximum extent permitted by law, Supawazap and its developers shall not be liable for any indirect, incidental, special, consequential, or punitive damages, including but not limited to: </Text> <List spacing="sm" icon={ <ThemeIcon color="gray" size={20} radius="xl"> <Icon icon="tabler:minus" width={12} /> </ThemeIcon> } > <List.Item> <Text c="gray.3">Loss of profits or revenue</Text> </List.Item> <List.Item> <Text c="gray.3">Loss of data or business interruption</Text> </List.Item> <List.Item> <Text c="gray.3">WhatsApp account restrictions or bans</Text> </List.Item> </List> </Stack> {/* Section 6 */} <Stack gap="md"> <Title order={2} c="white" size="h3"> 6. Changes to Terms </Title> <Text c="gray.4" lh={1.7}> We reserve the right to modify these Terms of Service at any time. Changes will be effective immediately upon posting. Your continued use of the Extension after any changes constitutes acceptance of the new terms. </Text> </Stack> {/* Section 7 */} <Stack gap="md"> <Title order={2} c="white" size="h3"> 7. Contact Us </Title> <Text c="gray.4" lh={1.7}> If you have any questions about these Terms of Service, please contact us at: </Text> <Paper p="md" radius="md" style={{ background: "rgba(16, 185, 129, 0.1)", border: "1px solid rgba(16, 185, 129, 0.2)", }} > <Group gap="sm"> <Icon icon="tabler:mail" color="#34d399" width={20} /> <Anchor href="mailto:supawazap@gmail.com" c="emerald.3"> supawazap@gmail.com </Anchor> </Group> </Paper> </Stack> {/* Footer */} <Box ta="center" mt="xl" pt="xl" style={{ borderTop: "1px solid rgba(255,255,255,0.05)" }} > <Text c="dimmed" size="sm"> Â© {new Date().getFullYear()} Supawazap. All rights reserved. </Text> </Box> </Stack> </Container> </Box> ); }
```

# src/components/BrowserMockup/BrowserMockup.tsx

```tsx
"use client"; import { Box, Group, Paper } from "@mantine/core"; import { useRef, useState, MouseEvent } from "react"; import { WhatsAppSidebar } from "./WhatsAppSidebar"; import { ChatArea } from "./ChatArea"; import { CRMSidebar } from "./CRMSidebar"; import { TabBar } from "./TabBar"; const CONTACT_NAME = "John Doe"; export function BrowserMockup() { const containerRef = useRef<HTMLDivElement>(null); // State untuk rotasi 3D const [rotation, setRotation] = useState({ x: 0, y: 0 }); // State untuk posisi kilau cahaya (Glare) const [glare, setGlare] = useState({ x: 50, y: 50, opacity: 0 }); const [activeCRMTab, setActiveCRMTab] = useState("profile"); const [activeMainTab, setActiveMainTab] = useState("crm"); const handleMouseMove = (e: MouseEvent<HTMLDivElement>) => { if (!containerRef.current) return; const rect = containerRef.current.getBoundingClientRect(); // Hitung posisi mouse relatif terhadap element (0 sampai 1) const xPct = (e.clientX - rect.left) / rect.width; const yPct = (e.clientY - rect.top) / rect.height; // Hitung Rotasi (Maksimal 5 derajat agar elegan, tidak pusing) // xPct 0 (kiri) -> rotateY -5deg // xPct 1 (kanan) -> rotateY 5deg const rotateY = (xPct - 0.5) * 10; const rotateX = (0.5 - yPct) * 10; setRotation({ x: rotateX, y: rotateY }); // Hitung posisi Glare (Cahaya) // Cahaya bergerak berlawanan arah sedikit untuk efek kedalaman setGlare({ x: xPct * 100, y: yPct * 100, opacity: 1, }); }; const handleMouseLeave = () => { // Reset ke posisi diam setRotation({ x: 0, y: 0 }); setGlare((prev) => ({ ...prev, opacity: 0 })); }; return ( <Box ref={containerRef} mt={10} onMouseMove={handleMouseMove} onMouseLeave={handleMouseLeave} style={{ perspective: "1000px", // Perspektif kamera display: "flex", justifyContent: "center", padding: "40px 0", // Ruang untuk animasi naik/turun }} > <Box style={{ transform: `rotateX(${rotation.x}deg) rotateY(${rotation.y}deg)`, transformStyle: "preserve-3d", transition: "transform 0.1s ease-out", // Smooth follow width: "100%", maxWidth: "1100px", position: "relative", }} > {/* --- PREMIUM SHADOW LAYER --- */} {/* Bayangan yang bergerak berlawanan dengan objek untuk efek melayang */} <div style={{ position: "absolute", top: 40, left: 20, right: 20, bottom: -30, background: "rgba(0,0,0,0.5)", filter: "blur(40px)", transform: `translateZ(-50px) translateX(${ rotation.y * -1.5 }px) translateY(${rotation.x * 1.5}px)`, transition: "transform 0.1s ease-out", borderRadius: "50%", zIndex: -1, }} /> {/* --- MAIN BROWSER FRAME --- */} <Paper radius="lg" style={{ background: "#0f172a", // Slate-900 base // Border gradient halus border: "1px solid rgba(255, 255, 255, 0.1)", overflow: "hidden", position: "relative", // Glass reflection static overlay boxShadow: ` 0 0 0 1px rgba(255,255,255,0.05), 0 1px 2px 0 rgba(0,0,0,0.5) `, }} > {/* --- DYNAMIC GLARE OVERLAY (KILAU) --- */} {/* Layer ini memberikan efek sorotan lampu senter di atas kaca */} <div style={{ position: "absolute", inset: 0, zIndex: 50, pointerEvents: "none", mixBlendMode: "overlay", // Kunci agar menyatu dengan warna di bawahnya background: ` radial-gradient( circle at ${glare.x}% ${glare.y}%, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.05) 30%, transparent 70% ) `, opacity: glare.opacity, transition: "opacity 0.3s ease", }} /> {/* --- TOP REFLECTION (SHEEN) --- */} {/* Garis kilau statis di bagian atas untuk kesan material keras/kaca */} <div style={{ position: "absolute", top: 0, left: 0, right: 0, height: "1px", background: "linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent)", zIndex: 51, }} /> {/* Browser Header (Traffic Lights) */} <Group px="md" h={42} style={{ background: "rgba(15, 23, 42, 0.8)", borderBottom: "1px solid rgba(255,255,255,0.05)", }} gap="xs" > {/* Mac Traffic Lights */} <Group gap={8}> <Box w={11} h={11} bg="#FF5F56" style={{ borderRadius: "50%", boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.1)", }} /> <Box w={11} h={11} bg="#FFBD2E" style={{ borderRadius: "50%", boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.1)", }} /> <Box w={11} h={11} bg="#27C93F" style={{ borderRadius: "50%", boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.1)", }} /> </Group> {/* URL Bar */} <Box bg="rgba(0, 0, 0, 0.3)" px="md" py={5} style={{ borderRadius: 8, fontSize: 12, color: "#64748b", flex: 1, textAlign: "center", fontFamily: "var(--font-geist-mono), monospace", display: "flex", alignItems: "center", justifyContent: "center", gap: 8, border: "1px solid rgba(255,255,255,0.05)", boxShadow: "inset 0 1px 2px rgba(0,0,0,0.2)", // Inner shadow for depth }} > <span style={{ color: "#10b981" }}>ðŸ”’</span> web.whatsapp.com </Box> </Group> {/* Interface Layout */} <Box h={650} style={{ display: "flex", overflow: "hidden" }}> <WhatsAppSidebar contactName={CONTACT_NAME} /> <ChatArea contactName={CONTACT_NAME} /> <Group gap={0} h="100%" align="flex-start" bg="transparent"> <CRMSidebar activeTab={activeCRMTab} onTabChange={setActiveCRMTab} /> <TabBar activeTab={activeMainTab} onTabChange={setActiveMainTab} /> </Group> </Box> </Paper> </Box> </Box> ); }
```

# src/components/BrowserMockup/ChatArea.tsx

```tsx
"use client"; import { ActionIcon, Avatar, Box, Group, Paper, Stack, Text, ThemeIcon, Tooltip, } from "@mantine/core"; import { Icon } from "@iconify/react"; interface ChatAreaProps { contactName: string; } export function ChatArea({ contactName }: ChatAreaProps) { return ( <Stack style={{ flex: 1, position: "relative", background: "#0b141a" }} gap={0} > {/* Chat Header */} <Group h={60} px="md" justify="space-between" bg="#202c33" style={{ borderBottom: "1px solid rgba(255,255,255,0.05)" }} > <Group> <Avatar radius="xl" color="emerald" size="sm"> JD </Avatar> <Stack gap={0}> <Text size="sm" fw={600} c="white"> {contactName} </Text> <Text size="xs" c="dimmed"> online </Text> </Stack> </Group> <Group gap="xs"> <Icon icon="tabler:search" width={18} color="#8696a0" /> <Icon icon="tabler:dots-vertical" width={18} color="#8696a0" /> </Group> </Group> {/* Chat Background Pattern */} <Box style={{ flex: 1, backgroundImage: "radial-gradient(rgba(255,255,255,0.05) 1px, transparent 1px)", backgroundSize: "20px 20px", opacity: 0.5, }} /> {/* Messages */} <Box style={{ position: "absolute", bottom: 80, left: 0, right: 0, padding: 20, }} > <Stack gap="sm"> {/* Incoming */} <Group align="flex-start"> <Paper p="sm" radius="md" style={{ background: "#202c33", color: "white", borderTopLeftRadius: 0, maxWidth: "65%", }} > <Text size="sm"> Hi! I noticed that I can send bulk messages using Supawazap. Is it safe for my number? </Text> <Text size="xs" c="dimmed" ta="right" mt={4} style={{ fontSize: 10 }} > 10:30 AM </Text> </Paper> </Group> {/* Outgoing */} <Group align="flex-end" justify="flex-end"> <Paper p="sm" radius="md" style={{ background: "#005c4b", color: "white", borderTopRightRadius: 0, maxWidth: "65%", }} > <Text size="sm"> Absolutely, John! We use 'Smart Batching' and random delays to mimic human behavior, keeping your account safe. </Text> <Group justify="flex-end" gap={4} mt={4}> <Text size="xs" style={{ opacity: 0.7, fontSize: 10 }}> 10:31 AM </Text> <Icon icon="tabler:checks" width={12} style={{ opacity: 0.7 }} /> </Group> </Paper> </Group> </Stack> </Box> {/* Extension Menu Overlay */} <Stack gap="xs" style={{ position: "absolute", bottom: 70, left: 10, zIndex: 10, }} > <Tooltip label="Quick Reply" position="right"> <ActionIcon variant="filled" size={28} radius="xl" color="emerald" style={{ boxShadow: "0 4px 6px rgba(0,0,0,0.3)" }} > <Icon icon="tabler:bolt" width={15} /> </ActionIcon> </Tooltip> <Tooltip label="Copy Number" position="right"> <ActionIcon variant="filled" size={28} radius="xl" color="emerald" style={{ boxShadow: "0 4px 6px rgba(0,0,0,0.3)", }} > <Icon icon="tabler:copy" width={15} /> </ActionIcon> </Tooltip> <Tooltip label="Contact Profile" position="right"> <ActionIcon variant="filled" size={28} radius="xl" color="emerald" style={{ boxShadow: "0 4px 6px rgba(0,0,0,0.3)", }} > <Icon icon="tabler:address-book" width={15} /> </ActionIcon> </Tooltip> <Tooltip label="Schedule Message" position="right"> <ActionIcon variant="filled" size={28} radius="xl" color="emerald" style={{ boxShadow: "0 4px 6px rgba(0,0,0,0.3)", }} > <Icon icon="tabler:calendar-time" width={15} /> </ActionIcon> </Tooltip> </Stack> {/* Input Area */} <Box h={62} px="md" bg="#202c33" style={{ display: "flex", alignItems: "center", gap: 12 }} > <ThemeIcon variant="transparent" color="gray"> <Icon icon="tabler:plus" width={24} /> </ThemeIcon> <Paper style={{ flex: 1, height: 40, background: "#2a3942", display: "flex", alignItems: "center", justifyContent: "space-between", paddingLeft: 16, paddingRight: 8, borderRadius: 8, color: "#8696a0", fontSize: 14, }} > <Text size="sm">Type a message</Text> <Tooltip label="Quick Reply" withArrow> <ActionIcon variant="light" color="emerald" radius="xl" size="sm"> <Icon icon="tabler:bolt" width={14} /> </ActionIcon> </Tooltip> </Paper> <ThemeIcon variant="transparent" color="gray"> <Icon icon="tabler:microphone" width={20} /> </ThemeIcon> </Box> </Stack> ); }
```

# src/components/BrowserMockup/CRMSidebar.tsx

```tsx
"use client"; import { ActionIcon, Avatar, Box, Button, Divider, Group, MultiSelect, NumberInput, Paper, Rating, ScrollArea, SegmentedControl, Select, Stack, Switch, TagsInput, Text, TextInput, ThemeIcon, } from "@mantine/core"; import { Icon } from "@iconify/react"; // Mock data const CONTACT_DATA = { name: "John Doe", number: "15550123456", tags: ["VIP", "Lead", "Negotiation"], }; const CUSTOM_FIELDS_DATA = [ { id: 1, name: "Company", type: "text", value: "Acme Corp USA" }, { id: 2, name: "Deal Value", type: "number", value: 50000 }, { id: 3, name: "LinkedIn", type: "url", value: "linkedin.com/in/johndoe" }, { id: 4, name: "Lead Source", type: "select", value: "Webinar", options: ["Webinar", "Ads"], }, { id: 5, name: "Products", type: "multiSelect", value: ["CRM Bot", "Auto Reply"], options: ["CRM Bot", "Auto Reply", "Broadcast"], }, { id: 6, name: "Active Customer", type: "toggle", value: true }, { id: 7, name: "Interest Level", type: "rating", value: 4 }, { id: 8, name: "Follow-up", type: "date", value: new Date("2025-10-15") }, { id: 9, name: "Contract", type: "document", value: { name: "Agreement_v2.pdf" }, }, ]; // Input styles const inputStyles = { input: { backgroundColor: "rgba(0, 0, 0, 0.3)", border: "1px solid rgba(255, 255, 255, 0.05)", color: "#f8fafc", fontSize: "12px", height: "32px", minHeight: "32px", "&:focus": { borderColor: "#10b981", }, }, label: { color: "#94a3b8", fontSize: "11px", fontWeight: 500, marginBottom: 4, }, }; // Field Renderer Component const FieldRenderer = ({ field }: { field: any }) => { switch (field.type) { case "text": return ( <TextInput id={`crm-field-${field.id}`} label={field.name} defaultValue={field.value} styles={inputStyles} /> ); case "number": return ( <NumberInput id={`crm-field-${field.id}`} label={field.name} defaultValue={field.value} thousandSeparator="," leftSection={ <Text size="xs" c="dimmed"> $ </Text> } styles={inputStyles} /> ); case "url": return ( <TextInput id={`crm-field-${field.id}`} label={field.name} defaultValue={field.value} rightSection={ <ActionIcon size="xs" variant="transparent" c="blue.4"> <Icon icon="tabler:external-link" width={12} /> </ActionIcon> } styles={inputStyles} /> ); case "select": return ( <Select id={`crm-field-${field.id}`} label={field.name} defaultValue={field.value} data={field.options} styles={inputStyles} comboboxProps={{ withinPortal: false }} /> ); case "multiSelect": return ( <MultiSelect id={`crm-field-${field.id}`} label={field.name} defaultValue={field.value} data={field.options} styles={{ ...inputStyles, pill: { backgroundColor: "rgba(56, 189, 248, 0.15)", color: "#7dd3fc", fontSize: "10px", height: "18px", }, input: { ...inputStyles.input, height: "auto", minHeight: "32px" }, }} comboboxProps={{ withinPortal: false }} /> ); case "toggle": return ( <Group justify="space-between" mt="xs" p={8} style={{ backgroundColor: "rgba(255,255,255,0.02)", borderRadius: 6, border: "1px solid rgba(255,255,255,0.05)", }} > <Text size="xs" fw={500} c="gray.3"> {field.name} </Text> <Switch id={`crm-field-${field.id}`} defaultChecked={field.value} color="emerald" size="sm" thumbIcon={ field.value ? ( <Icon icon="tabler:check" width={10} color="var(--mantine-color-emerald-6)" /> ) : ( <Icon icon="tabler:x" width={10} color="gray" /> ) } /> </Group> ); case "rating": return ( <Stack gap={4}> <Text size="xs" fw={500} c="gray.5" style={{ fontSize: "11px" }}> {field.name} </Text> <Group p={6} style={{ backgroundColor: "rgba(255,255,255,0.02)", borderRadius: 6, }} > <Rating name={`crm-rating-${field.id}`} defaultValue={field.value} color="yellow" size="sm" /> </Group> </Stack> ); case "date": return null; case "document": return ( <Stack gap={4}> <Text size="xs" fw={500} c="gray.5" style={{ fontSize: "11px" }}> {field.name} </Text> <Group p={6} style={{ border: "1px dashed rgba(255,255,255,0.2)", borderRadius: 6, backgroundColor: "rgba(0,0,0,0.2)", }} > <ThemeIcon variant="light" color="blue" size="md"> <Icon icon="tabler:file-text" width={14} /> </ThemeIcon> <Stack gap={0} style={{ flex: 1 }}> <Text size="xs" truncate> {field.value.name} </Text> <Text size="xs" c="dimmed" style={{ fontSize: 9 }}> PDF Document </Text> </Stack> <ActionIcon variant="subtle" color="red" size="sm"> <Icon icon="tabler:trash" width={12} /> </ActionIcon> </Group> </Stack> ); default: return null; } }; interface CRMSidebarProps { activeTab: string; onTabChange: (tab: string) => void; } export function CRMSidebar({ activeTab, onTabChange }: CRMSidebarProps) { return ( <Paper w={340} h="100%" radius={0} style={{ backgroundColor: "rgba(0, 0, 0, 0.85)", backdropFilter: "blur(24px)", borderLeft: "1px solid rgba(255, 255, 255, 0.1)", display: "flex", flexDirection: "column", }} > {/* Header */} <Stack p="md" gap="sm" style={{ borderBottom: "1px solid rgba(255,255,255,0.1)", background: "linear-gradient(90deg, transparent, rgba(255,255,255,0.02), transparent)", }} > <Group justify="space-between" align="center"> <Group gap={10}> <ThemeIcon variant="light" size="lg" color="emerald" radius="md"> <Icon icon="tabler:user-circle" width={20} /> </ThemeIcon> <Text fw={700} size="md" style={{ background: "linear-gradient(to right, #a7f3d0, #34d399)", WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent", }} > Contact Info </Text> </Group> <ActionIcon variant="subtle" color="gray" size="sm"> <Icon icon="tabler:x" width={16} /> </ActionIcon> </Group> {/* Navigation Tabs */} <SegmentedControl name="crm-tabs" value={activeTab} onChange={onTabChange} fullWidth size="xs" radius="md" color="emerald" data={[ { value: "profile", label: "Profile" }, { value: "notes", label: "Notes" }, { value: "tasks", label: "Tasks" }, ]} className="crm-tabs" styles={{ root: { backgroundColor: "rgba(255, 255, 255, 0.05)" }, label: { color: "#94a3b8" }, }} /> <style jsx global>{` .crm-tabs .mantine-SegmentedControl-label[data-active] { color: #ffffff !important; } `}</style> </Stack> {/* Form Content */} <ScrollArea style={{ flex: 1 }} p="md"> <Stack gap="md"> {/* Identity */} <Group align="flex-start" wrap="nowrap" gap="sm"> <Avatar size="lg" radius="xl" color="emerald" variant="filled"> JD </Avatar> <Stack gap={6} style={{ flex: 1 }}> <TextInput id="crm-name" label="Name" defaultValue={CONTACT_DATA.name} variant="filled" styles={inputStyles} /> <TextInput id="crm-number" label="Number" defaultValue={CONTACT_DATA.number} variant="filled" rightSection={ <Icon icon="tabler:copy" width={12} style={{ opacity: 0.5 }} /> } styles={inputStyles} /> </Stack> </Group> {/* Tags */} <TagsInput id="crm-tags" label="Tags" placeholder="Add tag..." defaultValue={CONTACT_DATA.tags} variant="filled" styles={{ ...inputStyles, pill: { backgroundColor: "rgba(16, 185, 129, 0.15)", color: "#6ee7b7", fontWeight: 600, textTransform: "uppercase", fontSize: "9px", letterSpacing: "0.05em", height: "20px", }, input: { ...inputStyles.input, minHeight: "auto", padding: "4px", }, }} /> <Divider color="rgba(255,255,255,0.1)" label="Custom Fields" labelPosition="center" /> {/* Custom Fields */} {CUSTOM_FIELDS_DATA.map((field) => ( <FieldRenderer key={field.id} field={field} /> ))} <Box h={20} /> </Stack> </ScrollArea> {/* Footer */} <Box p="md" style={{ borderTop: "1px solid rgba(255,255,255,0.1)" }}> <Button fullWidth variant="outline" color="emerald" size="xs" leftSection={<Icon icon="tabler:settings" width={14} />} style={{ borderColor: "rgba(16, 185, 129, 0.3)", color: "#34d399", }} > Manage Fields </Button> </Box> </Paper> ); }
```

# src/components/BrowserMockup/index.ts

```ts
export { BrowserMockup } from "./BrowserMockup"; export { WhatsAppSidebar } from "./WhatsAppSidebar"; export { ChatArea } from "./ChatArea"; export { CRMSidebar } from "./CRMSidebar"; export { TabBar } from "./TabBar";
```

# src/components/BrowserMockup/TabBar.tsx

```tsx
"use client"; import { ActionIcon, Box, Stack, Tooltip } from "@mantine/core"; import { Icon } from "@iconify/react"; interface TabBarProps { activeTab: string; onTabChange: (tab: string) => void; } export function TabBar({ activeTab, onTabChange }: TabBarProps) { return ( <Stack w={50} h="100%" bg="#0f172a" style={{ borderLeft: "1px solid rgba(255,255,255,0.1)" }} align="center" py="sm" gap={0} > <Stack gap={4}> <TabIcon icon="tabler:broadcast" label="Broadcast" active={activeTab === "broadcast"} onClick={() => onTabChange("broadcast")} /> <TabIcon icon="tabler:robot" label="Workflow" active={activeTab === "workflow"} onClick={() => onTabChange("workflow")} /> <TabIcon icon="tabler:bolt" label="Quick Reply" active={activeTab === "quick-reply"} onClick={() => onTabChange("quick-reply")} /> <TabIcon icon="tabler:address-book" label="CRM" active={activeTab === "crm"} onClick={() => onTabChange("crm")} /> <TabIcon icon="tabler:message-plus" label="Direct" active={activeTab === "direct"} onClick={() => onTabChange("direct")} /> <TabIcon icon="tabler:tools" label="Tools" active={activeTab === "tools"} onClick={() => onTabChange("tools")} /> <TabIcon icon="tabler:history-toggle" label="Status" active={activeTab === "status"} onClick={() => onTabChange("status")} /> <TabIcon icon="tabler:eye-off" label="Privacy" active={activeTab === "privacy"} onClick={() => onTabChange("privacy")} /> </Stack> <Stack mt="auto" gap={4}> <TabIcon icon="tabler:settings" label="Settings" active={activeTab === "settings"} onClick={() => onTabChange("settings")} /> </Stack> </Stack> ); } // Update TabIcon to accept onClick interface TabIconProps { icon: string; active?: boolean; label: string; onClick?: () => void; } function TabIcon({ icon, active, label, onClick }: TabIconProps) { return ( <Tooltip label={label} position="right" withArrow> <ActionIcon variant="transparent" size={40} onClick={onClick} style={{ color: active ? "#10b981" : "#94a3b8", // Add a subtle background for active state if desired backgroundColor: active ? "rgba(16, 185, 129, 0.1)" : "transparent", }} > {active && ( <Box style={{ position: "absolute", left: 0, top: "15%", bottom: "15%", width: 2, background: "var(--mantine-color-emerald-5)", borderRadius: "0 4px 4px 0", boxShadow: "0 0 8px var(--mantine-color-emerald-5)", }} /> )} <Icon icon={icon} width={22} strokeWidth={1.5} /> </ActionIcon> </Tooltip> ); }
```

# src/components/BrowserMockup/WhatsAppSidebar.tsx

```tsx
"use client"; import { Avatar, Box, Group, ScrollArea, Skeleton, Stack, Text, TextInput, ThemeIcon, } from "@mantine/core"; import { Icon } from "@iconify/react"; interface WhatsAppSidebarProps { contactName: string; } export function WhatsAppSidebar({ contactName }: WhatsAppSidebarProps) { return ( <Stack w={280} h="100%" gap={0} style={{ borderRight: "1px solid rgba(255,255,255,0.05)", background: "#111b21", }} visibleFrom="sm" > {/* Header */} <Group h={60} px="md" justify="space-between" bg="#202c33" style={{ borderRight: "1px solid rgba(255,255,255,0.05)" }} > <Avatar size="md" src="https://i.pravatar.cc/150?img=11" /> <Group gap="sm"> <ThemeIcon variant="transparent" c="dimmed"> <Icon icon="tabler:users" width={20} /> </ThemeIcon> <ThemeIcon variant="transparent" c="dimmed"> <Icon icon="tabler:message-circle" width={20} /> </ThemeIcon> <ThemeIcon variant="transparent" c="dimmed"> <Icon icon="tabler:dots-vertical" width={20} /> </ThemeIcon> </Group> </Group> {/* Search Bar */} <Box p="sm" style={{ borderBottom: "1px solid rgba(255,255,255,0.05)" }}> <TextInput id="whatsapp-search" placeholder="Search" leftSection={<Icon icon="tabler:search" width={14} />} radius="md" styles={{ input: { backgroundColor: "#202c33", border: "none", color: "#fff", fontSize: 13, }, }} /> </Box> {/* Chat List with Privacy Blur */} <ScrollArea style={{ flex: 1 }}> {[1, 2, 3, 4, 5, 6].map((i) => ( <Group key={i} p="sm" style={{ cursor: "pointer", backgroundColor: i === 1 ? "#2a3942" : "transparent", borderBottom: "1px solid rgba(255,255,255,0.03)", }} > <Skeleton height={40} width={40} circle animate={false} opacity={0.3} /> <Stack gap={4} style={{ flex: 1 }}> <Group justify="space-between"> <Box style={{ filter: i !== 1 ? "blur(4px)" : "none" }}> <Text size="sm" fw={500} c="white"> {i === 1 ? contactName : "Hidden Contact"} </Text> </Box> <Text size="xs" c="dimmed"> 10:3{i} AM </Text> </Group> <Box style={{ filter: "blur(4px)" }}> <Text size="xs" c="dimmed" lineClamp={1}> Hey, I was wondering if you could send me... </Text> </Box> </Stack> </Group> ))} </ScrollArea> </Stack> ); }
```

# src/components/CTA.tsx

```tsx
"use client"; import { Box, Button, Container, Group, Stack, Text, Title, rem, ThemeIcon, Paper, Badge, } from "@mantine/core"; import { Icon } from "@iconify/react"; export function CTA() { return ( <Box py={{ base: 60, md: 120 }} px="md" style={{ position: "relative" }}> {/* Ambient Background Glow - Memberikan kedalaman di belakang kartu */} <Box style={{ position: "absolute", top: "50%", left: "50%", transform: "translate(-50%, -50%)", width: "100%", maxWidth: "900px", height: "500px", background: "radial-gradient(circle, rgba(16, 185, 129, 0.15) 0%, transparent 60%)", filter: "blur(60px)", zIndex: 0, pointerEvents: "none", }} /> <Container size="lg" style={{ position: "relative", zIndex: 1 }}> <Paper radius={32} p={{ base: 40, md: 80 }} style={{ // Premium Dark Glass Background backgroundColor: "rgba(2, 6, 23, 0.7)", // Very dark slate (almost black) backdropFilter: "blur(24px) saturate(180%)", WebkitBackdropFilter: "blur(24px) saturate(180%)", // Gradient Border halus border: "1px solid rgba(255, 255, 255, 0.08)", boxShadow: "0 0 0 1px rgba(16, 185, 129, 0.1), 0 20px 60px -20px rgba(0, 0, 0, 0.5)", position: "relative", overflow: "hidden", }} > {/* --- DECORATIVE: BACKGROUND GRID PATTERN --- */} <Box style={{ position: "absolute", inset: 0, backgroundImage: "linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px)", backgroundSize: "40px 40px", opacity: 0.4, pointerEvents: "none", }} /> {/* --- DECORATIVE: TOP GLOW BEAM --- */} <Box style={{ position: "absolute", top: 0, left: "50%", transform: "translateX(-50%)", width: "60%", height: "1px", background: "linear-gradient(90deg, transparent, #10b981, transparent)", boxShadow: "0 0 30px 2px rgba(16, 185, 129, 0.4)", }} /> {/* --- CONTENT --- */} <Stack align="center" gap="xl" style={{ position: "relative", zIndex: 2 }} > {/* Headline */} <Title order={2} ta="center" style={{ fontSize: rem(52), // Lebih besar fontWeight: 800, lineHeight: 1.1, color: "white", letterSpacing: "-0.02em", }} > 10x Your Workflow. <br /> <Text span inherit style={{ // Gradient Text Emerald Premium background: "linear-gradient(to right, #6ee7b7, #10b981, #34d399)", WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent", filter: "drop-shadow(0 0 20px rgba(16, 185, 129, 0.3))", }} > Zero Extra Effort. </Text> </Title> {/* Subtext */} <Text c="dimmed" ta="center" maw={600} size="xl" lh={1.6}> Ditch the manual copy-pasting. Automate your follow-ups, organize your leads, and reclaim 10+ hours of your week. </Text> {/* Action Buttons */} <Group mt="md" gap="md"> <Button size="xl" radius="xl" h={60} className="btn-primary-action" // Menggunakan class global yang sudah ada leftSection={<Icon icon="logos:chrome" fontSize={24} />} style={{ fontSize: rem(18), paddingLeft: rem(32), paddingRight: rem(32), }} > Get Supawazap for Chrome </Button> </Group> {/* Trust Signals / Footer Text */} <Group gap="xl" mt="sm" c="dimmed" style={{ opacity: 0.7 }}> <Group gap={6}> <Icon icon="tabler:bolt" color="#10b981" width={18} /> <Text size="sm">2-Minute Setup</Text> </Group> <Box w={1} h={16} bg="rgba(255,255,255,0.1)" /> <Group gap={6}> <Icon icon="tabler:shield-lock" color="#10b981" width={18} /> <Text size="sm">100% Secure</Text> </Group> <Box w={1} h={16} bg="rgba(255,255,255,0.1)" /> <Group gap={6}> <Icon icon="tabler:circle-check" color="#10b981" width={18} /> <Text size="sm">Cancel Anytime</Text> </Group> </Group> </Stack> </Paper> </Container> </Box> ); }
```

# src/components/FAQ/FAQ.tsx

```tsx
"use client"; import { Box, Container, Title, Text, Accordion, ThemeIcon, rem, SimpleGrid, } from "@mantine/core"; import { Icon } from "@iconify/react"; const faqs = [ { value: "requirements", question: "Do I need the WhatsApp API or a specific OS?", answer: "No API required. Supawazap works directly on top of WhatsApp Web. It works on any operating system (Windows, Mac, Linux) as long as you have the Google Chrome, Edge, or Brave browser installed.", }, { value: "browsers", question: "Which browsers are supported?", answer: "Supawazap works on all Chromium-based browsers: Google Chrome, Microsoft Edge, Brave, Opera, and Arc.", }, { value: "privacy", question: "Is my data safe? Do you collect my contacts or messages?", answer: "100% safe. Supawazap uses a 'Local-First' architectureâ€”all your data (contacts, messages, templates) is stored only on your device in IndexedDB. We never collect, store, or access your personal data or your customers' information.", }, { value: "activation", question: "How do I activate my Pro license?", answer: "After purchasing, you'll receive a 16-character license key (xxxx-xxxx-xxxx-xxxx) via email. Open Supawazap, click the key icon (Activate) in the sidebar, enter your license key, then click the Activate button. Your Pro features will be unlocked instantly.", }, { value: "support", question: "I can't find my answer here. How can I get help?", answer: "No worries! You can reach our support team anytime at supawazap@gmail.com", }, ]; export function FAQ() { return ( <Box py={{ base: 60, md: 120 }} id="faq"> <Container size="lg"> <SimpleGrid cols={{ base: 1, md: 2 }} spacing={60}> {/* Left Side: Title & Context */} <Box style={{ position: "sticky", top: 120 }}> <ThemeIcon size={60} radius="xl" variant="light" color="emerald" mb="xl" style={{ backgroundColor: "rgba(16, 185, 129, 0.1)", border: "1px solid rgba(16, 185, 129, 0.2)", }} > <Icon icon="tabler:help-hexagon" width={32} /> </ThemeIcon> <Title order={2} style={{ fontSize: rem(42), lineHeight: 1.1 }} mb="md" > Frequently Asked <br /> <Text span inherit style={{ background: "linear-gradient(to right, #34d399, #10b981)", WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent", }} > Questions </Text> </Title> <Text c="dimmed" size="lg" maw={450}> Everything you need to know about safety, privacy, and how Supawazap helps you scale your business. </Text> {/* Decor Blob */} <Box visibleFrom="md" style={{ position: "absolute", top: 200, left: -100, width: 300, height: 300, background: "radial-gradient(circle, rgba(16, 185, 129, 0.08) 0%, transparent 70%)", zIndex: -1, pointerEvents: "none", }} /> </Box> {/* Right Side: Accordion */} <Accordion variant="separated" radius="lg" styles={{ item: { backgroundColor: "rgba(255, 255, 255, 0.03)", border: "1px solid rgba(255, 255, 255, 0.05)", transition: "all 0.3s ease", marginBottom: rem(16), }, control: { color: "white", padding: rem(20), }, label: { fontWeight: 600, fontSize: rem(16), }, content: { padding: rem(20), paddingTop: 0, }, chevron: { color: "#34d399", }, }} chevron={<Icon icon="tabler:chevron-down" width={20} />} > {faqs.map((faq) => ( <Accordion.Item key={faq.value} value={faq.value}> <Accordion.Control>{faq.question}</Accordion.Control> <Accordion.Panel> <Text size="sm" c="gray.4" lh={1.6}> {faq.answer} </Text> </Accordion.Panel> </Accordion.Item> ))} </Accordion> </SimpleGrid> </Container> </Box> ); }
```

# src/components/FeaturedOn/FeaturedOn.tsx

```tsx
"use client"; import { useState } from "react"; import { Box, Container, Stack, Text, Title, rem, Group, Flex, Collapse, } from "@mantine/core"; import { Icon } from "@iconify/react"; // Primary badges - always visible const PRIMARY_BADGES = [ { src: "https://api.producthunt.com/widgets/embed-image/v1/featured.svg?post_id=YOUR_POST_ID&theme=dark", alt: "Product Hunt", href: "https://www.producthunt.com/", width: 200, height: 45, }, { src: "https://www.tinylaunch.com/tinylaunch_badge_1.svg", alt: "TinyLaunch", href: "https://www.tinylaunch.com/", width: 160, height: 40, }, { src: "https://fazier.com/api/v1/public/badges/embed_image.svg?launch_id=YOUR_LAUNCH_ID&badge_type=daily&theme=dark", alt: "Fazier", href: "https://fazier.com/", width: 215, height: 50, }, { src: "https://www.uneed.best/POTD2.png", alt: "Uneed", href: "https://www.uneed.best/", width: 180, height: 50, }, ]; // Secondary badges - shown when "And More" is clicked const SECONDARY_BADGES = [ { src: "https://www.founderplug.com/badges/2TopProduct.png", alt: "FounderPlug", href: "https://www.founderplug.com/", width: 160, height: 50, }, { src: "https://rankinpublic.xyz/api/badges/badge3.png?site=supawazap", alt: "RankInPublic", href: "https://rankinpublic.xyz/", width: 140, height: 40, }, { src: "https://saasboilerplates.dev/badges/Neutral.png", alt: "Best SaaS Boilerplates", href: "https://saasboilerplates.dev/", width: 200, height: 50, }, ]; const BadgeItem = ({ badge }: { badge: (typeof PRIMARY_BADGES)[0] }) => ( <Box component="a" href={badge.href} target="_blank" rel="noopener noreferrer" style={{ transition: "all 0.2s ease", opacity: 0.85, }} onMouseEnter={(e) => { e.currentTarget.style.opacity = "1"; e.currentTarget.style.transform = "translateY(-3px)"; }} onMouseLeave={(e) => { e.currentTarget.style.opacity = "0.85"; e.currentTarget.style.transform = "translateY(0)"; }} > {/* eslint-disable-next-line @next/next/no-img-element */} <img src={badge.src} alt={badge.alt} width={badge.width} height={badge.height} style={{ objectFit: "contain", borderRadius: rem(8), }} /> </Box> ); export function FeaturedOn() { const [showMore, setShowMore] = useState(false); return ( <Box py={80}> <Container size="lg"> <Stack align="center" gap="xl"> {/* Title */} <Stack align="center" gap="xs" ta="center"> <Title order={2} style={{ fontSize: rem(36) }} className="text-gradient" > Featured on leading startup platforms </Title> <Text c="dimmed" size="lg" maw={600}> Proudly featured across startup platforms where founders and makers launch their ideas. </Text> </Stack> {/* Primary Badges */} <Flex wrap="wrap" gap="lg" justify="center" align="center" maw={900}> {PRIMARY_BADGES.map((badge, index) => ( <BadgeItem key={index} badge={badge} /> ))} </Flex> {/* Secondary Badges - Collapsible */} <Collapse in={showMore}> <Flex wrap="wrap" gap="lg" justify="center" align="center" maw={900} mt="md" > {SECONDARY_BADGES.map((badge, index) => ( <BadgeItem key={index} badge={badge} /> ))} </Flex> </Collapse> {/* And More / Show Less Button */} <Group gap="xs" onClick={() => setShowMore(!showMore)} style={{ cursor: "pointer", opacity: 0.7, transition: "opacity 0.2s", }} onMouseEnter={(e) => { e.currentTarget.style.opacity = "1"; }} onMouseLeave={(e) => { e.currentTarget.style.opacity = "0.7"; }} > <Text c="dimmed" size="sm"> {showMore ? "Show Less" : "And More"} </Text> <Icon icon={showMore ? "tabler:minus" : "tabler:plus"} width={14} color="#9ca3af" /> </Group> </Stack> </Container> </Box> ); }
```

# src/components/Features/Features.tsx

```tsx
"use client"; import { Box, Container, Group, List, SimpleGrid, Stack, Text, ThemeIcon, Title, rem, Paper, } from "@mantine/core"; import { Icon } from "@iconify/react"; const features = [ { title: "Your CRM, Built Into WhatsApp", description: "Transform WhatsApp Web into a complete customer database. Manage leads directly from the chat interfaceâ€”no switching apps.", points: [ "Save contacts with Custom Fields (Text, Date, Select, Rating, etc.)", "Organize contacts using Tags for instant categorization", "Interaction history notes per customer", "Smart Segments for dynamic contact filtering (AND/OR logic)", "Import contacts from Excel, Phone Sync, or Group Members", "Quickly search contacts by name, number, tags, or custom fields", "Customizable Contact View columns for your workflow", ], imagePosition: "right", videoId: "dQw4w9WgXcQ", // Replace with actual YouTube video ID }, { title: "Build Once, Automate Forever", description: "Create intelligent chatbots in minutes, not months. Our Visual Builder turns your ideas into 24/7 automated assistants.", points: [ "Trigger flows based on Incoming Message Keywords, Exact Match, or Any Message", "Auto actions: Reply, Add/Remove Tags, Update CRM Fields, or Archive Chat", "Personal Trigger scope for personal chats or specific Group IDs", "Dynamic Variables: Insert {sender_name}, {date}, {time} into automated replies", "Rich Media Replies: Send Images, Videos, Audio, or Documents automatically", "Wait & Delay steps to create natural conversational pacing", ], imagePosition: "left", videoId: "dQw4w9WgXcQ", // Replace with actual YouTube video ID }, { title: "Bulk Messaging, Zero Risk", description: "Transform tedious manual messaging into one-click campaigns. Our intelligent engine handles timing, pacing, and safety.", points: [ "Smart Batching: Automatically splits large lists with rest periods.", "Typing Presence: Shows 'Typing...' status before sending for a natural feel.", "Randomized Delays between messages to simulate human behavior", "Smart Scheduler: Schedule broadcasts for specific future dates and times", "Post-Broadcast Automation: Auto-tag or Archive chat based on delivery status", "Automatic Number Validation before sending to prevent errors", "Track delivery status for each recipient", "Export delivery reports for team analysis", ], imagePosition: "right", videoId: "dQw4w9WgXcQ", // Replace with actual YouTube video ID }, ]; export function Features() { return ( <Box py={100} id="features"> <Container size="lg"> <Stack align="center" mb={{ base: 60, md: 100 }}> <Title order={2} ta="center" style={{ fontSize: rem(42) }} className="text-gradient" > Automate. Organize. Scale. </Title> <Text c="dimmed" ta="center" maw={600} size="lg"> Built for power users who need more than just a chat app. Experience the next evolution of WhatsApp Web. </Text> </Stack> <Stack gap={120}> {features.map((feature, index) => ( <Group key={index} gap={80} align="center" style={{ flexDirection: feature.imagePosition === "right" ? "row" : "row-reverse", }} visibleFrom="md" > {/* Text Content */} <Stack style={{ flex: 1 }}> <Title order={2} style={{ fontSize: rem(35), fontWeight: 700 }}> {feature.title} </Title> <Text c="dimmed" size="lg" mt="md" style={{ fontSize: rem(20) }} > {feature.description} </Text> <List mt={30} spacing="md" size="lg" icon={ <ThemeIcon color="emerald" size={24} radius="xl"> <Icon icon="tabler:check" width={14} /> </ThemeIcon> } > {feature.points.map((point, idx) => ( <List.Item key={idx} c="white"> <Text span c="gray.3"> {point} </Text> </List.Item> ))} </List> </Stack> {/* YouTube Video Embed */} <Box style={{ flex: 1 }}> <Paper radius="xl" h={400} p={0} style={{ background: "#000", border: "1px solid var(--bg-glass-overlay)", position: "relative", overflow: "hidden", }} > <iframe width="100%" height="100%" src={`https://www.youtube.com/embed/${feature.videoId}?autoplay=1&mute=1&loop=1&playlist=${feature.videoId}&controls=0&showinfo=0&rel=0&modestbranding=1`} title={feature.title} frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen style={{ position: "absolute", top: "50%", left: "50%", width: "177.78%", // 16:9 aspect ratio compensation height: "177.78%", transform: "translate(-50%, -50%)", borderRadius: "inherit", pointerEvents: "none", }} /> </Paper> </Box> </Group> ))} {/* Mobile View (Consistent Order) */} <Stack gap={100} hiddenFrom="md"> {features.map((feature, index) => ( <Stack key={index} gap="xl"> {/* Visual First on Mobile for Impact, or Text First? Text First is usually safer for context. Let's do Text First. */} <Stack> <Title order={2} fz={32} fw={800} lh={1.2}> {feature.title} </Title> <Text c="dimmed" size="md"> {feature.description} </Text> </Stack> <Paper radius="xl" h={250} style={{ background: "#000", border: "1px solid var(--bg-glass-overlay)", position: "relative", overflow: "hidden", width: "100%", }} > <iframe width="100%" height="100%" src={`https://www.youtube.com/embed/${feature.videoId}?autoplay=1&mute=1&loop=1&playlist=${feature.videoId}&controls=0&showinfo=0&rel=0&modestbranding=1`} title={feature.title} frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen style={{ position: "absolute", top: "50%", left: "50%", width: "177.78%", height: "177.78%", transform: "translate(-50%, -50%)", borderRadius: "inherit", pointerEvents: "none", }} /> </Paper> <List spacing="sm" size="md" icon={ <ThemeIcon color="emerald" size={20} radius="xl"> <Icon icon="tabler:check" width={12} /> </ThemeIcon> } > {feature.points.map((point, idx) => ( <List.Item key={idx} c="white"> <Text span c="gray.3" size="sm"> {point} </Text> </List.Item> ))} </List> </Stack> ))} </Stack> </Stack> </Container> </Box> ); }
```

# src/components/Features/SecondaryFeatures.tsx

```tsx
"use client"; import { Box, Container, SimpleGrid, Stack, Text, ThemeIcon, Title, rem, Badge, Group, Button, } from "@mantine/core"; import { Icon } from "@iconify/react"; import { SpotlightCard } from "../SpotlightCard"; // Import komponen baru import { PremiumCard } from "../PremiumCard"; const secondaryFeatures = [ { emoji: "âš¡", title: "Smart Quick Replies", description: "Reply in milliseconds. Save text, image, video, or PDF templates and send them with a single click.", }, { emoji: "ðŸ—“ï¸", title: "Status Scheduler", description: "Automate your 'Story Selling'. Schedule WhatsApp Status updates (Text/Media) for the entire week in advance.", }, { emoji: "ðŸ‘¥", title: "Community Scraper", description: "Turn groups into leads. Extract member data from WhatsApp Groups and Communities to build your marketing database.", }, { emoji: "âœ…", title: "Number Validator", description: "Clean your database. Bulk validate thousands of numbers to separate active accounts from invalid ones before broadcasting.", }, { emoji: "ðŸ“‚", title: "Bulk Chat Manager", description: "Achieve Inbox Zero instantly. Archive, Pin, or Mute hundreds of chats at once to keep your workspace organized.", }, { emoji: "ðŸ”’", title: "Privacy Blur", description: "Work safely in public. Blur sensitive info like contact names, photos, and message content automatically. Unblur on hover.", }, { emoji: "ðŸ‘‹", title: "Direct Chat", description: "Start conversations instantly without saving the number to your phone contacts. Supports 'Typing...' simulation.", }, { emoji: "ðŸ”—", title: "Link Generator", description: "Turn traffic into chats. Generate custom `wa.me` links with pre-filled messages for your ads and social bio.", }, { emoji: "ðŸ“¥", title: "Full Data Export", description: "You own your data. Export chat history, group members, or CRM contacts to Excel (XLSX), CSV, or JSON anytime.", }, { emoji: "ðŸ”€", title: "Spintax Engine", description: "Avoid spam detection. Automatically randomize greetings and phrases (e.g., {Hi|Hello}) so every message looks unique.", }, { emoji: "ðŸŽ¯", title: "Smart Filter Segments", description: "Target the right audience. Create dynamic rules to filter contacts by tags, country, or activity for laser-focused campaigns.", }, { emoji: "ðŸ˜€", title: "Emoji & Formatting", description: "Express yourself clearly. Built-in emoji picker and rich text tools (Bold, Italic, Strikethrough) for perfect message composition.", }, { emoji: "â°", title: "Personal Message Scheduler", description: "Never miss a follow-up. Schedule messages for individual chats to be delivered automatically at a future time.", }, { emoji: "âœ¨", title: "AI Writer Assistant", description: "Your personal writing genius. Fix grammar, rewrite text, or change the tone of your messages instantly before sending.", comingSoon: true, }, { emoji: "ðŸ“", title: "Custom Chat Tabs", description: "Organize your chaos. Create custom tabs (Labels) like 'Leads', 'VIP', or 'Family' to categorize your chats for easy access.", comingSoon: true, }, { emoji: "ðŸ“¢", title: "Group Link Manager", description: "Track and manage your group invite links efficiently. Monitor traffic and join requests from a single dashboard.", comingSoon: true, }, { emoji: "ðŸŒ", title: "AI Translate", description: "Break language barriers. Translation for incoming messages.", comingSoon: true, }, { emoji: "ðŸ’¾", title: "Chat Backup", description: "Secure your business data. Automatically backup chats, media, and contacts to your computer or cloud storage.", comingSoon: true, }, ]; export function SecondaryFeatures() { return ( <Box py={100} style={{ position: "relative", zIndex: 1 }}> <Container size="lg" style={{ position: "relative", zIndex: 1 }}> <Stack align="center" mb={{ base: 40, md: 80 }}> <Title order={2} ta="center" style={{ fontSize: rem(42) }} className="text-gradient" > Built for Speed, Designed for Results </Title> <Text c="dimmed" ta="center" maw={600} size="lg"> Powerful utilities that save hours every dayâ€”all included in one extension. </Text> </Stack> <SimpleGrid cols={{ base: 1, sm: 2, md: 3 }} spacing={20}> {secondaryFeatures.map((feature: any, index: number) => ( // Implementasi SpotlightCard <PremiumCard key={index} className="feature-card-group"> <Stack justify="space-between" h="100%" gap="sm" style={{ position: "relative", zIndex: 10 }} > <Box> <Group justify="space-between" align="start" mb="md"> <ThemeIcon size={50} radius="md" variant="light" color="gray" style={{ backgroundColor: "rgba(255, 255, 255, 0.05)", border: "1px solid rgba(255, 255, 255, 0.1)", color: "#fff", }} > <Text style={{ fontSize: rem(26) }}>{feature.emoji}</Text> </ThemeIcon> {feature.comingSoon && ( <Badge variant="light" color="orange" size="sm" style={{ backgroundColor: "rgba(251, 146, 60, 0.1)", color: "#fb923c", border: "1px solid rgba(251, 146, 60, 0.2)", }} > Coming Soon </Badge> )} </Group> <Text fz="lg" fw={600} mb="xs" c="white"> {feature.title} </Text> <Text c="dimmed" size="sm" lh={1.6}> {feature.description} </Text> </Box> </Stack> {/* Hover Overlay - Temporarily disabled */} {/* <Box className="feature-overlay" style={{ position: "absolute", inset: 0, backgroundColor: "rgba(0, 0, 0, 0.6)", backdropFilter: "blur(4px)", display: "flex", alignItems: "center", justifyContent: "center", opacity: 0, transition: "opacity 0.2s ease", zIndex: 20, borderRadius: "inherit", }} > <Button size="md" radius="xl" className="btn-primary-action view-demo-btn" leftSection={<Icon icon="tabler:eye" width={18} />} style={{ transform: "translateY(10px)", transition: "transform 0.2s ease", }} > View Demo </Button> </Box> */} </PremiumCard> ))} </SimpleGrid> </Container> </Box> ); }
```

# src/components/Footer/Footer.tsx

```tsx
"use client"; import { Box, Container, SimpleGrid, Stack, Text, Group, ActionIcon, TextInput, Button, rem, Anchor, Divider, } from "@mantine/core"; import { Icon } from "@iconify/react"; import Image from "next/image"; // Logo Component (Daur ulang dari Navbar agar konsisten) const Logo = () => ( <Group gap={8} style={{ cursor: "pointer" }} wrap="nowrap"> <Image src="/logo.png" alt="Supawazap Logo" width={32} height={32} style={{ objectFit: "contain", filter: "drop-shadow(0 0 10px rgba(16, 185, 129, 0.4))", }} /> <Text fw={"bold"} size={"xl"} c="white" style={{ letterSpacing: "-0.02em", transition: "all 0.3s ease", }} > Supa <Text span c="emerald.5" fw={"bold"} size="xl"> wazap </Text> </Text> </Group> ); const SOCIAL_LINKS = [ { icon: "tabler:brand-twitter", link: "#" }, { icon: "tabler:brand-youtube", link: "#" }, ]; const FOOTER_DATA = [ { title: "Links", links: [ { label: "Features", link: "#features" }, { label: "Pricing", link: "#pricing" }, ], }, { title: "Legal", links: [ { label: "Privacy Policy", link: "/privacy" }, { label: "Terms of Service", link: "/terms" }, ], }, { title: "More", links: [], }, ]; export function Footer() { return ( <Box component="footer" style={{ backgroundColor: "#02040a", // Warna sedikit lebih gelap dari body borderTop: "1px solid rgba(255, 255, 255, 0.05)", position: "relative", overflow: "hidden", paddingTop: rem(80), paddingBottom: rem(40), marginTop: rem(100), }} > {/* --- 1. GIANT WATERMARK --- */} {/* Teks besar di background untuk estetika premium */} <Text style={{ position: "absolute", bottom: -40, left: "50%", transform: "translateX(-50%)", fontSize: "clamp(6rem, 15vw, 15rem)", // Responsive font size fontWeight: 900, color: "white", opacity: 0.02, // Sangat tipis lineHeight: 1, whiteSpace: "nowrap", pointerEvents: "none", zIndex: 0, letterSpacing: "-0.05em", userSelect: "none", }} > SUPAWAZAP </Text> <Container size="xl" style={{ position: "relative", zIndex: 1 }}> <SimpleGrid cols={{ base: 1, sm: 2, md: 4 }} spacing={50}> {/* KOLOM 1: BRAND IDENTITY */} <Stack gap="lg"> <Logo /> <Text c="dimmed" size="sm" lh={1.6} maw={300}> The ultimate local-first WhatsApp CRM and automation tool. Supercharge your workflow without compromising privacy. </Text> {/* Social Icons */} <Group gap="xs"> {SOCIAL_LINKS.map((item, index) => ( <ActionIcon key={index} variant="subtle" color="gray" size="lg" radius="md" component="a" href={item.link} style={{ border: "1px solid rgba(255,255,255,0.05)", transition: "all 0.2s", }} onMouseEnter={(e) => { e.currentTarget.style.borderColor = "rgba(255,255,255,0.2)"; e.currentTarget.style.backgroundColor = "rgba(255,255,255,0.05)"; e.currentTarget.style.color = "#fff"; }} onMouseLeave={(e) => { e.currentTarget.style.borderColor = "rgba(255,255,255,0.05)"; e.currentTarget.style.backgroundColor = "transparent"; e.currentTarget.style.color = "var(--mantine-color-gray-6)"; }} > <Icon icon={item.icon} width={20} /> </ActionIcon> ))} </Group> </Stack> {/* KOLOM 2 & 3: LINKS */} {FOOTER_DATA.map((group) => ( <Stack key={group.title} gap="md"> <Text c="white" fw={700} size="sm" tt="uppercase"> {group.title} </Text> <Stack gap="sm"> {group.links.map((link) => ( <Anchor key={link.label} href={link.link} c="dimmed" size="sm" underline="never" style={{ transition: "color 0.2s, transform 0.2s", display: "inline-block", }} onMouseEnter={(e) => { e.currentTarget.style.color = "#34d399"; // Emerald-400 e.currentTarget.style.transform = "translateX(4px)"; }} onMouseLeave={(e) => { e.currentTarget.style.color = "var(--mantine-color-dimmed)"; e.currentTarget.style.transform = "translateX(0)"; }} > {link.label} </Anchor> ))} </Stack> </Stack> ))} </SimpleGrid> </Container> </Box> ); }
```

# src/components/Navbar/Navbar.tsx

```tsx
"use client"; import { Box, Button, Burger, Drawer, Group, Stack, Text, UnstyledButton, rem, Transition, } from "@mantine/core"; import { useDisclosure } from "@mantine/hooks"; import { Chrome, Download } from "lucide-react"; import Image from "next/image"; import Link from "next/link"; import { useState, useEffect } from "react"; // --- Components --- const Logo = ({ compact }: { compact?: boolean }) => ( <Group gap={8} style={{ cursor: "pointer" }} wrap="nowrap"> <Image src="/logo.png" alt="Supawazap Logo" width={compact ? 28 : 32} height={compact ? 28 : 32} style={{ objectFit: "contain", filter: "drop-shadow(0 0 10px rgba(16, 185, 129, 0.4))", }} /> <Text fw={"bold"} size={"xl"} c="white" style={{ letterSpacing: "-0.02em", transition: "all 0.3s ease", }} > Supa <Text span c="emerald.5" fw={"bold"} size="xl"> wazap </Text> </Text> </Group> ); const links = [ { link: "#pricing", label: "Pricing" }, { link: "/privacy", label: "Privacy Policy" }, ]; export function Navbar() { const [opened, { toggle, close }] = useDisclosure(false); const [active, setActive] = useState(links[0].link); const [scrolled, setScrolled] = useState(false); // Handle scroll effect useEffect(() => { const handleScroll = () => { setScrolled(window.scrollY > 50); }; window.addEventListener("scroll", handleScroll); return () => window.removeEventListener("scroll", handleScroll); }, []); // Handle smooth scroll for anchor links const handleSmoothScroll = ( e: React.MouseEvent<HTMLButtonElement>, href: string ) => { e.preventDefault(); const targetId = href.replace("#", ""); const targetElement = document.getElementById(targetId); if (targetElement) { const navbarHeight = 100; // Offset for fixed navbar const elementPosition = targetElement.getBoundingClientRect().top; const offsetPosition = elementPosition + window.scrollY - navbarHeight; window.scrollTo({ top: offsetPosition, behavior: "smooth", }); } setActive(href); }; const items = links.map((link) => { const isExternal = link.link.startsWith("/"); const isAnchor = link.link.startsWith("#"); if (isExternal) { return ( <Link key={link.label} href={link.link} style={{ fontSize: rem(16), fontWeight: 500, color: "var(--text-secondary)", transition: "all 0.2s ease", padding: "6px 16px", borderRadius: "99px", textDecoration: "none", }} onMouseEnter={(e) => { e.currentTarget.style.color = "var(--text-primary)"; e.currentTarget.style.backgroundColor = "rgba(255, 255, 255, 0.05)"; }} onMouseLeave={(e) => { e.currentTarget.style.color = "var(--text-secondary)"; e.currentTarget.style.backgroundColor = "transparent"; }} > {link.label} </Link> ); } return ( <UnstyledButton key={link.label} onClick={(e) => isAnchor && handleSmoothScroll(e, link.link)} style={{ fontSize: rem(16), fontWeight: 500, color: active === link.link ? "var(--brand-emerald-400)" : "var(--text-secondary)", transition: "all 0.2s ease", padding: "6px 16px", borderRadius: "99px", }} onMouseEnter={(e) => { if (active !== link.link) { e.currentTarget.style.color = "var(--text-primary)"; e.currentTarget.style.backgroundColor = "rgba(255, 255, 255, 0.05)"; } }} onMouseLeave={(e) => { if (active !== link.link) { e.currentTarget.style.color = "var(--text-secondary)"; e.currentTarget.style.backgroundColor = "transparent"; } }} > {link.label} </UnstyledButton> ); }); return ( <> {/* Floating Navbar Container */} <Box component="header" style={{ position: "fixed", top: scrolled ? 20 : 16, // Moves up slightly when scrolled left: "50%", transform: "translateX(-50%)", zIndex: 100, width: "100%", maxWidth: scrolled ? "800px" : "1152px", // Shrinks width on scroll transition: "all 0.4s cubic-bezier(0.4, 0, 0.2, 1)", // Smooth premium easing padding: "0 16px", // Safe area for mobile }} > <Box py={scrolled ? 8 : 12} px={scrolled ? 16 : 24} style={{ backgroundColor: scrolled ? "rgba(10, 10, 10, 0.85)" // Darker background when scrolled : "rgba(15, 23, 42, 0.4)", // Lighter initially backdropFilter: "blur(16px) saturate(180%)", WebkitBackdropFilter: "blur(16px) saturate(180%)", borderRadius: "9999px", // Full pill shape border: "1px solid rgba(255, 255, 255, 0.08)", boxShadow: scrolled ? "0 20px 40px -10px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255,255,255,0.05)" : "0 4px 30px rgba(0, 0, 0, 0.1)", transition: "all 0.4s ease", }} > <Group justify="space-between" align="center" wrap="nowrap"> {/* Left: Logo */} <Logo compact={scrolled} /> {/* Center: Navigation Links (Desktop) */} <Group gap={4} visibleFrom="sm"> {items} </Group> {/* Right: Actions */} <Group gap={12} wrap="nowrap"> {/* Premium Button */} <Button variant="filled" color="emerald" size={scrolled ? "xs" : "sm"} radius="xl" leftSection={<Chrome size={scrolled ? 14 : 16} />} visibleFrom="xs" className="btn-primary-action" // Menggunakan class premium yang kita bahas sebelumnya style={{ height: scrolled ? 32 : 40, transition: "all 0.3s ease", fontSize: scrolled ? 13 : 14, }} > Install Free </Button> {/* Mobile Menu Toggle */} <Burger opened={opened} onClick={toggle} hiddenFrom="sm" size="sm" color="white" aria-label="Toggle navigation" /> </Group> </Group> </Box> </Box> {/* Mobile Drawer */} <Drawer opened={opened} onClose={close} size="100%" padding="md" title={<Logo />} hiddenFrom="sm" transitionProps={{ duration: 200, transition: "slide-down", }} styles={{ content: { backgroundColor: "#030712", // Matches global background color: "white", }, header: { backgroundColor: "transparent", color: "white", }, close: { color: "white", }, }} // Add noise texture to drawer background as well for consistency style={{ zIndex: 200 }} > <Stack gap="xl" mt="xl" align="center"> {links.map((link) => { const isExternal = link.link.startsWith("/"); if (isExternal) { return ( <Link key={link.label} href={link.link} onClick={close} style={{ fontSize: rem(24), fontWeight: 600, color: "white", textDecoration: "none", }} > {link.label} </Link> ); } const isAnchor = link.link.startsWith("#"); return ( <UnstyledButton key={link.label} onClick={(e) => { if (isAnchor) { handleSmoothScroll(e, link.link); } close(); }} style={{ fontSize: rem(24), fontWeight: 600, color: active === link.link ? "var(--brand-emerald-400)" : "white", }} > {link.label} </UnstyledButton> ); })} <Button fullWidth size="xl" variant="filled" color="emerald" radius="xl" leftSection={<Download size={20} />} mt="xl" className="btn-primary-action" > Install Extension </Button> </Stack> </Drawer> </> ); }
```

# src/components/PainVsGain/PainVsGain.tsx

```tsx
"use client"; import { Box, Container, SimpleGrid, Stack, Text, Title, rem, ThemeIcon, Group, Badge, Paper, } from "@mantine/core"; import { Icon } from "@iconify/react"; import { PremiumCard } from "@/components/PremiumCard"; // Pastikan path ini sesuai const TRANSFORMATIONS = [ { icon: "tabler:keyboard-off", title: "Manual Typing", pain: "Wasting 2 hours daily typing the same welcome message.", gain: "Reply in milliseconds with Quick Replies & Spintax.", stat: "10x Faster", }, { icon: "tabler:clock-bolt", title: "Follow-up Timing", pain: "Forgetting to follow up and losing warm leads.", gain: "Never miss a beat with Scheduled Messages & Reminders.", stat: "0 Missed Leads", }, { icon: "tabler:repeat", title: "Repetitive Tasks", pain: "Copy-pasting the same info to every new contact.", gain: "Automate workflows once, let them run forever.", stat: "90% Less Work", }, { icon: "tabler:broadcast", title: "Mass Messaging", pain: "Manually forwarding updates to hundreds of customers one by one.", gain: "Broadcast personalized campaigns to unlimited contacts instantly.", stat: "Unlimited Reach", }, { icon: "tabler:address-book", title: "Messy Contacts", pain: "Losing track of leads mixed with family and friends chats.", gain: "Organize with CRM tags, custom fields, and smart labels.", stat: "Total Clarity", }, { icon: "tabler:eye-off", title: "Prying Eyes", pain: "Sensitive customer data visible to everyone when working in public.", gain: "Auto-blur messages and names for complete privacy.", stat: "100% Private", }, { icon: "tabler:message-plus", title: "Phone Clutter", pain: "Saving temporary numbers to contacts just to send one message.", gain: "Message any number instantly without saving to your phone.", stat: "Clean Contacts", }, { icon: "tabler:users-group", title: "Manual Copying", pain: "Manually copying hundreds of group members into a spreadsheet.", gain: "Scrape and export all group participants to Excel in one click.", stat: "Instant Leads", }, { icon: "tabler:calendar-star", title: "Missed Prime Time", pain: "Posting status updates manually at odd hours when no one watches.", gain: "Schedule WhatsApp Statuses (Text/Media) for the entire week.", stat: "Max Views", }, ]; export function PainVsGain() { return ( <Box py={{ base: 60, md: 120 }} style={{ position: "relative" }}> {/* Background Decor: Subtle gradient beam behind the section */} <Box style={{ position: "absolute", top: "0%", left: "50%", transform: "translateX(-50%)", width: "100%", height: "100%", background: "radial-gradient(ellipse at center, rgba(16, 185, 129, 0.05) 0%, transparent 60%)", zIndex: 0, pointerEvents: "none", }} /> <Container size="lg" style={{ position: "relative", zIndex: 1 }}> {/* Section Header */} <Stack align="center" mb={{ base: 50, md: 80 }} gap="sm"> <Title order={2} ta="center" style={{ fontSize: rem(42) }} className="text-gradient" > Stop The Manual Grind. </Title> <Text c="dimmed" ta="center" maw={600} size="lg"> See exactly how Supawazap replaces your daily headaches with automated efficiency. </Text> </Stack> {/* Transformation Grid */} <SimpleGrid cols={{ base: 1, md: 3 }} spacing={30}> {TRANSFORMATIONS.map((item, index) => ( <PremiumCard key={index}> <Stack h="100%" justify="space-between" gap="lg"> {/* Header Icon */} <Group justify="space-between" align="start"> <ThemeIcon size={56} radius="xl" variant="gradient" gradient={{ from: "emerald.9", to: "emerald.6", deg: 135 }} style={{ boxShadow: "0 8px 20px rgba(16, 185, 129, 0.2)", border: "1px solid rgba(255,255,255,0.1)", }} > <Icon icon={item.icon} width={28} /> </ThemeIcon> <Badge size="md" variant="light" color="emerald" style={{ backgroundColor: "rgba(16, 185, 129, 0.1)", color: "#34d399", }} > {item.stat} </Badge> </Group> <Stack gap="md" style={{ flex: 1 }}> <Text fw={700} size="xl" c="white"> {item.title} </Text> {/* The Pain (Old Way) */} <Group gap="sm" align="start" wrap="nowrap" style={{ opacity: 0.6 }} > <Icon icon="tabler:x" color="#ef4444" width={20} style={{ marginTop: 4, flexShrink: 0 }} /> <Text size="sm" c="gray.5" lh={1.5}> {item.pain} </Text> </Group> {/* Visual Connector Line */} <Box pl={9} // Align with icons py={2} > <Box w={2} h={20} bg="linear-gradient(to bottom, #ef4444 0%, #10b981 100%)" style={{ opacity: 0.3 }} /> </Box> {/* The Gain (New Way) */} <Group gap="sm" align="start" wrap="nowrap"> <ThemeIcon size={20} radius="xl" color="emerald" variant="filled" style={{ marginTop: 2, flexShrink: 0 }} > <Icon icon="tabler:check" width={12} /> </ThemeIcon> <Text size="md" fw={600} c="emerald.3" // Lighter emerald for text readability on dark bg lh={1.4} style={{ textShadow: "0 0 20px rgba(52, 211, 153, 0.2)", }} > {item.gain} </Text> </Group> </Stack> </Stack> </PremiumCard> ))} </SimpleGrid> </Container> </Box> ); }
```

# src/components/PremiumCard.tsx

```tsx
"use client"; import { Box, Paper, PaperProps } from "@mantine/core"; import { useState } from "react"; interface PremiumCardProps extends PaperProps { children: React.ReactNode; } export function PremiumCard({ children, ...props }: PremiumCardProps) { const [isHovered, setIsHovered] = useState(false); return ( <Box onMouseEnter={() => setIsHovered(true)} onMouseLeave={() => setIsHovered(false)} style={{ position: "relative", height: "100%", borderRadius: "1rem", // 16px (matches radius="lg") // Background container (agar border terlihat) padding: "1px", // Ketebalan border overflow: "hidden", transition: "transform 0.3s ease, box-shadow 0.3s ease", transform: isHovered ? "translateY(-4px)" : "translateY(0)", boxShadow: isHovered ? "0 10px 40px -10px rgba(16, 185, 129, 0.3)" // Emerald Glow : "0 0 0 0 transparent", cursor: "default", isolation: "isolate", // Membuat stacking context baru }} > {/* 1. ANIMATED ROTATING BORDER LAYER */} <div style={{ position: "absolute", inset: "-50%", // Membuat layer jauh lebih besar dari kartu background: "conic-gradient(from 0deg, transparent 0 340deg, #10b981 360deg)", // Emerald Tail opacity: isHovered ? 1 : 0, transition: "opacity 0.3s ease", animation: "rotate-border 4s linear infinite", // Animasi putaran zIndex: 0, }} /> {/* 2. STATIC BORDER LAYER (Saat tidak di-hover) */} <div style={{ position: "absolute", inset: 0, background: "rgba(255, 255, 255, 0.1)", // Border abu-abu diam zIndex: 0, borderRadius: "1rem", }} /> {/* 3. INNER CONTENT CARD */} <Paper radius="lg" p="xl" style={{ position: "relative", height: "100%", zIndex: 1, // Di atas animasi border backgroundColor: "#0b1016", // Background kartu (harus solid/dark agar menutupi tengah animasi) // Opsional: Sedikit transparan jika mau background page terlihat dikit // backgroundColor: "rgba(11, 16, 22, 0.95)", }} {...props} > {children} </Paper> {/* INJECT KEYFRAMES untuk animasi putar */} </Box> ); }
```

# src/components/Pricing/Pricing.tsx

```tsx
"use client"; import { Box, Button, Card, Container, Group, List, Paper, Progress, Stack, Text, ThemeIcon, Title, rem, Badge, } from "@mantine/core"; import { Icon } from "@iconify/react"; const FEATURES = [ "ðŸ”“ Unlock ALL Pro Features Instantly", "ðŸš€ Unlimited Usage & Contacts (No Caps)", "ðŸ¤ Lifetime Updates & Support", "ðŸ’³ No monthly fees, No subscription", "ðŸ”‘ Pay once, access forever", ]; export function Pricing() { return ( <Box py={{ base: 60, md: 100 }} id="pricing" style={{ position: "relative" }} > {/* Background Glow Effect (Emerald for Brand Consistency) */} <Box style={{ position: "absolute", top: "50%", left: "50%", transform: "translate(-50%, -50%)", width: "100%", maxWidth: "800px", height: "600px", background: "radial-gradient(circle, rgba(16, 185, 129, 0.15) 0%, transparent 70%)", // Emerald Glow zIndex: 0, pointerEvents: "none", }} /> <Container size="md" style={{ position: "relative", zIndex: 1 }}> <Stack align="center" gap="xl"> {/* Headlines */} <Stack gap="xs" align="center" ta="center"> <Title order={2} className="text-gradient" // Menggunakan class global Anda style={{ fontSize: rem(48), fontWeight: 800, lineHeight: 1.1, }} > Limited Time Offer â€“ Save $70! </Title> <Text c="dimmed" size="lg"> Get lifetime access to all Supawazap Pro tools for just $29 </Text> </Stack> {/* Urgency Warning Box */} <Paper radius="md" p="xs" px="lg" style={{ backgroundColor: "rgba(6, 78, 59, 0.4)", // Dark Emerald bg border: "1px solid rgba(16, 185, 129, 0.3)", backdropFilter: "blur(4px)", }} > <Group gap={8}> <Icon icon="tabler:flame" color="#34d399" /> <Text size="sm" fw={500} c="emerald.1"> Once these slots are gone, price goes back to $99 </Text> </Group> </Paper> {/* --- MAIN PRICING CARD --- */} <Card radius={24} p={{ base: "xl", md: 50 }} w="100%" maw={550} style={{ // Glassmorphism Premium Style sesuai theme backgroundColor: "rgba(10, 10, 10, 0.8)", backdropFilter: "blur(20px)", border: "1px solid rgba(52, 211, 153, 0.3)", // Emerald Border Highlight boxShadow: "0 0 60px -20px rgba(16, 185, 129, 0.2)", // Emerald Ambient Glow position: "relative", overflow: "visible", }} > {/* Absolute Badge inside Card */} <Badge variant="filled" color="emerald" size="lg" radius="sm" style={{ position: "absolute", top: 30, left: 30, backgroundColor: "rgba(16, 185, 129, 0.15)", color: "#6ee7b7", border: "1px solid rgba(16, 185, 129, 0.2)", }} > â— Only 5 of 100 left </Badge> <Stack gap={30} mt="xl"> {/* Price Display */} <Box ta="center" style={{ position: "relative" }}> {/* Floating Discount Tag */} <Badge variant="gradient" gradient={{ from: "emerald.6", to: "emerald.4", deg: 45 }} size="lg" radius="md" style={{ position: "absolute", top: -10, right: 0, transform: "rotate(12deg)", boxShadow: "0 4px 15px rgba(16, 185, 129, 0.3)", color: "#022c22", // Dark text for contrast on bright emerald fontWeight: 800, }} > $70 OFF </Badge> <Group justify="center" align="center" gap="xs"> <Text td="line-through" c="dimmed" fw={500} style={{ fontSize: rem(32) }} > $99 </Text> <Text fw={800} style={{ fontSize: rem(80), lineHeight: 1, // Gradient Text sesuai theme background: "linear-gradient(to bottom, #ffffff, #34d399)", WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent", filter: "drop-shadow(0 0 20px rgba(16, 185, 129, 0.3))", }} > $29 </Text> </Group> <Text size="sm" tt="uppercase" c="dimmed" fw={600} mt="xs" style={{ letterSpacing: "0.1em" }} > One-time payment </Text> <Text size="xs" c="emerald.4" mt={4} fw={600}> Limited to first 100 customers </Text> </Box> {/* Progress Bar */} <Stack gap={6}> <Group justify="space-between"> <Text size="xs" fw={700} c="white"> 95 claimed </Text> <Text size="xs" fw={700} c="emerald.4"> 5 remaining </Text> </Group> <Progress value={95} size="xl" radius="xl" color="emerald" striped styles={{ root: { backgroundColor: "rgba(255,255,255,0.05)" }, section: { background: "linear-gradient(90deg, #059669, #34d399)", boxShadow: "0 0 10px rgba(52, 211, 153, 0.5)", }, }} /> </Stack> {/* Divider */} <Box h={1} w="100%" bg="rgba(255,255,255,0.1)" /> {/* Features List */} <Box> <Text fw={600} mb="md" size="lg" c="white"> What You Get: </Text> <List spacing="sm" center icon={ <ThemeIcon color="emerald" size={24} radius="xl" variant="light" > <Icon icon="tabler:check" width={14} strokeWidth={4} /> </ThemeIcon> } > {FEATURES.map((feature, index) => ( <List.Item key={index}> <Text size="md" c="gray.3"> {feature} </Text> </List.Item> ))} </List> </Box> {/* CTA Button */} <Stack gap="xs"> <Button size="xl" radius="md" fullWidth h={64} className="btn-primary-action" // Class dari globals.css leftSection={<Icon icon="tabler:rocket" width={24} />} style={{ fontSize: rem(18), fontWeight: 700, letterSpacing: "0.05em", }} > GET LIFETIME ACCESS </Button> <Group justify="center" gap={6} mt={4}> <Icon icon="tabler:shield-check" color="#34d399" width={16} /> <Text size="xs" c="dimmed"> 30-day money-back guarantee â€¢ Secure checkout via Lemon Squeezy </Text> </Group> </Stack> </Stack> </Card> </Stack> </Container> </Box> ); }
```

# src/components/SpotlightCard.tsx

```tsx
"use client"; import { Box, Paper, PaperProps } from "@mantine/core"; import { useRef, useState, MouseEvent } from "react"; interface SpotlightCardProps extends PaperProps { children: React.ReactNode; spotlightColor?: string; } export function SpotlightCard({ children, spotlightColor = "rgba(16, 185, 129, 0.35)", // Emerald glow default ...props }: SpotlightCardProps) { const divRef = useRef<HTMLDivElement>(null); const [position, setPosition] = useState({ x: 0, y: 0 }); const [opacity, setOpacity] = useState(0); const handleMouseMove = (e: MouseEvent<HTMLDivElement>) => { if (!divRef.current) return; const rect = divRef.current.getBoundingClientRect(); setPosition({ x: e.clientX - rect.left, y: e.clientY - rect.top }); }; const handleMouseEnter = () => { setOpacity(1); }; const handleMouseLeave = () => { setOpacity(0); }; return ( <Paper ref={divRef} onMouseMove={handleMouseMove} onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave} radius="lg" style={{ position: "relative", overflow: "hidden", backgroundColor: "rgba(2, 6, 23, 0.6)", // Dark transparent bg border: "1px solid rgba(255, 255, 255, 0.1)", // Base subtle border ...props.style, }} {...props} > {/* 1. Spotlight BORDER Layer */} <div style={{ pointerEvents: "none", position: "absolute", inset: -1, // Extends slightly outside to cover border opacity: opacity, transition: "opacity 0.3s", zIndex: 10, background: `radial-gradient(600px circle at ${position.x}px ${position.y}px, ${spotlightColor}, transparent 40%)`, // Masking technique to only show the gradient on the border area maskImage: ` linear-gradient(black, black), linear-gradient(black, black) `, maskClip: "content-box, border-box", padding: "1px", // Thickness of the spotlight border maskComposite: "exclude", WebkitMaskComposite: "xor", }} /> {/* 2. Spotlight INNER GLOW Layer (Optional: Adds depth inside) */} <div style={{ pointerEvents: "none", position: "absolute", inset: 0, opacity: opacity, transition: "opacity 0.3s", zIndex: 1, background: `radial-gradient(800px circle at ${position.x}px ${position.y}px, rgba(16, 185, 129, 0.06), transparent 40%)`, }} /> {/* Content */} <Box style={{ position: "relative", zIndex: 20 }}>{children}</Box> </Paper> ); }
```

# src/components/Stats.tsx

```tsx
import { Container, SimpleGrid, Stack, Text, Title, rem } from "@mantine/core"; const stats = [ { value: "98%", label: "Open Rate (vs 20% Email)" }, { value: "45%", label: "Response Rate (vs 2% Email)" }, { value: "90s", label: "Avg Response (vs 90 mins)" }, { value: "5x", label: "Higher Conversion" }, ]; export function Stats() { return ( <Container size="lg" py={100}> <Stack align="center" gap="lg" mb={60}> <Title order={2} ta="center" className="text-gradient" style={{ fontSize: rem(42), fontWeight: 800, lineHeight: 1.1, }} > Emails can't compete with these numbers </Title> <Text c="dimmed" ta="center" maw={700} style={{ fontSize: rem(20), lineHeight: 1.6 }} > Don't let your hard work end up in the spam folder. Compare the raw power of WhatsApp marketing against traditional email campaigns. </Text> </Stack> <SimpleGrid cols={{ base: 2, sm: 4 }} spacing={40} verticalSpacing={40}> {stats.map((stat) => ( <Stack key={stat.label} align="center" gap={4}> <Text fw={800} style={{ fontSize: rem(56), lineHeight: 1, letterSpacing: "-0.02em", color: "#10b981", // Emerald-500 matching the theme }} > {stat.value} </Text> <Text size="lg" c="dimmed" fw={600} mt="xs" style={{ fontSize: rem(18) }} > {stat.label} </Text> </Stack> ))} </SimpleGrid> </Container> ); }
```

# src/components/Testimonials.tsx

```tsx
"use client"; import { Icon } from "@iconify/react"; import { Avatar, Box, Container, Group, Paper, Rating, Stack, Text, Title, rem, ThemeIcon, } from "@mantine/core"; // Data diperbanyak agar marquee terlihat penuh const REVIEWS = [ { name: "David Reus", role: "E-commerce Owner", content: "The Visual Workflow Builder is insane. I set up an auto-reply for 'Price' and 'Shipping' in 5 minutes. It feels like having a 24/7 VA.", avatar: "https://i.pravatar.cc/150?img=15", }, { name: "Marcus Reid", role: "Event Organizer", content: "Finally, a tool that stores data LOCALLY. I don't trust other extensions with my client list. Supawazap respects privacy.", avatar: "https://i.pravatar.cc/150?img=53", }, { name: "Elena Rodriguez", role: "Digital Marketer", content: "The Spintax engine is brilliant. My open rates increased by 40% because messages don't look like generic spam anymore.", avatar: "https://i.pravatar.cc/150?img=24", }, { name: "James Wilson", role: "SaaS Founder", content: "Direct Chat and Link Generator save me hours every week. The best productivity tool for WhatsApp Web hands down.", avatar: "https://i.pravatar.cc/150?img=60", }, { name: "Liam Chen", role: "Startup Founder", content: "Supawazap has completely transformed our outreach process. It's a game changer for connecting with potential partners.", avatar: "https://i.pravatar.cc/150?img=12", }, { name: "Sophia Patel", role: "Senior Recruiter", content: "I was worried about safety, but the batching feature is rock solid. My candidate response rates have doubled.", avatar: "https://i.pravatar.cc/150?img=44", }, { name: "Noah Kim", role: "Sales Lead", content: "The CRM features are surprisingly robust. Being able to tag and segment leads directly in WhatsApp is invaluable.", avatar: "https://i.pravatar.cc/150?img=68", }, { name: "Olivia Davis", role: "Event Planner", content: "Broadcasting event updates used to take all day. Now I can reach hundreds of attendees in minutes with personalized messages.", avatar: "https://i.pravatar.cc/150?img=36", }, { name: "Ethan Wright", role: "Education Consultant", content: "My students appreciate the quick responses. The automation tools save me at least 10 hours a week.", avatar: "https://i.pravatar.cc/150?img=59", }, { name: "Ava Wilson", role: "Agency Director", content: "Managing multiple client profiles was a nightmare before. Supawazap makes it effortless to switch and stay organized.", avatar: "https://i.pravatar.cc/150?img=25", }, { name: "Mason Thompson", role: "Freelance Developer", content: "Incredible ROI. It's affordable, powerful, and simpler to use than the complex enterprise tools I've tried.", avatar: "https://i.pravatar.cc/150?img=53", }, { name: "Isabella Martinez", role: "Customer Success", content: "The Quick Replies and Spintax features are lifesavers. I can clear my support queue in half the time.", avatar: "https://i.pravatar.cc/150?img=16", }, { name: "Lucas Brown", role: "Gym Owner", content: "Automated class reminders have reduced our no-show rate by nearly 50%. Essential tool for any local business.", avatar: "https://i.pravatar.cc/150?img=11", }, { name: "Mia Garcia", role: "Real Estate Broker", content: "Being able to send personalized property listings to hot leads instantly has directly increased my closings.", avatar: "https://i.pravatar.cc/150?img=9", }, ]; // Komponen Kartu Testimonial const TestimonialCard = ({ review }: { review: (typeof REVIEWS)[0] }) => ( <Paper p="xl" radius="lg" w={350} // Lebar fix agar marquee rapi style={{ background: "rgba(255, 255, 255, 0.03)", backdropFilter: "blur(12px)", WebkitBackdropFilter: "blur(12px)", border: "1px solid rgba(255, 255, 255, 0.05)", transition: "transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s", height: "100%", }} onMouseEnter={(e) => { e.currentTarget.style.borderColor = "rgba(16, 185, 129, 0.3)"; e.currentTarget.style.backgroundColor = "rgba(255, 255, 255, 0.05)"; }} onMouseLeave={(e) => { e.currentTarget.style.borderColor = "rgba(255, 255, 255, 0.05)"; e.currentTarget.style.backgroundColor = "rgba(255, 255, 255, 0.03)"; }} > <Stack justify="space-between" h="100%" gap="lg"> <Stack gap="md"> <Group justify="space-between" align="start"> <ThemeIcon variant="light" color="emerald" size="lg" radius="xl" style={{ backgroundColor: "rgba(16, 185, 129, 0.1)" }} > <Icon icon="tabler:quote" width={20} /> </ThemeIcon> <Rating value={5} readOnly color="emerald" size="xs" /> </Group> <Text size="md" c="gray.3" lh={1.6} style={{ fontStyle: "italic" }}> "{review.content}" </Text> </Stack> <Group gap="md"> <Avatar src={review.avatar} size="md" radius="xl" /> <Box> <Text fw={600} c="white" size="sm"> {review.name} </Text> <Text size="xs" c="dimmed"> {review.role} </Text> </Box> </Group> </Stack> </Paper> ); export function Testimonials() { return ( <Box py={{ base: 60, md: 120 }} style={{ position: "relative", overflow: "hidden", backgroundColor: "#030712", // Background gelap konsisten }} > {/* Background Glow Effect */} <Box style={{ position: "absolute", top: "50%", left: "50%", transform: "translate(-50%, -50%)", width: "60%", height: "100%", background: "radial-gradient(ellipse at center, rgba(16, 185, 129, 0.05) 0%, transparent 70%)", zIndex: 0, pointerEvents: "none", }} /> <Container size="lg" style={{ position: "relative", zIndex: 1 }} mb={60}> <Stack align="center" gap="xs"> <Title order={2} ta="center" style={{ fontSize: rem(42) }} className="text-gradient" > Trusted by Professionals </Title> <Text c="dimmed" ta="center" maw={600} size="lg"> Join the community of marketers, agents, and business owners who trust Supawazap. </Text> </Stack> </Container> {/* --- MARQUEE ROWS --- */} <Stack gap={30}> {/* Row 1: Bergerak ke Kiri */} <div className="marquee-container"> <div className="marquee-content animate-scroll-left"> {/* Render 2x untuk looping seamless */} {[...REVIEWS, ...REVIEWS].map((review, index) => ( <TestimonialCard key={`row1-${index}`} review={review} /> ))} </div> </div> {/* Row 2: Bergerak ke Kanan (Opsional: reverse data agar variatif) */} <div className="marquee-container"> <div className="marquee-content animate-scroll-right"> {[...REVIEWS, ...REVIEWS].reverse().map((review, index) => ( <TestimonialCard key={`row2-${index}`} review={review} /> ))} </div> </div> </Stack> </Box> ); }
```

# src/components/Typewriter.tsx

```tsx
"use client"; import { useEffect, useState } from "react"; interface TypewriterProps { words: string[]; typingSpeed?: number; deletingSpeed?: number; pauseTime?: number; } export function Typewriter({ words, typingSpeed = 150, deletingSpeed = 100, pauseTime = 2000, }: TypewriterProps) { const [index, setIndex] = useState(0); const [subIndex, setSubIndex] = useState(0); const [reverse, setReverse] = useState(false); const [blink, setBlink] = useState(true); // Blinking cursor useEffect(() => { const timeout2 = setTimeout(() => { setBlink((prev) => !prev); }, 500); return () => clearTimeout(timeout2); }, [blink]); useEffect(() => { if (index >= words.length) { setIndex(0); return; } if (subIndex === words[index].length + 1 && !reverse) { const timeout = setTimeout(() => { setReverse(true); }, pauseTime); return () => clearTimeout(timeout); } if (subIndex === 0 && reverse) { setReverse(false); setIndex((prev) => (prev + 1) % words.length); return; } const timeout = setTimeout( () => { setSubIndex((prev) => prev + (reverse ? -1 : 1)); }, reverse ? deletingSpeed : typingSpeed ); return () => clearTimeout(timeout); }, [subIndex, index, reverse, words, typingSpeed, deletingSpeed, pauseTime]); return ( <span> {words[index].substring(0, subIndex)} <span style={{ opacity: blink ? 1 : 0, marginLeft: "2px", borderRight: "3px solid currentColor", }} > &#8203; </span> </span> ); }
```

# src/theme.ts

```ts
import { createTheme, rem } from "@mantine/core"; export const theme = createTheme({ colors: { // Custom emerald scale based on brand colors emerald: [ "#ecfdf5", // 0 "#d1fae5", // 1 "#a7f3d0", // 2 "#6ee7b7", // 3 (Brand 300) "#34d399", // 4 (Brand 400 - Accent) "#10b981", // 5 (Brand 500 - Primary) "#059669", // 6 (Brand 600) "#047857", // 7 "#065f46", // 8 "#064e3b", // 9 ], }, primaryColor: "emerald", primaryShade: 5, fontFamily: "var(--font-geist-sans), 'Inter', system-ui, sans-serif", fontFamilyMonospace: "'Space Mono', var(--font-geist-mono), monospace", headings: { fontFamily: "var(--font-geist-sans), 'Inter', system-ui, sans-serif", sizes: { h1: { fontSize: rem(60), lineHeight: "1", fontWeight: "400" }, // 3.75rem h2: { fontSize: rem(36), lineHeight: rem(40), fontWeight: "500" }, // 2.25rem }, }, defaultRadius: "md", components: { Button: { defaultProps: { radius: "xl", // Pill shape from design system }, }, Card: { defaultProps: { radius: "lg", }, }, }, other: { aesthetic: "Cyber-Organic Fintech", }, });
```

# tsconfig.json

```json
{ "compilerOptions": { "target": "ES2017", "lib": ["dom", "dom.iterable", "esnext"], "allowJs": true, "skipLibCheck": true, "strict": true, "noEmit": true, "esModuleInterop": true, "module": "esnext", "moduleResolution": "bundler", "resolveJsonModule": true, "isolatedModules": true, "jsx": "react-jsx", "incremental": true, "plugins": [ { "name": "next" } ], "paths": { "@/*": ["./src/*"] } }, "include": [ "next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts", ".next/dev/types/**/*.ts", "**/*.mts" ], "exclude": ["node_modules"] }
```

